{"version":3,"sources":["webpack:///path---guide-ocaml-2ca14420b62310f8bbae.js","webpack:///./.cache/json/guide-ocaml.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/guide-ocaml.json","module","exports","data","allFile","edges","node","relativePath","childMarkdownRemark","frontmatter","title","order","file","html","pathContext","section","sectionTitle","relatedFiles"],"mappings":"AAAAA,cAAc,KAERC,qEACA,SAAUC,EAAQC,GCHxBD,EAAAC,SACAC,MACAC,SACAC,QAEAC,MACAC,aAAA,wBACAC,qBACAC,aACAC,MAAA,eACAC,MAAA,OAMAL,MACAC,aAAA,oBACAC,qBACAC,aACAC,MAAA,WACAC,MAAA,QAMAL,MACAC,aAAA,2BACAC,qBACAC,aACAC,MAAA,kBACAC,MAAA,OAMAL,MACAC,aAAA,iBACAC,qBACAC,aACAC,MAAA,mBACAC,MAAA,OAMAL,MACAC,aAAA,iBACAC,qBACAC,aACAC,MAAA,sBACAC,MAAA,QAMAL,MACAC,aAAA,iBACAC,qBACAC,aACAC,MAAA,QACAC,MAAA,OAMAL,MACAC,aAAA,4BACAC,qBACAC,aACAC,MAAA,aACAC,MAAA,OAMAL,MACAC,aAAA,iCACAC,qBACAC,aACAC,MAAA,qBACAC,MAAA,OAMAL,MACAC,aAAA,gCACAC,qBACAC,aACAC,MAAA,YACAC,MAAA,OAMAL,MACAC,aAAA,8BACAC,qBACAC,aACAC,MAAA,UACAC,MAAA,OAMAL,MACAC,aAAA,iCACAC,qBACAC,aACAC,MAAA,aACAC,MAAA,OAMAL,MACAC,aAAA,wCACAC,qBACAC,aACAC,MAAA,oBACAC,MAAA,OAMAL,MACAC,aAAA,iCACAC,qBACAC,aACAC,MAAA,eACAC,MAAA,OAMAL,MACAC,aAAA,+BACAC,qBACAC,aACAC,MAAA,sBACAC,MAAA,OAMAL,MACAC,aAAA,kCACAC,qBACAC,aACAC,MAAA,mCACAC,MAAA,OAMAL,MACAC,aAAA,8BACAC,qBACAC,aACAC,MAAA,YACAC,MAAA,OAMAL,MACAC,aAAA,qCACAC,qBACAC,aACAC,MAAA,mBACAC,MAAA,OAMAL,MACAC,aAAA,0BACAC,qBACAC,aACAC,MAAA,kBACAC,MAAA,OAMAL,MACAC,aAAA,wBACAC,qBACAC,aACAC,MAAA,MACAC,MAAA,QAMAL,MACAC,aAAA,iCACAC,qBACAC,aACAC,MAAA,eACAC,MAAA,OAMAL,MACAC,aAAA,4BACAC,qBACAC,aACAC,MAAA,UACAC,MAAA,QAMAL,MACAC,aAAA,+BACAC,qBACAC,aACAC,MAAA,gBACAC,MAAA,OAMAL,MACAC,aAAA,mCACAC,qBACAC,aACAC,MAAA,oBACAC,MAAA,OAMAL,MACAC,aAAA,6BACAC,qBACAC,aACAC,MAAA,WACAC,MAAA,OAMAL,MACAC,aAAA,+BACAC,qBACAC,aACAC,MAAA,aACAC,MAAA,OAMAL,MACAC,aAAA,0BACAC,qBACAC,aACAC,MAAA,QACAC,MAAA,OAMAL,MACAC,aAAA,qCACAC,qBACAC,aACAC,MAAA,wBACAC,MAAA,OAMAL,MACAC,aAAA,wBACAC,qBACAC,aACAC,MAAA,SACAC,MAAA,OAMAL,MACAC,aAAA,6BACAC,qBACAC,aACAC,MAAA,aACAC,MAAA,QAOAC,MACAL,aAAA,iBACAC,qBACAK,KAAA;AACAJ,aACAC,MAAA,0BAKAI,aACAC,QAAA,QACAC,aAAA,QACAT,aAAA,iBACAU,aAAA","file":"path---guide-ocaml-2ca14420b62310f8bbae.js","sourcesContent":["webpackJsonp([12],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/guide-ocaml.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"data\": {\n\t\t\t\"allFile\": {\n\t\t\t\t\"edges\": [\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/editor-setup.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Editor setup\",\n\t\t\t\t\t\t\t\t\t\"order\": 1\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/examples.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Examples\",\n\t\t\t\t\t\t\t\t\t\"order\": 20\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/getting-started.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Getting started\",\n\t\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/index.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"The Reason Guide\",\n\t\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/ocaml.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Comparison to OCaml\",\n\t\t\t\t\t\t\t\t\t\"order\": 10\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/tools.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Tools\",\n\t\t\t\t\t\t\t\t\t\"order\": 4\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/javascript/index.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"JavaScript\",\n\t\t\t\t\t\t\t\t\t\"order\": 4\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/javascript/converting.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Converting from JS\",\n\t\t\t\t\t\t\t\t\t\"order\": 5\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/javascript/libraries.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Libraries\",\n\t\t\t\t\t\t\t\t\t\"order\": 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/javascript/interop.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Interop\",\n\t\t\t\t\t\t\t\t\t\"order\": 1\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/javascript/quickstart.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Quickstart\",\n\t\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/javascript/syntax-cheetsheet.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Syntax cheetsheet\",\n\t\t\t\t\t\t\t\t\t\"order\": 1\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/conditionals.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Conditionals\",\n\t\t\t\t\t\t\t\t\t\"order\": 4\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/data-types.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Built-in Data Types\",\n\t\t\t\t\t\t\t\t\t\"order\": 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/destructuring.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Destructuring & Pattern Matching\",\n\t\t\t\t\t\t\t\t\t\"order\": 5\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/functions.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Functions\",\n\t\t\t\t\t\t\t\t\t\"order\": 3\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/imperative-loops.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Imperative Loops\",\n\t\t\t\t\t\t\t\t\t\"order\": 9\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/index.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Language basics\",\n\t\t\t\t\t\t\t\t\t\"order\": 1\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/jsx.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"JSX\",\n\t\t\t\t\t\t\t\t\t\"order\": 10\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/let-bindings.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Let Bindings\",\n\t\t\t\t\t\t\t\t\t\"order\": 2\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/modules.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Modules\",\n\t\t\t\t\t\t\t\t\t\"order\": 11\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/more-types.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"More on Types\",\n\t\t\t\t\t\t\t\t\t\"order\": 7\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/more-functions.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"More on Functions\",\n\t\t\t\t\t\t\t\t\t\"order\": 6\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/mutation.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Mutation\",\n\t\t\t\t\t\t\t\t\t\"order\": 8\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/primitives.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Primitives\",\n\t\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/language/types.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Types\",\n\t\t\t\t\t\t\t\t\t\"order\": 1\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/native/convert-from-ocaml.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Converting from OCaml\",\n\t\t\t\t\t\t\t\t\t\"order\": 4\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/native/index.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Native\",\n\t\t\t\t\t\t\t\t\t\"order\": 5\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\t\"relativePath\": \"guide/native/quickstart.md\",\n\t\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\t\"title\": \"Quickstart\",\n\t\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\t\"file\": {\n\t\t\t\t\"relativePath\": \"guide/ocaml.md\",\n\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\"html\": \"<p>A quick reference for OCaml programmers.</p>\\n<p>Consult the general <a href=\\\"index.html#syntax-basics\\\">Syntax Basics</a> for an overview\\nof the <code>Reason</code> syntax. This guide merely dives deeper into the differences and\\nimprovements that OCaml programmers would notice most.</p>\\n<h3>Comments</h3>\\n<p>Reason comments use the C-family style of comments, and OCaml comments use <code>(* *)</code> style comments. In Reason, nested <code>/**/</code> comments are validated at parse\\ntime, and in OCaml, nested <code>(* *)</code> are validated at parse time.\\nReason will also <em>eventually</em> support line comments, which are not supported in OCaml.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p >OCaml</p></th> <th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <code>\\n`(* OCaml (*nest*) *)`\\n      </code>\\n    </td>\\n    <td>\\n      <code>\\n`/* Reason /*nest*/  */`\\n      </code>\\n    </td>\\n  </tr>\\n</table>\\n<h3>REPL (<a href=\\\"https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop\\\">Read-Eval-Print-Loop</a>)</h3>\\n<p>In <code>Reason</code>'s repl <code>rtop</code> (a customized <code>utop</code>), each input is submitted via\\na single <code>;</code> semicolon. <code>OCaml</code>'s repl requires two semicolons <code>;;</code>.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p >OCaml REPL</p></th> <th scope=\\\"col\\\"><p>Reason REPL</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>;;</pre>\\n    </td>\\n    <td>\\n      <pre>;</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3>Operator Renaming</h3>\\n<p><code>Reason</code> has all of <code>OCaml</code>'s infix operators, but a couple of operators\\nare <em>expressed</em> differently.\\nIn <code>Reason</code>, structural equality is written as <code>==</code>, and reference equality\\n(physical equality)\\nis written as <code>===</code> (so just remember to add an extra <code>=</code> to what <code>OCaml</code>\\nrequires). In <code>Reason</code>, to achieve the corresponding <em>inequality</em>,\\nsimply swap the first character with a <code>!</code> character. (<code>!=</code> for structural\\ninequality, and <code>!==</code> for reference inequality). <code>Reason</code>'s\\nsymbol choices are slightly more consistent and follow the ES6 conventions.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr><th scope=\\\"col\\\"><p>Equality</p></th> <th scope=\\\"col\\\"><p>Expressed in OCaml via</p></th> <th scope=\\\"col\\\"><p>Expressed in Reason via</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nstructural</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx = y</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx == y</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nreference</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx == y</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx === y</pre>\\n    </td>\\n  </tr>\\n  <thead><tr><th scope=\\\"col\\\"><p>Inequality</p></th> <th scope=\\\"col\\\"><p>Expressed in OCaml via</p></th> <th scope=\\\"col\\\"><p>Expressed in Reason via</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nstructural</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx <> y</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx != y</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nreference</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx != y</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx !== y</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3>Local Scope</h3>\\n<p><code>Reason</code>'s lexical scoping is exactly the same as <code>OCaml</code>'s, but let bindings\\nsyntactically resemble \\\"block scope\\\" which is more familiar to many\\ndevelopers. In <code>Reason</code>, they are created with <code>{}</code> braces, which\\nmay contain both <code>let</code> bindings and imperative commands, separated by <code>;</code>.\\nAll blocks <em>evaluate</em> to the last line and the semicolon on the last line is\\noptional. <code>{}</code> braces are only needed if you have more than one item to chain\\ntogether via <code>;</code>.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet \\\\_ =\\n  let msg = \\\"Hello\\\" in\\n  print\\\\_string msg;\\n  let msg2 = \\\"Goodbye\\\" in\\n  print\\\\_string msg2</pre>\\n    </td>\\n    <td>\\n      <pre>\\n{\\n  let msg = \\\"Hello\\\";\\n  print\\\\_string msg;\\n  let msg2 = \\\"Goodbye\\\";\\n  print\\\\_string msg2\\n};</pre>\\n    </td>\\n  </tr>\\n</table>\\n<p><code>Reason</code>'s <code>{}</code> syntax removes many commonly reported pain points in <code>OCaml</code>'s\\nsyntax:</p>\\n<ul>\\n<li>Double semicolons are removed entirely.</li>\\n<li><code>begin</code>/<code>end</code> is removed entirely.</li>\\n<li>Infamous imperative parsing <a href=\\\"https://github.com/ocaml/ocaml/pull/278\\\">issues</a> are gone.</li>\\n<li>Module bodies and local scope are unified.</li>\\n</ul>\\n<h3>Local Scope Vs. Module Bodies</h3>\\n<p>In <code>Reason</code>, everything that can go between the <code>{}</code> in <a href=\\\"#reason-vs-ml-syntax-local-scope\\\">Local\\nScopes</a> and in module bodies. You can usually\\neven cut/paste code between the two contexts. In <code>OCaml</code>, the syntaxes for the two\\ncontexts are very different. (Local scope requires trailing <code>in</code>, but module bodies do\\nnot and some imperative statements must be assigned to <code>_</code> or <code>()</code>, or else use double <code>;;</code>).\\n<code>Reason</code> greatly simplifies the syntax for new <em>and</em> experienced ML programmers.</p>\\n<blockquote>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml Module Body</p></th><th scope=\\\"col\\\"><p>Reason Module Body</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10\\nlet () = imperativeFunc ten ten\\nlet () = imperativeFunc 0 0</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet ten = 10;\\nimperativeFunc ten ten;\\nimperativeFunc 0 0;</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10;;\\nimperativeFunc ten ten;;\\nimperativeFunc 0 0;;</pre>\\n    </td>\\n    <td>*Same as above*</td>\\n  </tr>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml Local Scope</p></th><th scope=\\\"col\\\"><p>Reason Local Scope</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10 in\\nlet \\\\_ = imperativeFunc ten ten in\\nimperativeFunc 0 0</pre>\\n    </td>\\n    <td>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-none\\\"><code>   *same <span class=\\\"hljs-keyword\\\">as</span> above*\\n\\n&lt;/td&gt;</code></pre>\\n      </div>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10 in begin\\n  imperativeFunc ten ten;\\n  imperativeFunc 0 0\\nend</pre>\\n    </td>\\n    <td>\\n       *same as above*\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10 in (\\n  imperativeFunc ten ten;\\n  imperativeFunc 0 0\\n)</pre>\\n    </td>\\n    <td>\\n       *same as above*\\n    </td>\\n  </tr>\\n</table>\\n</blockquote>\\n<h3>Tuples and Records</h3>\\n<p>In <code>Reason</code>, tuples always require parentheses. This requirement makes <code>Reason</code> easier to\\nread and also removes the need for type annotations inside of tuple members\\nto be wrapped in <em>additional</em> parentheses.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>let tup = 4, 5</pre>\\n    </td>\\n    <td>\\n      <pre>let tup = (4, 5);</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>let tup = ((1: int), (2:int))</pre>\\n    </td>\\n    <td>\\n      <pre>let tup = (1: int, 2:int);</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>fun ((a:int), (b:int)) -> a </pre>\\n    </td>\\n    <td>\\n      <pre>fun (a:int, b:int) => a</pre>\\n    </td>\\n  </tr>\\n</table>\\n<p>In <code>Reason</code>, records resemble JavaScript, using <code>:</code> instead of <code>=</code>. Because\\n<code>Reason</code> tuples always require wrapping parens, records may contain lambdas as values\\nwithout needing extra parens.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet myRec = {x = 0; y = 10}</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet myRec = {x: 0, y: 10};</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet myFuncs = {\\n  myFun = (fun x -> x + 1);\\n  your = (fun a b -> a + b);\\n}</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet myFuncs = {\\n  myFun: fun x => x + 1,\\n  your: fun a b => a + b\\n};</pre>\\n    </td>\\n</table>\\n<h3>Lists</h3>\\n<p>Lists in <code>Reason</code> are delimited with commas rather than semi-colons as they are in JavaScript. <code>Reason</code> also uses JavaScript's spread syntax for list concatenation instead of the <code>::</code> operator.</p>\\n<blockquote>\\n<table>\\n<thead><tr> <th scope=\\\"col\\\"><p>OCaml Lists</p></th><th scope=\\\"col\\\"><p>Reason Lists</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>let list = [1; 2; 3]</pre>\\n      <pre>let list = hd :: tl</pre>\\n    </td>\\n    <td>\\n      <pre>let list = [1, 2, 3];</pre>\\n      <pre>let list = [hd, ...tl];</pre>\\n    </td>\\n  </tr>\\n</table>\\n</blockquote>\\n<h3>Type Definitions</h3>\\n<p>With <code>Reason</code>, types generally look like the values they represent.  There is\\nonly one syntactic pattern to learn for each kind of type. Whereas in <code>OCaml</code>,\\nthere are separate syntaxes for tuple types <code>(x * y)</code> and tuple values\\n<code>(x, y)</code>).</p>\\n<blockquote>\\n<table>\\n<thead><tr> <th scope=\\\"col\\\"><p>OCaml Tuples</p></th><th scope=\\\"col\\\"><p>Reason Tuples</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\ntype tuple = int \\\\* int\\nlet tup: tuple = (10, 30)</pre>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-none\\\"><code>&lt;/td&gt;\\n&lt;td&gt;\\n  &lt;pre&gt;</code></pre>\\n      </div>\\n<p>type tuple = (int, int);\\nlet tup: tuple = (10, 30);</pre>\\n</td></p>\\n  </tr>\\n<thead><tr> <th scope=\\\"col\\\"><p>OCaml Records</p></th><th scope=\\\"col\\\"><p>Reason Records</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\ntype r =\\n  {x: int; y: int};\\nlet myRec: r = {x = 0; y = 10};</pre>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-none\\\"><code>&lt;/td&gt;\\n&lt;td&gt;\\n  &lt;pre&gt;</code></pre>\\n      </div>\\n<p>type r =\\n{x: int, y: int};\\nlet myRec: r = {x: 0, y: 10};</pre>\\n</td></p>\\n  </tr>\\n<thead><tr> <th scope=\\\"col\\\"><p>OCaml Functions</p></th><th scope=\\\"col\\\"><p>Reason Functions</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\ntype func = int -> int;\\nlet x: func = fun a -> a + 1;</pre>\\n    </td>\\n    <td>\\n      <pre>\\ntype func = int => int;\\nlet x: func = fun a => a + 1;</pre>\\n    </td>\\n  </tr>\\n</table>\\n</blockquote>\\n<h3>Functions</h3>\\n<p><code>OCaml</code> has three ways to define functions:</p>\\n<ul>\\n<li>Some <code>OCaml</code> forms use arrows <code>-></code>, some use equals <code>=</code>.</li>\\n<li>Some <code>OCaml</code> forms use the <code>fun</code> keyword, others use the <code>function</code> keyword.</li>\\n</ul>\\n<p><code>Reason</code> also supports the same three ways to define lambdas, but for\\nconsistency:</p>\\n<ul>\\n<li>Every <code>Reason</code> form uses an <code>=></code> arrow in one way or another.*</li>\\n<li><code>Reason</code> uses at most one keyword (<code>fun</code>).</li>\\n<li>As with all pattern matching, the leading bar <code>|</code> is required in the single\\nargument pattern match form.</li>\\n</ul>\\n<h6>Single argument match functions</h6>\\n<p><code>OCaml</code> has a function definition (<code>function |</code>) which is considered to be\\nequivalent of <code>function a -> match a with ...</code>. <code>Reason</code> has the same, but\\nthe syntax makes it clear how it is actually an extension of a single argument\\nfunction. The single case match is a natural extension of the simple lambda,\\nand the multicase lambda is a natural extension of the single case lambda.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>Form</p></th><th scope=\\\"col\\\"><p>Ocaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      lambda\\n    </td>\\n    <td>\\n      <pre>\\nfun pat -> e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nfun pat => e</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      one match case\\n    </td>\\n    <td>\\n      <pre>\\nfunction | pat -> e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nfun | pat => e</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      many cases\\n    </td>\\n    <td>\\n      <pre>\\nfunction | pat -> e\\n         | pat2 -> e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nfun | pat => e\\n    | pat2 => e</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h6>Let binding for curried functions</h6>\\n<p>Both <code>OCaml</code> and <code>Reason</code> syntax offer a syntactic sugar for expressing curried\\nfunctions. The following table shows three equivalent definitions which are\\nidentical once parsed. As always, all <code>Reason</code> functions include an <code>=></code> arrow.</p>\\n<blockquote>\\n<table> <thead><tr><th scope=\\\"col\\\"><p>Ocaml</p></th><th\\n</blockquote>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-none\\\"><code>    scope=<span class=\\\"hljs-string\\\">\\\"col\\\"</span>&gt;&lt;p&gt;Reason&lt;/p&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;</code></pre>\\n      </div>\\n  <tr>\\n    <td>\\n      <pre>\\nlet x = fun a -> fun b -> e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet x = fun a => fun b => e;</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet x = fun a b -> e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet x = fun a b => e;</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet x a b = e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet x a b => e;</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3>Annotating Function Arguments</h3>\\n<p>In both <code>Reason</code> and <code>OCaml</code>, arguments are annotated with types by (as with\\neverything else), wrapping them in parenthesis after appending\\n<code>:typeAnnotation</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> (arg<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> argType)<span class=\\\"hljs-params\\\"> </span></span></span></span></span>=&gt; returnValue;</code></pre>\\n      </div>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> (arg<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> argType)<span class=\\\"hljs-params\\\"> </span></span></span></span></span>=&gt; <span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> (arg2<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> arg2Type)<span class=\\\"hljs-params\\\"> </span></span></span></span></span>=&gt; returnValue;</code></pre>\\n      </div>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> (arg<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> argType)<span class=\\\"hljs-params\\\"> (arg2<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> arg2Type)<span class=\\\"hljs-params\\\"> </span></span></span></span></span></span></span></span>=&gt; returnValue;</code></pre>\\n      </div>\\n<p>Both <code>Reason</code> and <code>OCaml</code> allow annotating the return type, when using the\\n\\\"super sugared let binding\\\" form.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-ocaml\\\"><code><span class=\\\"hljs-comment\\\">(* OCaml *)</span>\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:<span class=\\\"hljs-built_in\\\">int</span>) (b:<span class=\\\"hljs-built_in\\\">int</span>) :<span class=\\\"hljs-built_in\\\">int</span> * <span class=\\\"hljs-built_in\\\">int</span> = (a, b)\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:<span class=\\\"hljs-built_in\\\">int</span>) (b:<span class=\\\"hljs-built_in\\\">int</span>) :<span class=\\\"hljs-built_in\\\">int</span> <span class=\\\"hljs-built_in\\\">list</span> = [<span class=\\\"hljs-number\\\">1</span>]\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:<span class=\\\"hljs-built_in\\\">int</span>) (b:<span class=\\\"hljs-built_in\\\">int</span>) :<span class=\\\"hljs-built_in\\\">int</span> -&gt; <span class=\\\"hljs-built_in\\\">int</span> = <span class=\\\"hljs-keyword\\\">fun</span> x -&gt; x + a + b</code></pre>\\n      </div>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-comment\\\">/* Reason */</span>\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:int) (b:int) :(int, int) =&gt; (a, b);\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:int) (b:int) :list int =&gt; [<span class=\\\"hljs-number\\\">1</span>];\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:int) (b:int) :(int =&gt; int) =&gt; <span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> x<span class=\\\"hljs-params\\\"> </span></span></span>=&gt; x + a + b;</code></pre>\\n      </div>\\n<blockquote>\\n<p>Because we're using <code>=></code> for all functions everywhere in <code>Reason</code>, there's\\none case where we need to add extra parens around a return type that is\\nitself a function type.</p>\\n</blockquote>\\n<h3>Type Parameters</h3>\\n<h6>OCaml:</h6>\\n<p>OCaml's type applications (think \\\"generics\\\"), are applied in reverse order.</p>\\n<p>With OCaml, there are some unintuitive consequences of this.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-ocaml\\\"><code>    <span class=\\\"hljs-keyword\\\">let</span> x: <span class=\\\"hljs-built_in\\\">int</span> <span class=\\\"hljs-built_in\\\">list</span> = [<span class=\\\"hljs-number\\\">2</span>]\\n\\n    <span class=\\\"hljs-keyword\\\">type</span> listOfListOfInts = <span class=\\\"hljs-built_in\\\">int</span> <span class=\\\"hljs-built_in\\\">list</span> <span class=\\\"hljs-built_in\\\">list</span>\\n\\n    <span class=\\\"hljs-comment\\\">(* Parsed as: *)</span>\\n    <span class=\\\"hljs-keyword\\\">type</span> listOfListOfInts = (<span class=\\\"hljs-built_in\\\">int</span> <span class=\\\"hljs-built_in\\\">list</span>) <span class=\\\"hljs-built_in\\\">list</span></code></pre>\\n      </div>\\n<p>Things get even more strange when type constructors accept multiple parameters.\\nMultiple arguments require parenthesis and commas to separate type parameters,\\nbut those parentheses don't represent tuples. The parentheses/comma form must\\nalso be given when constructing type instances such as <code>(int, string) tuple</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-ocaml\\\"><code>    <span class=\\\"hljs-keyword\\\">type</span> (<span class=\\\"hljs-symbol\\\">'a</span>, <span class=\\\"hljs-symbol\\\">'b</span>) tuple = <span class=\\\"hljs-symbol\\\">'a</span> * <span class=\\\"hljs-symbol\\\">'b</span>\\n\\n    <span class=\\\"hljs-keyword\\\">type</span> listOfTuplesOfStringAndInt = (<span class=\\\"hljs-built_in\\\">string</span>, <span class=\\\"hljs-built_in\\\">int</span>) tuple <span class=\\\"hljs-built_in\\\">list</span>\\n\\n    <span class=\\\"hljs-comment\\\">(* Which is parsed as: *)</span>\\n    <span class=\\\"hljs-keyword\\\">type</span> listOfTuplesOfStringAndInt = ((<span class=\\\"hljs-built_in\\\">string</span>, <span class=\\\"hljs-built_in\\\">int</span>) tuple) <span class=\\\"hljs-built_in\\\">list</span>\\n\\n    <span class=\\\"hljs-comment\\\">(* Which allows a list of (tuples of (string and int)) *)</span>\\n    <span class=\\\"hljs-keyword\\\">let</span> tuples: listOfTuplesOfStringAndInt = [(<span class=\\\"hljs-string\\\">\\\"asdf\\\"</span>, <span class=\\\"hljs-number\\\">3</span>)]</code></pre>\\n      </div>\\n<h6>Reason:</h6>\\n<p>In summary, Reason unifies almost all of the syntax into simple \\\"function\\napplication\\\" style meaning that type parameters follow the same space-separated\\nlist pattern seen everywhere else in the syntax. As with everything else,\\nparentheses may be used to enforce precedence. This results in fewer syntactic\\npatterns to learn.</p>\\n<p>For example, you can imagine <code>list</code> being a \\\"function\\\" for types that accepts a\\ntype and returns a new type.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet x: int list = [2]\\ntype listOfListOfInts =\\n  int list list\\ntype ('a, 'b) tup = ('a \\\\* 'b)\\ntype pairs = (int, int) tup list\\nlet tuples: pairs = [(2, 3)]</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet x: list int = [2];\\ntype listOfListOfInts =\\n  list (list int);\\ntype tup 'a 'b = ('a, 'b);\\ntype pairs = list (tup int int)\\nlet tuples: pairs = [(2, 3)]</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3>Tuples as Type Parameters</h3>\\n<p>Because <code>OCaml</code> uses parens and commas to represent multiple arguments to type\\nconstructors, it's confusing when one of the arguments to a type constructor is\\nitself a tuple. In <code>OCaml</code>, it's difficult to remember the difference between a\\ntype constructor accepting multiple arguments and a type constructor accepting\\na single argument which happens to be a tuple.</p>\\n<p>The following examples shows the difference between passing <em>two</em> type\\nparameters to <code>pair</code>, and a <em>single</em> type parameter that happens to be a tuple.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\ntype intPair = (int, int) pair\\ntype pairList = (int \\\\* int) list</pre>\\n    </td>\\n    <td>\\n      <pre>\\ntype intPair = pair int int;\\ntype pairList = list (int, int);</pre>\\n    </td>\\n  </tr>\\n</table>\\n<ul>\\n<li>In <code>Reason</code>, syntax that represent tuple or tuple types, always looks like\\ntuples.</li>\\n<li>In <code>Reason</code>, syntax that represent records or record types, always look like\\nrecords.</li>\\n<li>Just about everything else uses the syntactic pattern of function application\\n(space separated arguments).</li>\\n</ul>\\n<h3>Variants</h3>\\n<h6>OCaml</h6>\\n<ul>\\n<li><code>OCaml</code> already expects constructor argument types to be specified in tuple\\nform, so it's confusing when a single constructor expects a single argument\\nthat <em>happens</em> to be a tuple type.</li>\\n<li>What's even more confusing is that the constructors don't <em>actually</em> accept\\ntuples, yet the syntax appear to resemble tuples.</li>\\n<li>Sometimes the syntax for instantiating a constructor with multiple arguments\\noverlaps the syntax for constructing a variant with a single argument that\\nhappens to be a tuple - so it looks <em>exactly</em> like you <em>are</em> supplying a\\ntuple when you are not actually supplying a tuple.</li>\\n</ul>\\n<h6>Reason</h6>\\n<ul>\\n<li>Variant constructor types are expected to be listed as space separated lists,\\nusing parenthesis to group precedence (as with <strong>everything</strong> else).</li>\\n<li>Constructing instances of the variant (as you would have guessed) follows\\nfunction application style (space separated lists).</li>\\n<li>Tuples <strong>always</strong> <em>look</em> like tuples, and anything that looks like a tuple\\n<em>is</em> a tuple.</li>\\n</ul>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\ntype myVariant =\\n   | HasNothing\\n   | HasSingleInt of int\\n   | HasSingleTuple of (int \\\\* int)\\n   | HasMultipleInts of int \\\\* int\\n   | HasMultipleTuples\\n      of (int \\\\* int) \\\\* (int\\\\* int)\\n<p>let a = HasSingleInt 10\\nlet a = HasSingleTuple (10, 10)\\nlet a = HasMultipleInts (10, 10)\\nlet a =\\nHasMultipleTuples (\\n(10, 10),\\n(10, 10)\\n)</p>\\n<p>let res = match x with\\n| HasNothing -> 0\\n| HasSingleInt x -> 0\\n| HasSingleTuple (x, y) -> 0\\n| HasMultipleInts (x, y) -> 0\\n| HasMultipleTuples\\n((x, y),\\n(q, r)) -> 0</pre>\\n</td>\\n<td>\\n<pre>\\ntype myVariant =\\n| HasNothing\\n| HasSingleInt int\\n| HasSingleTuple (int, int)\\n| HasMultipleInts int int\\n| HasMultipleTuples\\n(int, int) (int, int);</p>\\n<p>let a = HasSingleInt 10;\\nlet a = HasSingleTuple (10, 10);\\nlet a = HasMultipleInts 10 10;\\nlet a =\\nHasMultipleTuples\\n(10, 10)\\n(10, 10);</p>\\n<p>let res = switch x {\\n| HasNothing => 0\\n| HasSingleInt x => 0\\n| HasSingleTuple (x, y) => 0\\n| HasMultipleInts x y => 0\\n| HasMultipleTuples\\n(x, y)\\n(q, r) => 0\\n};</pre>\\n</td></p>\\n  </tr>\\n</table>\\n<h3>Pattern Matching</h3>\\n<h6>OCaml</h6>\\n<h6>Reason</h6>\\n<ul>\\n<li>Uses the <code>switch</code> keyword, and doesn't require <code>with</code>.</li>\\n<li><em>Requires</em> wrapping <code>switch</code> cases in <code>{}</code> to avoid confusing and error\\nprone mis-parsing when pattern matching is embedded in other pattern\\nmatching.</li>\\n<li>Uses the <code>=></code>.</li>\\n<li>Requires the leading bar. This is a good idea because it frees up other\\npossibilities in the grammar without conflicts.</li>\\n</ul>\\n<p>Can you spot the error in the <code>OCaml</code> example? This is one of the most common\\nmistakes among <code>OCaml</code> programmers. The second <code>match</code> <em>must</em> be wrapped in\\nparentheses, otherwise the <code>Some</code> case is parsed as belonging to the outer\\n<code>match</code>. <code>Reason</code>'s required <code>{}</code> blocks around match cases prevent this\\nissue.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml (BROKEN)</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet res = match x with\\n  | A (x, y) -> match y with\\n    | None -> 0\\n    | Some i -> 10\\n  | B (x, y) -> 0</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet res = switch x {\\n  | A (x, y) => switch y {\\n    | None => 0\\n    | Some i => 10\\n  }\\n  | B x y => 0\\n};</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3>Modules and Signatures</h3>\\n<h6>Defining Modules/Signatures</h6>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule type MySig = sig\\n  type t = int\\n  val x: int\\nend\\nmodule MyModule: MySig = struct\\n  type t = int\\n  let x = 10\\nend\\nmodule MyModule = struct\\n  module NestedModule = struct\\n     let msg = \\\"hello\\\";\\n  end\\nend\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule type MySig = {\\n  type t = int;\\n  let x: int;\\n};\\nmodule MyModule: MySig = {\\n  type t = int;\\n  let x = 10;\\n};\\nmodule MyModule = {\\n  module NestedModule = {\\n     let msg = \\\"hello\\\";\\n  };\\n};\\n      </pre>\\n    </td>\\n  </tr>\\n</table>\\n<h5>Functors Types</h5>\\n<p>In the same way that type parameters (think generics) were made consistent with\\nfunction application syntax, <code>Reason</code> also unifies the syntax for Functors.</p>\\n<p>In <code>Reason</code>, functor parsing rules are almost identical to the function\\nparsing rules, using <code>=></code> to represent curried application.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule type FType =\\n    functor (A: ASig) ->\\n    functor (B:BSig) -> Result\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule type FType =\\n    (A: ASig) =>\\n    (B:BSig) => Result;\\n      </pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3>Functors</h3>\\n<p>In <code>Reason</code>, the syntax for creating and applying functors is nearly identical\\nto the syntax for creating/applying functions. Also, functor <em>application</em> is\\nconsistent with function application (again, space separated lists).</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule F =\\n  functor (A:ASig) ->\\n  functor (B:BSig) ->\\n    struct end</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule F =\\n  fun (A:ASig) =>\\n  fun (B:BSig) =>\\n    {};</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule F =\\n  functor\\n    (A:ASig)\\n    (B:BSig) -> struct end</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule F =\\n  fun (A:ASig)\\n      (B:BSig) => {};</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule F\\n       (A:ASig)\\n       (B:BSig) =\\n         struct end</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule F\\n           (A:ASig)\\n           (B:BSig) =>\\n             {};</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule Res = F(A)(B)</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule Res = F A B;</pre>\\n    </td>\\n  </tr>\\n</table>\\n<blockquote>\\n<p>* <em>Note: There is currently a known inconsistency where functors do not\\nconform to function application syntax when in type annotation position - see\\n<code>formatTest/modules.re</code>.</em></p>\\n</blockquote>\\n<h3>Various Improvements</h3>\\n<p>OCaml doesn't require parens around sequences <code>(a;b;c;d)</code> or tuples <code>(x,y)</code>, so\\nthat ends up ruling out a bunch of other very convenient syntax rules.  Since\\nReason always uses <code>{}</code> to enclose sequences or let bindings, and <code>Reason</code>\\nalways requires <code>()</code> around tuples, many other syntax constructs are expressed\\nmore intuitively, without requiring extra wrapping in parenthesis.</p>\\n<h6>Lambdas as record fields no longer need extra parens</h6>\\n<p>This is a welcomed improvement because the <code>OCaml</code> type errors the user would\\nsee were very confusing when it would believe the function's return value\\nwas a tuple with infix <code>,</code> comma.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet myFuncs = {\\n  myFun = (fun x -> x + 1);\\n  your = (fun a b -> a + b);\\n}</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet myFuncs = {\\n  myFun: fun x => x + 1,\\n  your: fun a b => a + b\\n}</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h6>Lambdas as match results no longer need extra parens</h6>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet x = match prnt with\\n  | None -> fun a -> blah\\n  (\\\\* Extra () required ! \\\\*)\\n  | Some \\\"\\\\_\\\" -> (fun a -> ())\\n  | Some \\\"ml\\\" -> blah\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet x = switch prnt {\\n| None => fun a => blah\\n| Some \\\"_\\\" => fun a => ()\\n| Some \\\"ml\\\" => blah\\n};</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h6>Lambdas and type annotations in tuples no longer require extra parens</h6>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet tuple =\\n  ((fun x -> x), 20)\\nlet tuple =\\n  ((\\\"hi\\\": string), (20: int))\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet tuple =\\n  (fun x => x, 20);\\nlet tuple =\\n  (\\\"hi\\\": string, 20: int);\\n      </pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3>Various Differences</h3>\\n<h5><code>as</code> precedence</h5>\\n<p>With <code>Reason</code>, <code>as</code> has a higher precedence than <code>|</code> bar. This allows creating <code>as</code> aliases\\nfor entire rows in pattern matching.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ppp = match MyThing 20 with\\n  | (MyThing x as ppp)\\n  | (YourThing x as ppp) -> ppp;\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet ppp = switch (MyThing 20) {\\n| MyThing x as ppp\\n| YourThing x as ppp => ppp;\\n};\\n      </pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet | (MyThing \\\\_ as ppp)\\n    | (YourThing \\\\_ as ppp) = ppp;</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet | MyThing \\\\_ as ppp\\n    | YourThing \\\\_ as ppp = ppp;</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3>Mutable Record Field Updates</h3>\\n<p>Because equalities and their negations have been made more consistent in <code>Reason</code>,\\nthe <code>=</code> operator is available for mutable field update.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p >OCaml</p></th> <th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nmyRec.field <- \\\"next\\\"</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmyRec.field = \\\"next\\\"</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h5>Prefix operators</h5>\\n<p>In Reason, <code>!</code> and other prefix operators have lower precedence than dot <code>.</code> or send <code>#</code>.\\nThis is more consistent with what other languages do, and is more practical\\nwhen (or if) the <code>!</code> symbol is used to represent boolean <code>not</code>.</p>\\n<blockquote>\\n<table>\\n<thead>\\n<tr>\\n<th>Ocaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><pre>\\n   let x = !(foo.bar);    \\n</pre></td>\\n<td><pre>\\n    let x = !foo.bar;        \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !(foo#bar);    \\n</pre></td>\\n<td><pre>\\n    let x = !foo#bar;        \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !(!foo.bar);   \\n</pre></td>\\n<td><pre>\\n    let x = !(!foo).bar;     \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !(!foo#bar);   \\n</pre></td>\\n<td><pre>\\n    let x = !(!foo)#bar;     \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !(!(foo.bar)); \\n</pre></td>\\n<td><pre>\\n    let x = !(!foo.bar);     \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !(!(foo#bar)); \\n</pre></td>\\n<td><pre>\\n    let x = !(!foo#bar);     \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !!(foo.bar);   \\n</pre></td>\\n<td><pre>\\n    let x = !!foo.bar;       \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !!(foo#bar);   \\n</pre></td>\\n<td><pre>\\n    let x = !!foo#bar;       \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !~(foo.bar);   \\n</pre></td>\\n<td><pre>\\n    let x = !~foo.bar;       \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !~(foo#bar);   \\n</pre></td>\\n<td><pre>\\n    let x = !~foo#bar;       \\n</pre></td>\\n</tr>\\n</tbody>\\n</table>\\n</blockquote>\\n<h6>Comment Escaping</h6>\\n<p>Because Reason uses C-style comments, some obscure custom prefix/infix\\noperators must be written differently.  The rules for prefix/infix operators\\nare the same as in OCaml syntax, but with the following exceptions:</p>\\n<p>Specifically, if any character except the first in an prefix/infix operator is\\na star or forward slash, that must be first escaped with a backslash. These will\\nbe parsed <em>without</em> the backslash when added to the AST. When reprinted, the\\nescape backslashes are added back in automatically.</p>\\n<blockquote>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>\\nlet (/*) a b => a + b;       \\n</code></td>\\n<td><code>\\n     let (/\\n\\\\\\n*\\n) a b => a + b;         \\n</code></td>\\n</tr>\\n<tr>\\n<td><code>\\nlet x = 12 /-\\n*\\n 23 /-\\n*\\n 12;  \\n</code></td>\\n<td><code>\\n     let x = 12 /-\\n\\\\\\n*\\n 23 /-\\n\\\\\\n*\\n 12; \\n</code></td>\\n</tr>\\n<tr>\\n<td><code>\\nlet y = (/*) a b;            \\n</code></td>\\n<td><code>\\n     let y = (/\\n\\\\\\n*\\n) a b;            \\n</code></td>\\n</tr>\\n<tr>\\n<td><code>\\nlet (!=*) q r => q + r;      \\n</code></td>\\n<td><code>\\n     let (!=\\n\\\\\\n*\\n) q r => q + r;      \\n</code></td>\\n</tr>\\n<tr>\\n<td><code>\\nlet res = q (!=*) r;         \\n</code></td>\\n<td><code>\\n     let res = q (!=\\n\\\\\\n*\\n) r;         \\n</code></td>\\n</tr>\\n<tr>\\n<td><code>\\nlet (!=/*) q r => q + r;     \\n</code></td>\\n<td><code>\\n     let (!=\\n/\\n\\\\\\n*\\n) q r => q + r;    \\n</code></td>\\n</tr>\\n<tr>\\n<td><code>\\nlet res = q (!=/*) r;        \\n</code></td>\\n<td><code>\\n     let res = q (!=\\n/\\n\\\\\\n*\\n) r;       \\n</code></td>\\n</tr>\\n</tbody>\\n</table>\\n</blockquote>\\n<h6>Operator Renaming</h6>\\n<p>If <code>Reason</code> uses <code>==</code> to represent <code>OCaml</code>'s <code>=</code>, and\\nuses <code>===</code> to represent <code>OCaml</code>'s <code>==</code>, then how would <code>Reason</code> represent <code>OCaml</code>'s\\n<code>===</code> symbol (if it were defined)? <code>Reason</code> provides a way! \\\"Escape\\\" the triple\\nequals symbol!</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>Identifier</p></th><th scope=\\\"col\\\"><p>Meaning</p></th> <th scope=\\\"col\\\"><p>Expressed in OCaml via</p></th> <th scope=\\\"col\\\"><p>Expressed in Reason via</p></th></tr></thead>\\n  <tr>\\n  <tr>\\n    <td>\\n      <pre>\\n\\\"===\\\"</pre>\\n    </td>\\n    <td>\\n      <pre>\\nCustom value</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx === y</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx \\\\=== y</pre>\\n    </td>\\n  </tr>\\n</table>\",\n\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\"title\": \"Comparison to OCaml\"\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"pathContext\": {\n\t\t\t\"section\": \"guide\",\n\t\t\t\"sectionTitle\": \"Guide\",\n\t\t\t\"relativePath\": \"guide/ocaml.md\",\n\t\t\t\"relatedFiles\": \"/^guide\\\\/.*\\\\.md$/\"\n\t\t}\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---guide-ocaml-2ca14420b62310f8bbae.js","module.exports = {\n\t\"data\": {\n\t\t\"allFile\": {\n\t\t\t\"edges\": [\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/editor-setup.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Editor setup\",\n\t\t\t\t\t\t\t\t\"order\": 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/examples.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Examples\",\n\t\t\t\t\t\t\t\t\"order\": 20\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/getting-started.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Getting started\",\n\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/index.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"The Reason Guide\",\n\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/ocaml.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Comparison to OCaml\",\n\t\t\t\t\t\t\t\t\"order\": 10\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/tools.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Tools\",\n\t\t\t\t\t\t\t\t\"order\": 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/javascript/index.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"JavaScript\",\n\t\t\t\t\t\t\t\t\"order\": 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/javascript/converting.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Converting from JS\",\n\t\t\t\t\t\t\t\t\"order\": 5\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/javascript/libraries.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Libraries\",\n\t\t\t\t\t\t\t\t\"order\": 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/javascript/interop.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Interop\",\n\t\t\t\t\t\t\t\t\"order\": 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/javascript/quickstart.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Quickstart\",\n\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/javascript/syntax-cheetsheet.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Syntax cheetsheet\",\n\t\t\t\t\t\t\t\t\"order\": 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/conditionals.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Conditionals\",\n\t\t\t\t\t\t\t\t\"order\": 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/data-types.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Built-in Data Types\",\n\t\t\t\t\t\t\t\t\"order\": 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/destructuring.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Destructuring & Pattern Matching\",\n\t\t\t\t\t\t\t\t\"order\": 5\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/functions.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Functions\",\n\t\t\t\t\t\t\t\t\"order\": 3\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/imperative-loops.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Imperative Loops\",\n\t\t\t\t\t\t\t\t\"order\": 9\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/index.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Language basics\",\n\t\t\t\t\t\t\t\t\"order\": 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/jsx.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"JSX\",\n\t\t\t\t\t\t\t\t\"order\": 10\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/let-bindings.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Let Bindings\",\n\t\t\t\t\t\t\t\t\"order\": 2\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/modules.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Modules\",\n\t\t\t\t\t\t\t\t\"order\": 11\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/more-types.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"More on Types\",\n\t\t\t\t\t\t\t\t\"order\": 7\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/more-functions.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"More on Functions\",\n\t\t\t\t\t\t\t\t\"order\": 6\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/mutation.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Mutation\",\n\t\t\t\t\t\t\t\t\"order\": 8\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/primitives.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Primitives\",\n\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/language/types.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Types\",\n\t\t\t\t\t\t\t\t\"order\": 1\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/native/convert-from-ocaml.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Converting from OCaml\",\n\t\t\t\t\t\t\t\t\"order\": 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/native/index.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Native\",\n\t\t\t\t\t\t\t\t\"order\": 5\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\t\"node\": {\n\t\t\t\t\t\t\"relativePath\": \"guide/native/quickstart.md\",\n\t\t\t\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\t\t\t\"title\": \"Quickstart\",\n\t\t\t\t\t\t\t\t\"order\": 0\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t]\n\t\t},\n\t\t\"file\": {\n\t\t\t\"relativePath\": \"guide/ocaml.md\",\n\t\t\t\"childMarkdownRemark\": {\n\t\t\t\t\"html\": \"<p>A quick reference for OCaml programmers.</p>\\n<p>Consult the general <a href=\\\"index.html#syntax-basics\\\">Syntax Basics</a> for an overview\\nof the <code>Reason</code> syntax. This guide merely dives deeper into the differences and\\nimprovements that OCaml programmers would notice most.</p>\\n<h3>Comments</h3>\\n<p>Reason comments use the C-family style of comments, and OCaml comments use <code>(* *)</code> style comments. In Reason, nested <code>/**/</code> comments are validated at parse\\ntime, and in OCaml, nested <code>(* *)</code> are validated at parse time.\\nReason will also <em>eventually</em> support line comments, which are not supported in OCaml.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p >OCaml</p></th> <th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <code>\\n`(* OCaml (*nest*) *)`\\n      </code>\\n    </td>\\n    <td>\\n      <code>\\n`/* Reason /*nest*/  */`\\n      </code>\\n    </td>\\n  </tr>\\n</table>\\n<h3>REPL (<a href=\\\"https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop\\\">Read-Eval-Print-Loop</a>)</h3>\\n<p>In <code>Reason</code>'s repl <code>rtop</code> (a customized <code>utop</code>), each input is submitted via\\na single <code>;</code> semicolon. <code>OCaml</code>'s repl requires two semicolons <code>;;</code>.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p >OCaml REPL</p></th> <th scope=\\\"col\\\"><p>Reason REPL</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>;;</pre>\\n    </td>\\n    <td>\\n      <pre>;</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3>Operator Renaming</h3>\\n<p><code>Reason</code> has all of <code>OCaml</code>'s infix operators, but a couple of operators\\nare <em>expressed</em> differently.\\nIn <code>Reason</code>, structural equality is written as <code>==</code>, and reference equality\\n(physical equality)\\nis written as <code>===</code> (so just remember to add an extra <code>=</code> to what <code>OCaml</code>\\nrequires). In <code>Reason</code>, to achieve the corresponding <em>inequality</em>,\\nsimply swap the first character with a <code>!</code> character. (<code>!=</code> for structural\\ninequality, and <code>!==</code> for reference inequality). <code>Reason</code>'s\\nsymbol choices are slightly more consistent and follow the ES6 conventions.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr><th scope=\\\"col\\\"><p>Equality</p></th> <th scope=\\\"col\\\"><p>Expressed in OCaml via</p></th> <th scope=\\\"col\\\"><p>Expressed in Reason via</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nstructural</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx = y</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx == y</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nreference</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx == y</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx === y</pre>\\n    </td>\\n  </tr>\\n  <thead><tr><th scope=\\\"col\\\"><p>Inequality</p></th> <th scope=\\\"col\\\"><p>Expressed in OCaml via</p></th> <th scope=\\\"col\\\"><p>Expressed in Reason via</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nstructural</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx <> y</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx != y</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nreference</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx != y</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx !== y</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3>Local Scope</h3>\\n<p><code>Reason</code>'s lexical scoping is exactly the same as <code>OCaml</code>'s, but let bindings\\nsyntactically resemble \\\"block scope\\\" which is more familiar to many\\ndevelopers. In <code>Reason</code>, they are created with <code>{}</code> braces, which\\nmay contain both <code>let</code> bindings and imperative commands, separated by <code>;</code>.\\nAll blocks <em>evaluate</em> to the last line and the semicolon on the last line is\\noptional. <code>{}</code> braces are only needed if you have more than one item to chain\\ntogether via <code>;</code>.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet \\\\_ =\\n  let msg = \\\"Hello\\\" in\\n  print\\\\_string msg;\\n  let msg2 = \\\"Goodbye\\\" in\\n  print\\\\_string msg2</pre>\\n    </td>\\n    <td>\\n      <pre>\\n{\\n  let msg = \\\"Hello\\\";\\n  print\\\\_string msg;\\n  let msg2 = \\\"Goodbye\\\";\\n  print\\\\_string msg2\\n};</pre>\\n    </td>\\n  </tr>\\n</table>\\n<p><code>Reason</code>'s <code>{}</code> syntax removes many commonly reported pain points in <code>OCaml</code>'s\\nsyntax:</p>\\n<ul>\\n<li>Double semicolons are removed entirely.</li>\\n<li><code>begin</code>/<code>end</code> is removed entirely.</li>\\n<li>Infamous imperative parsing <a href=\\\"https://github.com/ocaml/ocaml/pull/278\\\">issues</a> are gone.</li>\\n<li>Module bodies and local scope are unified.</li>\\n</ul>\\n<h3>Local Scope Vs. Module Bodies</h3>\\n<p>In <code>Reason</code>, everything that can go between the <code>{}</code> in <a href=\\\"#reason-vs-ml-syntax-local-scope\\\">Local\\nScopes</a> and in module bodies. You can usually\\neven cut/paste code between the two contexts. In <code>OCaml</code>, the syntaxes for the two\\ncontexts are very different. (Local scope requires trailing <code>in</code>, but module bodies do\\nnot and some imperative statements must be assigned to <code>_</code> or <code>()</code>, or else use double <code>;;</code>).\\n<code>Reason</code> greatly simplifies the syntax for new <em>and</em> experienced ML programmers.</p>\\n<blockquote>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml Module Body</p></th><th scope=\\\"col\\\"><p>Reason Module Body</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10\\nlet () = imperativeFunc ten ten\\nlet () = imperativeFunc 0 0</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet ten = 10;\\nimperativeFunc ten ten;\\nimperativeFunc 0 0;</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10;;\\nimperativeFunc ten ten;;\\nimperativeFunc 0 0;;</pre>\\n    </td>\\n    <td>*Same as above*</td>\\n  </tr>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml Local Scope</p></th><th scope=\\\"col\\\"><p>Reason Local Scope</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10 in\\nlet \\\\_ = imperativeFunc ten ten in\\nimperativeFunc 0 0</pre>\\n    </td>\\n    <td>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-none\\\"><code>   *same <span class=\\\"hljs-keyword\\\">as</span> above*\\n\\n&lt;/td&gt;</code></pre>\\n      </div>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10 in begin\\n  imperativeFunc ten ten;\\n  imperativeFunc 0 0\\nend</pre>\\n    </td>\\n    <td>\\n       *same as above*\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ten = 10 in (\\n  imperativeFunc ten ten;\\n  imperativeFunc 0 0\\n)</pre>\\n    </td>\\n    <td>\\n       *same as above*\\n    </td>\\n  </tr>\\n</table>\\n</blockquote>\\n<h3>Tuples and Records</h3>\\n<p>In <code>Reason</code>, tuples always require parentheses. This requirement makes <code>Reason</code> easier to\\nread and also removes the need for type annotations inside of tuple members\\nto be wrapped in <em>additional</em> parentheses.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>let tup = 4, 5</pre>\\n    </td>\\n    <td>\\n      <pre>let tup = (4, 5);</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>let tup = ((1: int), (2:int))</pre>\\n    </td>\\n    <td>\\n      <pre>let tup = (1: int, 2:int);</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>fun ((a:int), (b:int)) -> a </pre>\\n    </td>\\n    <td>\\n      <pre>fun (a:int, b:int) => a</pre>\\n    </td>\\n  </tr>\\n</table>\\n<p>In <code>Reason</code>, records resemble JavaScript, using <code>:</code> instead of <code>=</code>. Because\\n<code>Reason</code> tuples always require wrapping parens, records may contain lambdas as values\\nwithout needing extra parens.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet myRec = {x = 0; y = 10}</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet myRec = {x: 0, y: 10};</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet myFuncs = {\\n  myFun = (fun x -> x + 1);\\n  your = (fun a b -> a + b);\\n}</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet myFuncs = {\\n  myFun: fun x => x + 1,\\n  your: fun a b => a + b\\n};</pre>\\n    </td>\\n</table>\\n<h3>Lists</h3>\\n<p>Lists in <code>Reason</code> are delimited with commas rather than semi-colons as they are in JavaScript. <code>Reason</code> also uses JavaScript's spread syntax for list concatenation instead of the <code>::</code> operator.</p>\\n<blockquote>\\n<table>\\n<thead><tr> <th scope=\\\"col\\\"><p>OCaml Lists</p></th><th scope=\\\"col\\\"><p>Reason Lists</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>let list = [1; 2; 3]</pre>\\n      <pre>let list = hd :: tl</pre>\\n    </td>\\n    <td>\\n      <pre>let list = [1, 2, 3];</pre>\\n      <pre>let list = [hd, ...tl];</pre>\\n    </td>\\n  </tr>\\n</table>\\n</blockquote>\\n<h3>Type Definitions</h3>\\n<p>With <code>Reason</code>, types generally look like the values they represent.  There is\\nonly one syntactic pattern to learn for each kind of type. Whereas in <code>OCaml</code>,\\nthere are separate syntaxes for tuple types <code>(x * y)</code> and tuple values\\n<code>(x, y)</code>).</p>\\n<blockquote>\\n<table>\\n<thead><tr> <th scope=\\\"col\\\"><p>OCaml Tuples</p></th><th scope=\\\"col\\\"><p>Reason Tuples</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\ntype tuple = int \\\\* int\\nlet tup: tuple = (10, 30)</pre>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-none\\\"><code>&lt;/td&gt;\\n&lt;td&gt;\\n  &lt;pre&gt;</code></pre>\\n      </div>\\n<p>type tuple = (int, int);\\nlet tup: tuple = (10, 30);</pre>\\n</td></p>\\n  </tr>\\n<thead><tr> <th scope=\\\"col\\\"><p>OCaml Records</p></th><th scope=\\\"col\\\"><p>Reason Records</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\ntype r =\\n  {x: int; y: int};\\nlet myRec: r = {x = 0; y = 10};</pre>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-none\\\"><code>&lt;/td&gt;\\n&lt;td&gt;\\n  &lt;pre&gt;</code></pre>\\n      </div>\\n<p>type r =\\n{x: int, y: int};\\nlet myRec: r = {x: 0, y: 10};</pre>\\n</td></p>\\n  </tr>\\n<thead><tr> <th scope=\\\"col\\\"><p>OCaml Functions</p></th><th scope=\\\"col\\\"><p>Reason Functions</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\ntype func = int -> int;\\nlet x: func = fun a -> a + 1;</pre>\\n    </td>\\n    <td>\\n      <pre>\\ntype func = int => int;\\nlet x: func = fun a => a + 1;</pre>\\n    </td>\\n  </tr>\\n</table>\\n</blockquote>\\n<h3>Functions</h3>\\n<p><code>OCaml</code> has three ways to define functions:</p>\\n<ul>\\n<li>Some <code>OCaml</code> forms use arrows <code>-></code>, some use equals <code>=</code>.</li>\\n<li>Some <code>OCaml</code> forms use the <code>fun</code> keyword, others use the <code>function</code> keyword.</li>\\n</ul>\\n<p><code>Reason</code> also supports the same three ways to define lambdas, but for\\nconsistency:</p>\\n<ul>\\n<li>Every <code>Reason</code> form uses an <code>=></code> arrow in one way or another.*</li>\\n<li><code>Reason</code> uses at most one keyword (<code>fun</code>).</li>\\n<li>As with all pattern matching, the leading bar <code>|</code> is required in the single\\nargument pattern match form.</li>\\n</ul>\\n<h6>Single argument match functions</h6>\\n<p><code>OCaml</code> has a function definition (<code>function |</code>) which is considered to be\\nequivalent of <code>function a -> match a with ...</code>. <code>Reason</code> has the same, but\\nthe syntax makes it clear how it is actually an extension of a single argument\\nfunction. The single case match is a natural extension of the simple lambda,\\nand the multicase lambda is a natural extension of the single case lambda.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>Form</p></th><th scope=\\\"col\\\"><p>Ocaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      lambda\\n    </td>\\n    <td>\\n      <pre>\\nfun pat -> e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nfun pat => e</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      one match case\\n    </td>\\n    <td>\\n      <pre>\\nfunction | pat -> e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nfun | pat => e</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      many cases\\n    </td>\\n    <td>\\n      <pre>\\nfunction | pat -> e\\n         | pat2 -> e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nfun | pat => e\\n    | pat2 => e</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h6>Let binding for curried functions</h6>\\n<p>Both <code>OCaml</code> and <code>Reason</code> syntax offer a syntactic sugar for expressing curried\\nfunctions. The following table shows three equivalent definitions which are\\nidentical once parsed. As always, all <code>Reason</code> functions include an <code>=></code> arrow.</p>\\n<blockquote>\\n<table> <thead><tr><th scope=\\\"col\\\"><p>Ocaml</p></th><th\\n</blockquote>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-none\\\"><code>    scope=<span class=\\\"hljs-string\\\">\\\"col\\\"</span>&gt;&lt;p&gt;Reason&lt;/p&gt;&lt;/th&gt;&lt;/tr&gt;&lt;/thead&gt;</code></pre>\\n      </div>\\n  <tr>\\n    <td>\\n      <pre>\\nlet x = fun a -> fun b -> e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet x = fun a => fun b => e;</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet x = fun a b -> e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet x = fun a b => e;</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet x a b = e</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet x a b => e;</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3>Annotating Function Arguments</h3>\\n<p>In both <code>Reason</code> and <code>OCaml</code>, arguments are annotated with types by (as with\\neverything else), wrapping them in parenthesis after appending\\n<code>:typeAnnotation</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> (arg<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> argType)<span class=\\\"hljs-params\\\"> </span></span></span></span></span>=&gt; returnValue;</code></pre>\\n      </div>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> (arg<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> argType)<span class=\\\"hljs-params\\\"> </span></span></span></span></span>=&gt; <span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> (arg2<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> arg2Type)<span class=\\\"hljs-params\\\"> </span></span></span></span></span>=&gt; returnValue;</code></pre>\\n      </div>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> (arg<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> argType)<span class=\\\"hljs-params\\\"> (arg2<span class=\\\"hljs-params\\\"> :<span class=\\\"hljs-params\\\"> arg2Type)<span class=\\\"hljs-params\\\"> </span></span></span></span></span></span></span></span>=&gt; returnValue;</code></pre>\\n      </div>\\n<p>Both <code>Reason</code> and <code>OCaml</code> allow annotating the return type, when using the\\n\\\"super sugared let binding\\\" form.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-ocaml\\\"><code><span class=\\\"hljs-comment\\\">(* OCaml *)</span>\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:<span class=\\\"hljs-built_in\\\">int</span>) (b:<span class=\\\"hljs-built_in\\\">int</span>) :<span class=\\\"hljs-built_in\\\">int</span> * <span class=\\\"hljs-built_in\\\">int</span> = (a, b)\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:<span class=\\\"hljs-built_in\\\">int</span>) (b:<span class=\\\"hljs-built_in\\\">int</span>) :<span class=\\\"hljs-built_in\\\">int</span> <span class=\\\"hljs-built_in\\\">list</span> = [<span class=\\\"hljs-number\\\">1</span>]\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:<span class=\\\"hljs-built_in\\\">int</span>) (b:<span class=\\\"hljs-built_in\\\">int</span>) :<span class=\\\"hljs-built_in\\\">int</span> -&gt; <span class=\\\"hljs-built_in\\\">int</span> = <span class=\\\"hljs-keyword\\\">fun</span> x -&gt; x + a + b</code></pre>\\n      </div>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-reason\\\"><code><span class=\\\"hljs-comment\\\">/* Reason */</span>\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:int) (b:int) :(int, int) =&gt; (a, b);\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:int) (b:int) :list int =&gt; [<span class=\\\"hljs-number\\\">1</span>];\\n<span class=\\\"hljs-keyword\\\">let</span> myFunc (a:int) (b:int) :(int =&gt; int) =&gt; <span class=\\\"hljs-func\\\"><span class=\\\"hljs-keyword\\\">fun</span><span class=\\\"hljs-params\\\"> x<span class=\\\"hljs-params\\\"> </span></span></span>=&gt; x + a + b;</code></pre>\\n      </div>\\n<blockquote>\\n<p>Because we're using <code>=></code> for all functions everywhere in <code>Reason</code>, there's\\none case where we need to add extra parens around a return type that is\\nitself a function type.</p>\\n</blockquote>\\n<h3>Type Parameters</h3>\\n<h6>OCaml:</h6>\\n<p>OCaml's type applications (think \\\"generics\\\"), are applied in reverse order.</p>\\n<p>With OCaml, there are some unintuitive consequences of this.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-ocaml\\\"><code>    <span class=\\\"hljs-keyword\\\">let</span> x: <span class=\\\"hljs-built_in\\\">int</span> <span class=\\\"hljs-built_in\\\">list</span> = [<span class=\\\"hljs-number\\\">2</span>]\\n\\n    <span class=\\\"hljs-keyword\\\">type</span> listOfListOfInts = <span class=\\\"hljs-built_in\\\">int</span> <span class=\\\"hljs-built_in\\\">list</span> <span class=\\\"hljs-built_in\\\">list</span>\\n\\n    <span class=\\\"hljs-comment\\\">(* Parsed as: *)</span>\\n    <span class=\\\"hljs-keyword\\\">type</span> listOfListOfInts = (<span class=\\\"hljs-built_in\\\">int</span> <span class=\\\"hljs-built_in\\\">list</span>) <span class=\\\"hljs-built_in\\\">list</span></code></pre>\\n      </div>\\n<p>Things get even more strange when type constructors accept multiple parameters.\\nMultiple arguments require parenthesis and commas to separate type parameters,\\nbut those parentheses don't represent tuples. The parentheses/comma form must\\nalso be given when constructing type instances such as <code>(int, string) tuple</code>.</p>\\n<div class=\\\"gatsby-highlight\\\">\\n      <pre class=\\\"hljs lang-ocaml\\\"><code>    <span class=\\\"hljs-keyword\\\">type</span> (<span class=\\\"hljs-symbol\\\">'a</span>, <span class=\\\"hljs-symbol\\\">'b</span>) tuple = <span class=\\\"hljs-symbol\\\">'a</span> * <span class=\\\"hljs-symbol\\\">'b</span>\\n\\n    <span class=\\\"hljs-keyword\\\">type</span> listOfTuplesOfStringAndInt = (<span class=\\\"hljs-built_in\\\">string</span>, <span class=\\\"hljs-built_in\\\">int</span>) tuple <span class=\\\"hljs-built_in\\\">list</span>\\n\\n    <span class=\\\"hljs-comment\\\">(* Which is parsed as: *)</span>\\n    <span class=\\\"hljs-keyword\\\">type</span> listOfTuplesOfStringAndInt = ((<span class=\\\"hljs-built_in\\\">string</span>, <span class=\\\"hljs-built_in\\\">int</span>) tuple) <span class=\\\"hljs-built_in\\\">list</span>\\n\\n    <span class=\\\"hljs-comment\\\">(* Which allows a list of (tuples of (string and int)) *)</span>\\n    <span class=\\\"hljs-keyword\\\">let</span> tuples: listOfTuplesOfStringAndInt = [(<span class=\\\"hljs-string\\\">\\\"asdf\\\"</span>, <span class=\\\"hljs-number\\\">3</span>)]</code></pre>\\n      </div>\\n<h6>Reason:</h6>\\n<p>In summary, Reason unifies almost all of the syntax into simple \\\"function\\napplication\\\" style meaning that type parameters follow the same space-separated\\nlist pattern seen everywhere else in the syntax. As with everything else,\\nparentheses may be used to enforce precedence. This results in fewer syntactic\\npatterns to learn.</p>\\n<p>For example, you can imagine <code>list</code> being a \\\"function\\\" for types that accepts a\\ntype and returns a new type.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet x: int list = [2]\\ntype listOfListOfInts =\\n  int list list\\ntype ('a, 'b) tup = ('a \\\\* 'b)\\ntype pairs = (int, int) tup list\\nlet tuples: pairs = [(2, 3)]</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet x: list int = [2];\\ntype listOfListOfInts =\\n  list (list int);\\ntype tup 'a 'b = ('a, 'b);\\ntype pairs = list (tup int int)\\nlet tuples: pairs = [(2, 3)]</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3>Tuples as Type Parameters</h3>\\n<p>Because <code>OCaml</code> uses parens and commas to represent multiple arguments to type\\nconstructors, it's confusing when one of the arguments to a type constructor is\\nitself a tuple. In <code>OCaml</code>, it's difficult to remember the difference between a\\ntype constructor accepting multiple arguments and a type constructor accepting\\na single argument which happens to be a tuple.</p>\\n<p>The following examples shows the difference between passing <em>two</em> type\\nparameters to <code>pair</code>, and a <em>single</em> type parameter that happens to be a tuple.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\ntype intPair = (int, int) pair\\ntype pairList = (int \\\\* int) list</pre>\\n    </td>\\n    <td>\\n      <pre>\\ntype intPair = pair int int;\\ntype pairList = list (int, int);</pre>\\n    </td>\\n  </tr>\\n</table>\\n<ul>\\n<li>In <code>Reason</code>, syntax that represent tuple or tuple types, always looks like\\ntuples.</li>\\n<li>In <code>Reason</code>, syntax that represent records or record types, always look like\\nrecords.</li>\\n<li>Just about everything else uses the syntactic pattern of function application\\n(space separated arguments).</li>\\n</ul>\\n<h3>Variants</h3>\\n<h6>OCaml</h6>\\n<ul>\\n<li><code>OCaml</code> already expects constructor argument types to be specified in tuple\\nform, so it's confusing when a single constructor expects a single argument\\nthat <em>happens</em> to be a tuple type.</li>\\n<li>What's even more confusing is that the constructors don't <em>actually</em> accept\\ntuples, yet the syntax appear to resemble tuples.</li>\\n<li>Sometimes the syntax for instantiating a constructor with multiple arguments\\noverlaps the syntax for constructing a variant with a single argument that\\nhappens to be a tuple - so it looks <em>exactly</em> like you <em>are</em> supplying a\\ntuple when you are not actually supplying a tuple.</li>\\n</ul>\\n<h6>Reason</h6>\\n<ul>\\n<li>Variant constructor types are expected to be listed as space separated lists,\\nusing parenthesis to group precedence (as with <strong>everything</strong> else).</li>\\n<li>Constructing instances of the variant (as you would have guessed) follows\\nfunction application style (space separated lists).</li>\\n<li>Tuples <strong>always</strong> <em>look</em> like tuples, and anything that looks like a tuple\\n<em>is</em> a tuple.</li>\\n</ul>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\ntype myVariant =\\n   | HasNothing\\n   | HasSingleInt of int\\n   | HasSingleTuple of (int \\\\* int)\\n   | HasMultipleInts of int \\\\* int\\n   | HasMultipleTuples\\n      of (int \\\\* int) \\\\* (int\\\\* int)\\n<p>let a = HasSingleInt 10\\nlet a = HasSingleTuple (10, 10)\\nlet a = HasMultipleInts (10, 10)\\nlet a =\\nHasMultipleTuples (\\n(10, 10),\\n(10, 10)\\n)</p>\\n<p>let res = match x with\\n| HasNothing -> 0\\n| HasSingleInt x -> 0\\n| HasSingleTuple (x, y) -> 0\\n| HasMultipleInts (x, y) -> 0\\n| HasMultipleTuples\\n((x, y),\\n(q, r)) -> 0</pre>\\n</td>\\n<td>\\n<pre>\\ntype myVariant =\\n| HasNothing\\n| HasSingleInt int\\n| HasSingleTuple (int, int)\\n| HasMultipleInts int int\\n| HasMultipleTuples\\n(int, int) (int, int);</p>\\n<p>let a = HasSingleInt 10;\\nlet a = HasSingleTuple (10, 10);\\nlet a = HasMultipleInts 10 10;\\nlet a =\\nHasMultipleTuples\\n(10, 10)\\n(10, 10);</p>\\n<p>let res = switch x {\\n| HasNothing => 0\\n| HasSingleInt x => 0\\n| HasSingleTuple (x, y) => 0\\n| HasMultipleInts x y => 0\\n| HasMultipleTuples\\n(x, y)\\n(q, r) => 0\\n};</pre>\\n</td></p>\\n  </tr>\\n</table>\\n<h3>Pattern Matching</h3>\\n<h6>OCaml</h6>\\n<h6>Reason</h6>\\n<ul>\\n<li>Uses the <code>switch</code> keyword, and doesn't require <code>with</code>.</li>\\n<li><em>Requires</em> wrapping <code>switch</code> cases in <code>{}</code> to avoid confusing and error\\nprone mis-parsing when pattern matching is embedded in other pattern\\nmatching.</li>\\n<li>Uses the <code>=></code>.</li>\\n<li>Requires the leading bar. This is a good idea because it frees up other\\npossibilities in the grammar without conflicts.</li>\\n</ul>\\n<p>Can you spot the error in the <code>OCaml</code> example? This is one of the most common\\nmistakes among <code>OCaml</code> programmers. The second <code>match</code> <em>must</em> be wrapped in\\nparentheses, otherwise the <code>Some</code> case is parsed as belonging to the outer\\n<code>match</code>. <code>Reason</code>'s required <code>{}</code> blocks around match cases prevent this\\nissue.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml (BROKEN)</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet res = match x with\\n  | A (x, y) -> match y with\\n    | None -> 0\\n    | Some i -> 10\\n  | B (x, y) -> 0</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet res = switch x {\\n  | A (x, y) => switch y {\\n    | None => 0\\n    | Some i => 10\\n  }\\n  | B x y => 0\\n};</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3>Modules and Signatures</h3>\\n<h6>Defining Modules/Signatures</h6>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule type MySig = sig\\n  type t = int\\n  val x: int\\nend\\nmodule MyModule: MySig = struct\\n  type t = int\\n  let x = 10\\nend\\nmodule MyModule = struct\\n  module NestedModule = struct\\n     let msg = \\\"hello\\\";\\n  end\\nend\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule type MySig = {\\n  type t = int;\\n  let x: int;\\n};\\nmodule MyModule: MySig = {\\n  type t = int;\\n  let x = 10;\\n};\\nmodule MyModule = {\\n  module NestedModule = {\\n     let msg = \\\"hello\\\";\\n  };\\n};\\n      </pre>\\n    </td>\\n  </tr>\\n</table>\\n<h5>Functors Types</h5>\\n<p>In the same way that type parameters (think generics) were made consistent with\\nfunction application syntax, <code>Reason</code> also unifies the syntax for Functors.</p>\\n<p>In <code>Reason</code>, functor parsing rules are almost identical to the function\\nparsing rules, using <code>=></code> to represent curried application.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule type FType =\\n    functor (A: ASig) ->\\n    functor (B:BSig) -> Result\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule type FType =\\n    (A: ASig) =>\\n    (B:BSig) => Result;\\n      </pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3>Functors</h3>\\n<p>In <code>Reason</code>, the syntax for creating and applying functors is nearly identical\\nto the syntax for creating/applying functions. Also, functor <em>application</em> is\\nconsistent with function application (again, space separated lists).</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule F =\\n  functor (A:ASig) ->\\n  functor (B:BSig) ->\\n    struct end</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule F =\\n  fun (A:ASig) =>\\n  fun (B:BSig) =>\\n    {};</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule F =\\n  functor\\n    (A:ASig)\\n    (B:BSig) -> struct end</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule F =\\n  fun (A:ASig)\\n      (B:BSig) => {};</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule F\\n       (A:ASig)\\n       (B:BSig) =\\n         struct end</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule F\\n           (A:ASig)\\n           (B:BSig) =>\\n             {};</pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nmodule Res = F(A)(B)</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmodule Res = F A B;</pre>\\n    </td>\\n  </tr>\\n</table>\\n<blockquote>\\n<p>* <em>Note: There is currently a known inconsistency where functors do not\\nconform to function application syntax when in type annotation position - see\\n<code>formatTest/modules.re</code>.</em></p>\\n</blockquote>\\n<h3>Various Improvements</h3>\\n<p>OCaml doesn't require parens around sequences <code>(a;b;c;d)</code> or tuples <code>(x,y)</code>, so\\nthat ends up ruling out a bunch of other very convenient syntax rules.  Since\\nReason always uses <code>{}</code> to enclose sequences or let bindings, and <code>Reason</code>\\nalways requires <code>()</code> around tuples, many other syntax constructs are expressed\\nmore intuitively, without requiring extra wrapping in parenthesis.</p>\\n<h6>Lambdas as record fields no longer need extra parens</h6>\\n<p>This is a welcomed improvement because the <code>OCaml</code> type errors the user would\\nsee were very confusing when it would believe the function's return value\\nwas a tuple with infix <code>,</code> comma.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet myFuncs = {\\n  myFun = (fun x -> x + 1);\\n  your = (fun a b -> a + b);\\n}</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet myFuncs = {\\n  myFun: fun x => x + 1,\\n  your: fun a b => a + b\\n}</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h6>Lambdas as match results no longer need extra parens</h6>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet x = match prnt with\\n  | None -> fun a -> blah\\n  (\\\\* Extra () required ! \\\\*)\\n  | Some \\\"\\\\_\\\" -> (fun a -> ())\\n  | Some \\\"ml\\\" -> blah\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet x = switch prnt {\\n| None => fun a => blah\\n| Some \\\"_\\\" => fun a => ()\\n| Some \\\"ml\\\" => blah\\n};</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h6>Lambdas and type annotations in tuples no longer require extra parens</h6>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet tuple =\\n  ((fun x -> x), 20)\\nlet tuple =\\n  ((\\\"hi\\\": string), (20: int))\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet tuple =\\n  (fun x => x, 20);\\nlet tuple =\\n  (\\\"hi\\\": string, 20: int);\\n      </pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3>Various Differences</h3>\\n<h5><code>as</code> precedence</h5>\\n<p>With <code>Reason</code>, <code>as</code> has a higher precedence than <code>|</code> bar. This allows creating <code>as</code> aliases\\nfor entire rows in pattern matching.</p>\\n<table>\\n  <thead><tr> <th scope=\\\"col\\\"><p>OCaml</p></th><th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nlet ppp = match MyThing 20 with\\n  | (MyThing x as ppp)\\n  | (YourThing x as ppp) -> ppp;\\n      </pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet ppp = switch (MyThing 20) {\\n| MyThing x as ppp\\n| YourThing x as ppp => ppp;\\n};\\n      </pre>\\n    </td>\\n  </tr>\\n  <tr>\\n    <td>\\n      <pre>\\nlet | (MyThing \\\\_ as ppp)\\n    | (YourThing \\\\_ as ppp) = ppp;</pre>\\n    </td>\\n    <td>\\n      <pre>\\nlet | MyThing \\\\_ as ppp\\n    | YourThing \\\\_ as ppp = ppp;</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h3>Mutable Record Field Updates</h3>\\n<p>Because equalities and their negations have been made more consistent in <code>Reason</code>,\\nthe <code>=</code> operator is available for mutable field update.</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p >OCaml</p></th> <th scope=\\\"col\\\"><p>Reason</p></th></tr></thead>\\n  <tr>\\n    <td>\\n      <pre>\\nmyRec.field <- \\\"next\\\"</pre>\\n    </td>\\n    <td>\\n      <pre>\\nmyRec.field = \\\"next\\\"</pre>\\n    </td>\\n  </tr>\\n</table>\\n<h5>Prefix operators</h5>\\n<p>In Reason, <code>!</code> and other prefix operators have lower precedence than dot <code>.</code> or send <code>#</code>.\\nThis is more consistent with what other languages do, and is more practical\\nwhen (or if) the <code>!</code> symbol is used to represent boolean <code>not</code>.</p>\\n<blockquote>\\n<table>\\n<thead>\\n<tr>\\n<th>Ocaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><pre>\\n   let x = !(foo.bar);    \\n</pre></td>\\n<td><pre>\\n    let x = !foo.bar;        \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !(foo#bar);    \\n</pre></td>\\n<td><pre>\\n    let x = !foo#bar;        \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !(!foo.bar);   \\n</pre></td>\\n<td><pre>\\n    let x = !(!foo).bar;     \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !(!foo#bar);   \\n</pre></td>\\n<td><pre>\\n    let x = !(!foo)#bar;     \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !(!(foo.bar)); \\n</pre></td>\\n<td><pre>\\n    let x = !(!foo.bar);     \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !(!(foo#bar)); \\n</pre></td>\\n<td><pre>\\n    let x = !(!foo#bar);     \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !!(foo.bar);   \\n</pre></td>\\n<td><pre>\\n    let x = !!foo.bar;       \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !!(foo#bar);   \\n</pre></td>\\n<td><pre>\\n    let x = !!foo#bar;       \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !~(foo.bar);   \\n</pre></td>\\n<td><pre>\\n    let x = !~foo.bar;       \\n</pre></td>\\n</tr>\\n<tr>\\n<td><pre>\\n   let x = !~(foo#bar);   \\n</pre></td>\\n<td><pre>\\n    let x = !~foo#bar;       \\n</pre></td>\\n</tr>\\n</tbody>\\n</table>\\n</blockquote>\\n<h6>Comment Escaping</h6>\\n<p>Because Reason uses C-style comments, some obscure custom prefix/infix\\noperators must be written differently.  The rules for prefix/infix operators\\nare the same as in OCaml syntax, but with the following exceptions:</p>\\n<p>Specifically, if any character except the first in an prefix/infix operator is\\na star or forward slash, that must be first escaped with a backslash. These will\\nbe parsed <em>without</em> the backslash when added to the AST. When reprinted, the\\nescape backslashes are added back in automatically.</p>\\n<blockquote>\\n<table>\\n<thead>\\n<tr>\\n<th>OCaml</th>\\n<th>Reason</th>\\n</tr>\\n</thead>\\n<tbody>\\n<tr>\\n<td><code>\\nlet (/*) a b => a + b;       \\n</code></td>\\n<td><code>\\n     let (/\\n\\\\\\n*\\n) a b => a + b;         \\n</code></td>\\n</tr>\\n<tr>\\n<td><code>\\nlet x = 12 /-\\n*\\n 23 /-\\n*\\n 12;  \\n</code></td>\\n<td><code>\\n     let x = 12 /-\\n\\\\\\n*\\n 23 /-\\n\\\\\\n*\\n 12; \\n</code></td>\\n</tr>\\n<tr>\\n<td><code>\\nlet y = (/*) a b;            \\n</code></td>\\n<td><code>\\n     let y = (/\\n\\\\\\n*\\n) a b;            \\n</code></td>\\n</tr>\\n<tr>\\n<td><code>\\nlet (!=*) q r => q + r;      \\n</code></td>\\n<td><code>\\n     let (!=\\n\\\\\\n*\\n) q r => q + r;      \\n</code></td>\\n</tr>\\n<tr>\\n<td><code>\\nlet res = q (!=*) r;         \\n</code></td>\\n<td><code>\\n     let res = q (!=\\n\\\\\\n*\\n) r;         \\n</code></td>\\n</tr>\\n<tr>\\n<td><code>\\nlet (!=/*) q r => q + r;     \\n</code></td>\\n<td><code>\\n     let (!=\\n/\\n\\\\\\n*\\n) q r => q + r;    \\n</code></td>\\n</tr>\\n<tr>\\n<td><code>\\nlet res = q (!=/*) r;        \\n</code></td>\\n<td><code>\\n     let res = q (!=\\n/\\n\\\\\\n*\\n) r;       \\n</code></td>\\n</tr>\\n</tbody>\\n</table>\\n</blockquote>\\n<h6>Operator Renaming</h6>\\n<p>If <code>Reason</code> uses <code>==</code> to represent <code>OCaml</code>'s <code>=</code>, and\\nuses <code>===</code> to represent <code>OCaml</code>'s <code>==</code>, then how would <code>Reason</code> represent <code>OCaml</code>'s\\n<code>===</code> symbol (if it were defined)? <code>Reason</code> provides a way! \\\"Escape\\\" the triple\\nequals symbol!</p>\\n<blockquote>\\n<table>\\n</blockquote>\\n  <thead><tr> <th scope=\\\"col\\\"><p>Identifier</p></th><th scope=\\\"col\\\"><p>Meaning</p></th> <th scope=\\\"col\\\"><p>Expressed in OCaml via</p></th> <th scope=\\\"col\\\"><p>Expressed in Reason via</p></th></tr></thead>\\n  <tr>\\n  <tr>\\n    <td>\\n      <pre>\\n\\\"===\\\"</pre>\\n    </td>\\n    <td>\\n      <pre>\\nCustom value</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx === y</pre>\\n    </td>\\n    <td>\\n      <pre>\\nx \\\\=== y</pre>\\n    </td>\\n  </tr>\\n</table>\",\n\t\t\t\t\"frontmatter\": {\n\t\t\t\t\t\"title\": \"Comparison to OCaml\"\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t},\n\t\"pathContext\": {\n\t\t\"section\": \"guide\",\n\t\t\"sectionTitle\": \"Guide\",\n\t\t\"relativePath\": \"guide/ocaml.md\",\n\t\t\"relatedFiles\": \"/^guide\\\\/.*\\\\.md$/\"\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/guide-ocaml.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/guide-ocaml.json\n// module chunks = 12"],"sourceRoot":""}