webpackJsonp([13],{"./node_modules/json-loader/index.js!./.cache/json/guide-ocaml.json":function(e,n){e.exports={data:{allFile:{edges:[{node:{relativePath:"guide/examples.md",childMarkdownRemark:{frontmatter:{title:"Examples",order:20}}}},{node:{relativePath:"guide/editor-setup.md",childMarkdownRemark:{frontmatter:{title:"Editor setup",order:1}}}},{node:{relativePath:"guide/getting-started.md",childMarkdownRemark:{frontmatter:{title:"Getting started",order:0}}}},{node:{relativePath:"guide/index.md",childMarkdownRemark:{frontmatter:{title:"The Reason Guide",order:0}}}},{node:{relativePath:"guide/tools.md",childMarkdownRemark:{frontmatter:{title:"Tools",order:4}}}},{node:{relativePath:"guide/ocaml.md",childMarkdownRemark:{frontmatter:{title:"Comparison to OCaml",order:10}}}},{node:{relativePath:"guide/native/index.md",childMarkdownRemark:{frontmatter:{title:"Native",order:5}}}},{node:{relativePath:"guide/native/convert-from-ocaml.md",childMarkdownRemark:{frontmatter:{title:"Converting from OCaml",order:4}}}},{node:{relativePath:"guide/native/quickstart.md",childMarkdownRemark:{frontmatter:{title:"Quickstart",order:0}}}},{node:{relativePath:"guide/language/data-types.md",childMarkdownRemark:{frontmatter:{title:"Built-in Data Types",order:2}}}},{node:{relativePath:"guide/language/conditionals.md",childMarkdownRemark:{frontmatter:{title:"Conditionals",order:4}}}},{node:{relativePath:"guide/language/destructuring.md",childMarkdownRemark:{frontmatter:{title:"Destructuring & Pattern Matching",order:5}}}},{node:{relativePath:"guide/language/externals.md",childMarkdownRemark:{frontmatter:{title:"Externals",order:11}}}},{node:{relativePath:"guide/language/functions.md",childMarkdownRemark:{frontmatter:{title:"Functions",order:3}}}},{node:{relativePath:"guide/language/imperative-loops.md",childMarkdownRemark:{frontmatter:{title:"Imperative Loops",order:9}}}},{node:{relativePath:"guide/language/index.md",childMarkdownRemark:{frontmatter:{title:"Language basics",order:1}}}},{node:{relativePath:"guide/language/jsx.md",childMarkdownRemark:{frontmatter:{title:"JSX",order:10}}}},{node:{relativePath:"guide/language/let-bindings.md",childMarkdownRemark:{frontmatter:{title:"Let Bindings",order:2}}}},{node:{relativePath:"guide/language/mutation.md",childMarkdownRemark:{frontmatter:{title:"Mutation",order:8}}}},{node:{relativePath:"guide/language/modules.md",childMarkdownRemark:{frontmatter:{title:"Modules",order:12}}}},{node:{relativePath:"guide/language/more-types.md",childMarkdownRemark:{frontmatter:{title:"More on Types",order:7}}}},{node:{relativePath:"guide/language/more-functions.md",childMarkdownRemark:{frontmatter:{title:"More on Functions",order:6}}}},{node:{relativePath:"guide/language/primitives.md",childMarkdownRemark:{frontmatter:{title:"Primitives",order:0}}}},{node:{relativePath:"guide/language/types.md",childMarkdownRemark:{frontmatter:{title:"Types",order:1}}}},{node:{relativePath:"guide/javascript/index.md",childMarkdownRemark:{frontmatter:{title:"JavaScript",order:4}}}},{node:{relativePath:"guide/javascript/converting.md",childMarkdownRemark:{frontmatter:{title:"Converting from JS",order:5}}}},{node:{relativePath:"guide/javascript/libraries.md",childMarkdownRemark:{frontmatter:{title:"Libraries",order:2}}}},{node:{relativePath:"guide/javascript/quickstart.md",childMarkdownRemark:{frontmatter:{title:"Quickstart",order:0}}}},{node:{relativePath:"guide/javascript/interop.md",childMarkdownRemark:{frontmatter:{title:"Interop",order:1}}}},{node:{relativePath:"guide/javascript/syntax-cheetsheet.md",childMarkdownRemark:{frontmatter:{title:"Syntax cheetsheet",order:1}}}}]},file:{relativePath:"guide/ocaml.md",childMarkdownRemark:{html:'<p>A quick reference for OCaml programmers.</p>\n<h3>Comments</h3>\n<p>Reason comments use the C-family style of comments, and OCaml comments use <code>(* *)</code> style comments. In Reason, nested <code>/**/</code> comments are validated at parse\ntime, and in OCaml, nested <code>(* *)</code> are validated at parse time.\nReason will also <em>eventually</em> support line comments, which are not supported in OCaml.</p>\n<table>\n  <thead><tr> <th scope="col"><p >OCaml</p></th> <th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <code>\n(* OCaml (*nest*) *)\n      </code>\n    </td>\n    <td>\n      <code>\n/* Reason /*nest*/  */\n      </code>\n    </td>\n  </tr>\n</table>\n<h3>REPL (<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">Read-Eval-Print-Loop</a>)</h3>\n<p>In Reason\'s repl <code>rtop</code> (a customized <code>utop</code>), each input is submitted via\na single <code>;</code> semicolon. OCaml\'s repl requires two semicolons <code>;;</code>.</p>\n<table>\n  <thead><tr> <th scope="col"><p >OCaml REPL</p></th> <th scope="col"><p>Reason REPL</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>;;</pre>\n    </td>\n    <td>\n      <pre>;</pre>\n    </td>\n  </tr>\n</table>\n<h3>Operator Renaming</h3>\n<p>Reason has all of OCaml\'s infix operators, but a couple of operators\nare <em>expressed</em> differently.\nIn Reason, structural equality is written as <code>==</code>, and reference equality\n(physical equality)\nis written as <code>===</code> (so just remember to add an extra <code>=</code> to what OCaml\nrequires). In Reason, to achieve the corresponding <em>inequality</em>,\nsimply swap the first character with a <code>!</code> character. (<code>!=</code> for structural\ninequality, and <code>!==</code> for reference inequality). Reason\'s\nsymbol choices are slightly more consistent and follow the ES6 conventions.</p>\n<table>\n  <thead><tr><th scope="col"><p>Equality</p></th> <th scope="col"><p>Expressed in OCaml via</p></th> <th scope="col"><p>Expressed in Reason via</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nstructural</pre>\n    </td>\n    <td>\n      <pre>\nx = y</pre>\n    </td>\n    <td>\n      <pre>\nx == y</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nreference</pre>\n    </td>\n    <td>\n      <pre>\nx == y</pre>\n    </td>\n    <td>\n      <pre>\nx === y</pre>\n    </td>\n  </tr>\n  <thead><tr><th scope="col"><p>Inequality</p></th> <th scope="col"><p>Expressed in OCaml via</p></th> <th scope="col"><p>Expressed in Reason via</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nstructural</pre>\n    </td>\n    <td>\n      <pre>\nx <> y</pre>\n    </td>\n    <td>\n      <pre>\nx != y</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nreference</pre>\n    </td>\n    <td>\n      <pre>\nx != y</pre>\n    </td>\n    <td>\n      <pre>\nx !== y</pre>\n    </td>\n  </tr>\n</table>\n<h3>Local Scope</h3>\n<p>Reason\'s lexical scoping is exactly the same as OCaml\'s, but let bindings\nsyntactically resemble "block scope" which is more familiar to many\ndevelopers. In Reason, they are created with <code>{}</code> braces, which\nmay contain both <code>let</code> bindings and imperative commands, separated by <code>;</code>.\nAll blocks <em>evaluate</em> to the last line and the semicolon on the last line is\noptional. <code>{}</code> braces are only needed if you have more than one item to chain\ntogether via <code>;</code>.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet _ =\n  let msg = "Hello" in\n  print_string msg;\n  let msg2 = "Goodbye" in\n  print_string msg2</pre>\n    </td>\n    <td>\n      <pre>\n{\n  let msg = "Hello";\n  print_string msg;\n  let msg2 = "Goodbye";\n  print_string msg2\n};</pre>\n    </td>\n  </tr>\n</table>\n<p>Reason\'s <code>{}</code> syntax removes many commonly reported pain points in OCaml\'s\nsyntax:</p>\n<ul>\n<li>Double semicolons are removed entirely.</li>\n<li><code>begin</code>/<code>end</code> is removed entirely.</li>\n<li>Infamous imperative parsing <a href="https://github.com/ocaml/ocaml/pull/278">issues</a> are gone.</li>\n<li>Module bodies and local scope are unified.</li>\n</ul>\n<h3>Local Scope Vs. Module Bodies</h3>\n<p>In Reason, everything that can go between the <code>{}</code> in <a href="#reason-vs-ml-syntax-local-scope">Local\nScopes</a> and in module bodies. You can usually\neven cut/paste code between the two contexts. In OCaml, the syntaxes for the two\ncontexts are very different. (Local scope requires trailing <code>in</code>, but module bodies do\nnot and some imperative statements must be assigned to <code>_</code> or <code>()</code>, or else use double <code>;;</code>).\nReason greatly simplifies the syntax for new <em>and</em> experienced ML programmers.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml Module Body</p></th><th scope="col"><p>Reason Module Body</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet ten = 10\nlet () = imperativeFunc ten ten\nlet () = imperativeFunc 0 0</pre>\n    </td>\n    <td>\n      <pre>\nlet ten = 10;\nimperativeFunc ten ten;\nimperativeFunc 0 0;</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet ten = 10;;\nimperativeFunc ten ten;;\nimperativeFunc 0 0;;</pre>\n    </td>\n    <td>*Same as above*</td>\n  </tr>\n  <thead><tr> <th scope="col"><p>OCaml Local Scope</p></th><th scope="col"><p>Reason Local Scope</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet ten = 10 in\nlet _ = imperativeFunc ten ten in\nimperativeFunc 0 0</pre>\n    </td>\n    <td>\n       *same as above*\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet ten = 10 in begin\n  imperativeFunc ten ten;\n  imperativeFunc 0 0\nend</pre>\n    </td>\n    <td>\n       *same as above*\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet ten = 10 in (\n  imperativeFunc ten ten;\n  imperativeFunc 0 0\n)</pre>\n    </td>\n    <td>\n       *same as above*\n    </td>\n  </tr>\n</table>\n<h3>Tuples and Records</h3>\n<p>In Reason, tuples always require parentheses. This requirement makes Reason easier to\nread and also removes the need for type annotations inside of tuple members\nto be wrapped in <em>additional</em> parentheses.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>let tup = 4, 5</pre>\n    </td>\n    <td>\n      <pre>let tup = (4, 5);</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>let tup = ((1: int), (2:int))</pre>\n    </td>\n    <td>\n      <pre>let tup = (1: int, 2:int);</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>fun ((a:int), (b:int)) -> a </pre>\n    </td>\n    <td>\n      <pre>fun (a:int, b:int) => a</pre>\n    </td>\n  </tr>\n</table>\n<p>In Reason, records resemble JavaScript, using <code>:</code> instead of <code>=</code>. Because\nReason tuples always require wrapping parens, records may contain lambdas as values\nwithout needing extra parens.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet myRec = {x = 0; y = 10}</pre>\n    </td>\n    <td>\n      <pre>\nlet myRec = {x: 0, y: 10};</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet myFuncs = {\n  myFun = (fun x -> x + 1);\n  your = (fun a b -> a + b);\n}</pre>\n    </td>\n    <td>\n      <pre>\nlet myFuncs = {\n  myFun: fun x => x + 1,\n  your: fun a b => a + b\n};</pre>\n    </td>\n</table>\n<h3>Lists</h3>\n<p>Lists in Reason are delimited with commas rather than semi-colons as they are in JavaScript. Reason also uses JavaScript\'s spread syntax for list concatenation instead of the <code>::</code> operator.</p>\n<table>\n<thead><tr> <th scope="col"><p>OCaml Lists</p></th><th scope="col"><p>Reason Lists</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>let list = [1; 2; 3]</pre>\n      <pre>let list = hd :: tl</pre>\n    </td>\n    <td>\n      <pre>let list = [1, 2, 3];</pre>\n      <pre>let list = [hd, ...tl];</pre>\n    </td>\n  </tr>\n</table>\n<h3>Type Definitions</h3>\n<p>With Reason, types generally look like the values they represent.  There is\nonly one syntactic pattern to learn for each kind of type. Whereas in OCaml,\nthere are separate syntaxes for tuple types <code>(x * y)</code> and tuple values\n<code>(x, y)</code>).</p>\n<table>\n<thead><tr> <th scope="col"><p>OCaml Tuples</p></th><th scope="col"><p>Reason Tuples</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\ntype tuple = int * int\nlet tup: tuple = (10, 30)</pre>\n    </td>\n    <td>\n      <pre>\ntype tuple = (int, int);\nlet tup: tuple = (10, 30);</pre>\n    </td>\n  </tr>\n<thead><tr> <th scope="col"><p>OCaml Records</p></th><th scope="col"><p>Reason Records</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\ntype r =\n  {x: int; y: int};\nlet myRec: r = {x = 0; y = 10};</pre>\n    </td>\n    <td>\n      <pre>\ntype r =\n  {x: int, y: int};\nlet myRec: r = {x: 0, y: 10};</pre>\n    </td>\n  </tr>\n<thead><tr> <th scope="col"><p>OCaml Functions</p></th><th scope="col"><p>Reason Functions</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\ntype func = int -> int;\nlet x: func = fun a -> a + 1;</pre>\n    </td>\n    <td>\n      <pre>\ntype func = int => int;\nlet x: func = fun a => a + 1;</pre>\n    </td>\n  </tr>\n</table>\n<h3>Functions</h3>\n<p>OCaml has three ways to define functions:</p>\n<ul>\n<li>Some OCaml forms use arrows <code>-></code>, some use equals <code>=</code>.</li>\n<li>Some OCaml forms use the <code>fun</code> keyword, others use the <code>function</code> keyword.</li>\n</ul>\n<p>Reason also supports the same three ways to define lambdas, but for\nconsistency:</p>\n<ul>\n<li>Every Reason form uses an <code>=></code> arrow in one way or another.</li>\n<li>Reason uses at most one keyword (<code>fun</code>).</li>\n<li>As with all pattern matching, the leading bar <code>|</code> is required in the single\nargument pattern match form.</li>\n</ul>\n<h6>Single argument match functions</h6>\n<p>OCaml has a function definition (<code>function |</code>) which is considered to be\nequivalent of <code>function a -> match a with ...</code>. Reason has the same, but\nthe syntax makes it clear how it is actually an extension of a single argument\nfunction. The single case match is a natural extension of the simple lambda,\nand the multicase lambda is a natural extension of the single case lambda.</p>\n<table>\n  <thead><tr> <th scope="col"><p>Form</p></th><th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      lambda\n    </td>\n    <td>\n      <pre>\nfun pat -> e</pre>\n    </td>\n    <td>\n      <pre>\nfun pat => e</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      one match case\n    </td>\n    <td>\n      <pre>\nfunction | pat -> e</pre>\n    </td>\n    <td>\n      <pre>\nfun | pat => e</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      many cases\n    </td>\n    <td>\n      <pre>\nfunction | pat -> e\n         | pat2 -> e</pre>\n    </td>\n    <td>\n      <pre>\nfun | pat => e\n    | pat2 => e</pre>\n    </td>\n  </tr>\n</table>\n<h6>Let binding for curried functions</h6>\n<p>Both OCaml and Reason syntax offer a syntactic sugar for expressing curried\nfunctions. The following table shows three equivalent definitions which are\nidentical once parsed. As always, all Reason functions include an <code>=></code> arrow.</p>\n<table> <thead><tr><th scope="col"><p>OCaml</p></th><th\n        scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet x = fun a -> fun b -> e</pre>\n    </td>\n    <td>\n      <pre>\nlet x = fun a => fun b => e;</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet x = fun a b -> e</pre>\n    </td>\n    <td>\n      <pre>\nlet x = fun a b => e;</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet x a b = e</pre>\n    </td>\n    <td>\n      <pre>\nlet x a b => e;</pre>\n    </td>\n  </tr>\n</table>\n<h3>Annotating Function Arguments</h3>\n<p>In both Reason and OCaml, arguments are annotated with types by (as with\neverything else), wrapping them in parenthesis after appending\n<code>:typeAnnotation</code>.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> (arg<span class="hljs-params"> :<span class="hljs-params"> argType)<span class="hljs-params"> </span></span></span></span></span>=&gt; returnValue;</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> (arg<span class="hljs-params"> :<span class="hljs-params"> argType)<span class="hljs-params"> </span></span></span></span></span>=&gt; <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> (arg2<span class="hljs-params"> :<span class="hljs-params"> arg2Type)<span class="hljs-params"> </span></span></span></span></span>=&gt; returnValue;</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> (arg<span class="hljs-params"> :<span class="hljs-params"> argType)<span class="hljs-params"> (arg2<span class="hljs-params"> :<span class="hljs-params"> arg2Type)<span class="hljs-params"> </span></span></span></span></span></span></span></span>=&gt; returnValue;</code></pre>\n      </div>\n<p>Both Reason and OCaml allow annotating the return type, when using the\n"super sugared let binding" form.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code><span class="hljs-comment">(* OCaml *)</span>\n<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span> = (a, b)\n<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>]\n<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-keyword">fun</span> x -&gt; x + a + b</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* Reason */</span>\n<span class="hljs-keyword">let</span> myFunc (a:int) (b:int) :(int, int) =&gt; (a, b);\n<span class="hljs-keyword">let</span> myFunc (a:int) (b:int) :list int =&gt; [<span class="hljs-number">1</span>];\n<span class="hljs-keyword">let</span> myFunc (a:int) (b:int) :(int =&gt; int) =&gt; <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> x<span class="hljs-params"> </span></span></span>=&gt; x + a + b;</code></pre>\n      </div>\n<blockquote>\n<p>Because we\'re using <code>=></code> for all functions everywhere in Reason, there\'s\none case where we need to add extra parens around a return type that is\nitself a function type.</p>\n</blockquote>\n<h3>Type Parameters</h3>\n<h6>OCaml:</h6>\n<p>OCaml\'s type applications (think "generics"), are applied in reverse order.</p>\n<p>With OCaml, there are some unintuitive consequences of this.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code>    <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> = [<span class="hljs-number">2</span>]\n\n    <span class="hljs-keyword">type</span> listOfListOfInts = <span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">list</span>\n\n    <span class="hljs-comment">(* Parsed as: *)</span>\n    <span class="hljs-keyword">type</span> listOfListOfInts = (<span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span>) <span class="hljs-built_in">list</span></code></pre>\n      </div>\n<p>Things get even more strange when type constructors accept multiple parameters.\nMultiple arguments require parenthesis and commas to separate type parameters,\nbut those parentheses don\'t represent tuples. The parentheses/comma form must\nalso be given when constructing type instances such as <code>(int, string) tuple</code>.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code>    <span class="hljs-keyword">type</span> (<span class="hljs-symbol">\'a</span>, <span class="hljs-symbol">\'b</span>) tuple = <span class="hljs-symbol">\'a</span> * <span class="hljs-symbol">\'b</span>\n\n    <span class="hljs-keyword">type</span> listOfTuplesOfStringAndInt = (<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) tuple <span class="hljs-built_in">list</span>\n\n    <span class="hljs-comment">(* Which is parsed as: *)</span>\n    <span class="hljs-keyword">type</span> listOfTuplesOfStringAndInt = ((<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) tuple) <span class="hljs-built_in">list</span>\n\n    <span class="hljs-comment">(* Which allows a list of (tuples of (string and int)) *)</span>\n    <span class="hljs-keyword">let</span> tuples: listOfTuplesOfStringAndInt = [(<span class="hljs-string">"asdf"</span>, <span class="hljs-number">3</span>)]</code></pre>\n      </div>\n<h6>Reason:</h6>\n<p>In summary, Reason unifies almost all of the syntax into simple "function\napplication" style meaning that type parameters follow the same space-separated\nlist pattern seen everywhere else in the syntax. As with everything else,\nparentheses may be used to enforce precedence. This results in fewer syntactic\npatterns to learn.</p>\n<p>For example, you can imagine <code>list</code> being a "function" for types that accepts a\ntype and returns a new type.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet x: int list = [2]\ntype listOfListOfInts =\n  int list list\ntype (\'a, \'b) tup = (\'a * \'b)\ntype pairs = (int, int) tup list\nlet tuples: pairs = [(2, 3)]</pre>\n    </td>\n    <td>\n      <pre>\nlet x: list int = [2];\ntype listOfListOfInts =\n  list (list int);\ntype tup \'a \'b = (\'a, \'b);\ntype pairs = list (tup int int)\nlet tuples: pairs = [(2, 3)]</pre>\n    </td>\n  </tr>\n</table>\n<h3>Tuples as Type Parameters</h3>\n<p>Because OCaml uses parens and commas to represent multiple arguments to type\nconstructors, it\'s confusing when one of the arguments to a type constructor is\nitself a tuple. In OCaml, it\'s difficult to remember the difference between a\ntype constructor accepting multiple arguments and a type constructor accepting\na single argument which happens to be a tuple.</p>\n<p>The following examples shows the difference between passing <em>two</em> type\nparameters to <code>pair</code>, and a <em>single</em> type parameter that happens to be a tuple.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\ntype intPair = (int, int) pair\ntype pairList = (int * int) list</pre>\n    </td>\n    <td>\n      <pre>\ntype intPair = pair int int;\ntype pairList = list (int, int);</pre>\n    </td>\n  </tr>\n</table>\n<ul>\n<li>In Reason, syntax that represent tuple or tuple types, always looks like\ntuples.</li>\n<li>In Reason, syntax that represent records or record types, always look like\nrecords.</li>\n<li>Just about everything else uses the syntactic pattern of function application\n(space separated arguments).</li>\n</ul>\n<h3>Variants</h3>\n<h6>OCaml</h6>\n<ul>\n<li>OCaml already expects constructor argument types to be specified in tuple\nform, so it\'s confusing when a single constructor expects a single argument\nthat <em>happens</em> to be a tuple type.</li>\n<li>What\'s even more confusing is that the constructors don\'t <em>actually</em> accept\ntuples, yet the syntax appear to resemble tuples.</li>\n<li>Sometimes the syntax for instantiating a constructor with multiple arguments\noverlaps the syntax for constructing a variant with a single argument that\nhappens to be a tuple - so it looks <em>exactly</em> like you <em>are</em> supplying a\ntuple when you are not actually supplying a tuple.</li>\n</ul>\n<h6>Reason</h6>\n<ul>\n<li>Variant constructor types are expected to be listed as space separated lists,\nusing parenthesis to group precedence (as with <strong>everything</strong> else).</li>\n<li>Constructing instances of the variant (as you would have guessed) follows\nfunction application style (space separated lists).</li>\n<li>Tuples <strong>always</strong> <em>look</em> like tuples, and anything that looks like a tuple\n<em>is</em> a tuple.</li>\n</ul>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\ntype myVariant =\n   | HasNothing\n   | HasSingleInt of int\n   | HasSingleTuple of (int * int)\n   | HasMultipleInts of int * int\n   | HasMultipleTuples\n      of (int * int) * (int * int)\n<p>let a = HasSingleInt 10\nlet a = HasSingleTuple (10, 10)\nlet a = HasMultipleInts (10, 10)\nlet a =\nHasMultipleTuples (\n(10, 10),\n(10, 10)\n)</p>\n<p>let res = match x with\n| HasNothing -> 0\n| HasSingleInt x -> 0\n| HasSingleTuple (x, y) -> 0\n| HasMultipleInts (x, y) -> 0\n| HasMultipleTuples\n((x, y),\n(q, r)) -> 0</pre>\n</td>\n<td>\n<pre>\ntype myVariant =\n| HasNothing\n| HasSingleInt int\n| HasSingleTuple (int, int)\n| HasMultipleInts int int\n| HasMultipleTuples\n(int, int) (int, int);</p>\n<p>let a = HasSingleInt 10;\nlet a = HasSingleTuple (10, 10);\nlet a = HasMultipleInts 10 10;\nlet a =\nHasMultipleTuples\n(10, 10)\n(10, 10);</p>\n<p>let res = switch x {\n| HasNothing => 0\n| HasSingleInt x => 0\n| HasSingleTuple (x, y) => 0\n| HasMultipleInts x y => 0\n| HasMultipleTuples\n(x, y)\n(q, r) => 0\n};</pre>\n</td></p>\n  </tr>\n</table>\n<h3>Pattern Matching</h3>\n<h6>OCaml</h6>\n<h6>Reason</h6>\n<ul>\n<li>Uses the <code>switch</code> keyword, and doesn\'t require <code>with</code>.</li>\n<li><em>Requires</em> wrapping <code>switch</code> cases in <code>{}</code> to avoid confusing and error\nprone mis-parsing when pattern matching is embedded in other pattern\nmatching.</li>\n<li>Uses the <code>=></code>.</li>\n<li>Requires the leading bar. This is a good idea because it frees up other\npossibilities in the grammar without conflicts.</li>\n</ul>\n<p>Can you spot the error in the OCaml example? This is one of the most common\nmistakes among OCaml programmers. The second <code>match</code> <em>must</em> be wrapped in\nparentheses, otherwise the <code>Some</code> case is parsed as belonging to the outer\n<code>match</code>. Reason\'s required <code>{}</code> blocks around match cases prevent this\nissue.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml (BROKEN)</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet res = match x with\n  | A (x, y) -> match y with\n    | None -> 0\n    | Some i -> 10\n  | B (x, y) -> 0</pre>\n    </td>\n    <td>\n      <pre>\nlet res = switch x {\n  | A (x, y) => switch y {\n    | None => 0\n    | Some i => 10\n  }\n  | B x y => 0\n};</pre>\n    </td>\n  </tr>\n</table>\n<h3>Modules and Signatures</h3>\n<h6>Defining Modules/Signatures</h6>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nmodule type MySig = sig\n  type t = int\n  val x: int\nend\nmodule MyModule: MySig = struct\n  type t = int\n  let x = 10\nend\nmodule MyModule = struct\n  module NestedModule = struct\n     let msg = "hello";\n  end\nend\n      </pre>\n    </td>\n    <td>\n      <pre>\nmodule type MySig = {\n  type t = int;\n  let x: int;\n};\nmodule MyModule: MySig = {\n  type t = int;\n  let x = 10;\n};\nmodule MyModule = {\n  module NestedModule = {\n     let msg = "hello";\n  };\n};\n      </pre>\n    </td>\n  </tr>\n</table>\n<h5>Functors Types</h5>\n<p>In the same way that type parameters (think generics) were made consistent with\nfunction application syntax, Reason also unifies the syntax for Functors.</p>\n<p>In Reason, functor parsing rules are almost identical to the function\nparsing rules, using <code>=></code> to represent curried application.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nmodule type FType =\n    functor (A: ASig) ->\n    functor (B:BSig) -> Result\n      </pre>\n    </td>\n    <td>\n      <pre>\nmodule type FType =\n    (A: ASig) =>\n    (B:BSig) => Result;\n      </pre>\n    </td>\n  </tr>\n</table>\n<h3>Functors</h3>\n<p>In Reason, the syntax for creating and applying functors is nearly identical\nto the syntax for creating/applying functions. Also, functor <em>application</em> is\nconsistent with function application (again, space separated lists).</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nmodule F =\n  functor (A:ASig) ->\n  functor (B:BSig) ->\n    struct end</pre>\n    </td>\n    <td>\n      <pre>\nmodule F =\n  fun (A:ASig) =>\n  fun (B:BSig) =>\n    {};</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nmodule F =\n  functor\n    (A:ASig)\n    (B:BSig) -> struct end</pre>\n    </td>\n    <td>\n      <pre>\nmodule F =\n  fun (A:ASig)\n      (B:BSig) => {};</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nmodule F\n       (A:ASig)\n       (B:BSig) =\n         struct end</pre>\n    </td>\n    <td>\n      <pre>\nmodule F\n           (A:ASig)\n           (B:BSig) =>\n             {};</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nmodule Res = F(A)(B)</pre>\n    </td>\n    <td>\n      <pre>\nmodule Res = F A B;</pre>\n    </td>\n  </tr>\n</table>\n<p><strong>Note: There is currently a known inconsistency where functors do not\nconform to function application syntax when in type annotation position - see\n<code>formatTest/modules.re</code>.</strong></p>\n<h3>Various Improvements</h3>\n<p>OCaml doesn\'t require parens around sequences <code>(a;b;c;d)</code> or tuples <code>(x,y)</code>, so\nthat ends up ruling out a bunch of other very convenient syntax rules.  Since\nReason always uses <code>{}</code> to enclose sequences or let bindings, and Reason\nalways requires <code>()</code> around tuples, many other syntax constructs are expressed\nmore intuitively, without requiring extra wrapping in parenthesis.</p>\n<h6>Lambdas as record fields no longer need extra parens</h6>\n<p>This is a welcomed improvement because the OCaml type errors the user would\nsee were very confusing when it would believe the function\'s return value\nwas a tuple with infix <code>,</code> comma.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet myFuncs = {\n  myFun = (fun x -> x + 1);\n  your = (fun a b -> a + b);\n}</pre>\n    </td>\n    <td>\n      <pre>\nlet myFuncs = {\n  myFun: fun x => x + 1,\n  your: fun a b => a + b\n}</pre>\n    </td>\n  </tr>\n</table>\n<h6>Lambdas as match results no longer need extra parens</h6>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet x = match prnt with\n  | None -> fun a -> blah\n  (* Extra () required ! *)\n  | Some "_" -> (fun a -> ())\n  | Some "ml" -> blah\n      </pre>\n    </td>\n    <td>\n      <pre>\nlet x = switch prnt {\n| None => fun a => blah\n| Some "_" => fun a => ()\n| Some "ml" => blah\n};</pre>\n    </td>\n  </tr>\n</table>\n<h6>Lambdas and type annotations in tuples no longer require extra parens</h6>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet tuple =\n  ((fun x -> x), 20)\nlet tuple =\n  (("hi": string), (20: int))\n      </pre>\n    </td>\n    <td>\n      <pre>\nlet tuple =\n  (fun x => x, 20);\nlet tuple =\n  ("hi": string, 20: int);\n      </pre>\n    </td>\n  </tr>\n</table>\n<h3>Various Differences</h3>\n<h5><code>as</code> precedence</h5>\n<p>With Reason, <code>as</code> has a higher precedence than <code>|</code> bar. This allows creating <code>as</code> aliases\nfor entire rows in pattern matching.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet ppp = match MyThing 20 with\n  | (MyThing x as ppp)\n  | (YourThing x as ppp) -> ppp;\n      </pre>\n    </td>\n    <td>\n      <pre>\nlet ppp = switch (MyThing 20) {\n| MyThing x as ppp\n| YourThing x as ppp => ppp;\n};\n      </pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet | (MyThing _ as ppp)\n    | (YourThing _ as ppp) = ppp;</pre>\n    </td>\n    <td>\n      <pre>\nlet | MyThing _ as ppp\n    | YourThing _ as ppp = ppp;</pre>\n    </td>\n  </tr>\n</table>\n<h3>Mutable Record Field Updates</h3>\n<p>Because equalities and their negations have been made more consistent in Reason,\nthe <code>=</code> operator is available for mutable field update.</p>\n<table>\n  <thead><tr> <th scope="col"><p >OCaml</p></th> <th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nmyRec.field <- "next"</pre>\n    </td>\n    <td>\n      <pre>\nmyRec.field = "next"</pre>\n    </td>\n  </tr>\n</table>\n<h5>Prefix operators</h5>\n<p>In Reason, <code>!</code> and other prefix operators have lower precedence than dot <code>.</code> or send <code>#</code>.\nThis is more consistent with what other languages do, and is more practical\nwhen (or if) the <code>!</code> symbol is used to represent boolean <code>not</code>.</p>\n<table>\n<thead>\n<tr>\n<th>OCaml</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><pre>\n   let x = !(foo.bar);    \n</pre></td>\n<td><pre>\n    let x = !foo.bar;        \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !(foo#bar);    \n</pre></td>\n<td><pre>\n    let x = !foo#bar;        \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !(!foo.bar);   \n</pre></td>\n<td><pre>\n    let x = !(!foo).bar;     \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !(!foo#bar);   \n</pre></td>\n<td><pre>\n    let x = !(!foo)#bar;     \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !(!(foo.bar)); \n</pre></td>\n<td><pre>\n    let x = !(!foo.bar);     \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !(!(foo#bar)); \n</pre></td>\n<td><pre>\n    let x = !(!foo#bar);     \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !!(foo.bar);   \n</pre></td>\n<td><pre>\n    let x = !!foo.bar;       \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !!(foo#bar);   \n</pre></td>\n<td><pre>\n    let x = !!foo#bar;       \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !~(foo.bar);   \n</pre></td>\n<td><pre>\n    let x = !~foo.bar;       \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !~(foo#bar);   \n</pre></td>\n<td><pre>\n    let x = !~foo#bar;       \n</pre></td>\n</tr>\n</tbody>\n</table>\n<h6>Comment Escaping</h6>\n<p>Because Reason uses C-style comments, some obscure custom prefix/infix\noperators must be written differently.  The rules for prefix/infix operators\nare the same as in OCaml syntax, but with the following exceptions:</p>\n<p>Specifically, if any character except the first in an prefix/infix operator is\na star or forward slash, that must be first escaped with a backslash. These will\nbe parsed <em>without</em> the backslash when added to the AST. When reprinted, the\nescape backslashes are added back in automatically.</p>\n<table>\n<thead>\n<tr>\n<th>OCaml</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\nlet (/*) a b => a + b;       \n</code></td>\n<td><code>\n     let (/\n\\\n*) a b => a + b;         \n</code></td>\n</tr>\n<tr>\n<td><code>\nlet x = 12 /-* 23 /-* 12;  \n</code></td>\n<td><code>\n     let x = 12 /-\n\\\n* 23 /-\n\\\n* 12; \n</code></td>\n</tr>\n<tr>\n<td><code>\nlet y = (/*) a b;            \n</code></td>\n<td><code>\n     let y = (/\n\\\n*) a b;            \n</code></td>\n</tr>\n<tr>\n<td><code>\nlet (!=*) q r => q + r;      \n</code></td>\n<td><code>\n     let (!=\n\\\n*) q r => q + r;      \n</code></td>\n</tr>\n<tr>\n<td><code>\nlet res = q (!=*) r;         \n</code></td>\n<td><code>\n     let res = q (!=\n\\\n*) r;         \n</code></td>\n</tr>\n<tr>\n<td><code>\nlet (!=/*) q r => q + r;     \n</code></td>\n<td><code>\n     let (!=\n/\n\\\n*) q r => q + r;    \n</code></td>\n</tr>\n<tr>\n<td><code>\nlet res = q (!=/*) r;        \n</code></td>\n<td><code>\n     let res = q (!=\n/\n\\\n*) r;       \n</code></td>\n</tr>\n</tbody>\n</table>\n<h6>Operator Renaming</h6>\n<p>If Reason uses <code>==</code> to represent OCaml\'s <code>=</code>, and\nuses <code>===</code> to represent OCaml\'s <code>==</code>, then how would Reason represent OCaml\'s\n<code>===</code> symbol (if it were defined)? Reason provides a way! "Escape" the triple\nequals symbol!</p>\n<table>\n  <thead><tr> <th scope="col"><p>Identifier</p></th><th scope="col"><p>Meaning</p></th> <th scope="col"><p>Expressed in OCaml via</p></th> <th scope="col"><p>Expressed in Reason via</p></th></tr></thead>\n  <tr>\n  <tr>\n    <td>\n      <pre>\n"==="</pre>\n    </td>\n    <td>\n      <pre>\nCustom value</pre>\n    </td>\n    <td>\n      <pre>\nx === y</pre>\n    </td>\n    <td>\n      <pre>\nx \\=== y</pre>\n    </td>\n  </tr>\n</table>',
frontmatter:{title:"Comparison to OCaml"}}}},pathContext:{section:"guide",sectionTitle:"Guide",relativePath:"guide/ocaml.md",relatedFiles:"/^guide\\/.*\\.md$/"}}}});
//# sourceMappingURL=path---guide-ocaml-a8bdc92790b2d9d1f711.js.map