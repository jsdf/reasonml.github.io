webpackJsonp([12],{"./node_modules/json-loader/index.js!./.cache/json/guide-search.json":function(e,n){e.exports={data:{allFile:{edges:[{node:{relativePath:"guide/examples.md",childMarkdownRemark:{frontmatter:{title:"Examples",order:20},html:'<p>An example is worth a thousand words.</p>\n<p>This section is dedicated to newcomers trying to figure out general idioms &#x26; conventions in Reason and BuckleScript. If you\'re a beginner who\'s got a good idea for an example, please suggest an edit!</p>\n<h3>Using the <code>option</code> type</h3>\n<p><code>option</code> is a <a href="/guide/language/data-types#variant">variant</a> that comes with the <a href="/api/index.html">standard library</a>. It obviates the need for null values in other languages.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> possiblyNullValue1 = <span class="hljs-type">None</span>;\n<span class="hljs-keyword">let</span> possiblyNullValue2 = <span class="hljs-type">Some</span> <span class="hljs-string">"Hello@"</span>;\n\n<span class="hljs-keyword">switch</span> possiblyNullValue2 {\n| <span class="hljs-type">None</span> =&gt; print_endline <span class="hljs-string">"Nothing to see here."</span>\n| <span class="hljs-type">Some</span> message =&gt; print_endline message\n};</code></pre>\n      </div>\n<h3>Creating a parametrized type</h3>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> universityStudent = {gpa: float};\n\n<span class="hljs-keyword">type</span> response \'studentType = {status: int, student: \'studentType};\n\n<span class="hljs-keyword">let</span> result: response universityStudent = fetchDataFromServer ();</code></pre>\n      </div>\n<h3>Creating a JS Object</h3>\n<p>Assuming you\'re <a href="/guide/javascript">compiling to JS</a>, of course.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> obj1 = {\n  <span class="hljs-string">"name"</span>: <span class="hljs-string">"John"</span>,\n  <span class="hljs-string">"age"</span>: <span class="hljs-number">30</span>\n};\n<span class="hljs-comment">/* Compiles to a JS object that looks exactly like what you\'re seeing */</span></code></pre>\n      </div>\n<p>Note that the above isn\'t a record; the keys are quoted in string. That\'s Reason syntax sugar for <a href="http://bucklescript.github.io/bucklescript/Manual.html#_create_js_objects_using_bs_obj">bs.obj</a>. The type is inferred. Next example explicitly types it.</p>\n<h3>Typing a JS Object</h3>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> payload = <span class="hljs-type">Js</span>.t {.\n  name: string,\n  age: int\n};\n<span class="hljs-keyword">let</span> obj1: payload = {<span class="hljs-string">"name"</span>: <span class="hljs-string">"John"</span>, <span class="hljs-string">"age"</span>: <span class="hljs-number">30</span>};</code></pre>\n      </div>\n<p>Note that <code>{. name: string, age: int}</code> is the syntax for a Reason/OCaml object type declaration (not a record!). It\'s lifted into <code>Js.t</code> so that BuckleScript sees the whole type and compiles it correctly to a regular JavaScript object. Ordinary, non-lifted OCaml objects are compiled into something else (rarely needed currently).</p>\n<h3>Binding to a JS Module with Default Export</h3>\n<p>Assuming the module\'s called <code>store.js</code>, and has a default export, plus a method called <code>getDate</code>.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> store = <span class="hljs-type">Js</span>.t {. getDate : (unit =&gt; float) [@bs.meth]};\nexternal store : store = <span class="hljs-string">"./store"</span> [@@bs.<span class="hljs-keyword">module</span>];\n<span class="hljs-type">Js</span>.log store;\n<span class="hljs-type">Js</span>.log (store##getDate ());</code></pre>\n      </div>'}}},{node:{relativePath:"guide/editor-setup.md",childMarkdownRemark:{frontmatter:{title:"Editor setup",order:1},html:'<p>See our <a href="/guide/tools">tooling</a> section for a descriptions of what you need to install and which editors we support.\nOur <a href="/guide/tools#editor-integration">editor integration</a> need a few binaries to be found in your <code>$PATH</code>:</p>\n<ul>\n<li><code>refmt</code>: the Reason parser/printer (editor formatter).</li>\n<li><code>ocamlmerlin-reason</code>: Reason bridge to <a href="/guide/tools#tools-command-line-utilities-merlin">Merlin</a>.</li>\n<li>\n<p><code>ocamlmerlin</code>: the Merlin binary.\nThe tooling section explains what these binaries do.\n<strong>Install reason-cli globally</strong> with npm:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-sh"><code><span class="hljs-comment">## on Linux:</span>\nnpm install -g https://github.com/reasonml/reason-cli/archive/beta-v-<span class="hljs-number">1.13</span>.<span class="hljs-number">6</span>-bin-linux.tar.gz\n<span class="hljs-comment">## on MacOS:</span>\nnpm install -g https://github.com/reasonml/reason-cli/archive/beta-v-<span class="hljs-number">1.13</span>.<span class="hljs-number">6</span>-bin-darwin.tar.gz\n<span class="hljs-comment">## test that you have them installed correctly</span>\n<span class="hljs-built_in">which</span> ocamlmerlin refmt ocamlmerlin-reason</code></pre>\n      </div>\n<p><strong>Note</strong>: the global toolchain <code>reason-cli</code> currently doesn\'t work on Windows.\n<strong>Note</strong>: please verify that your installed OCaml version is <code>4.02.x</code> and that Merlin is <code>>=2.5.1</code>. The above installation does that automatically, but people sometimes install our toolchain through other ways (e.g. native workflow, with looser version constraints).</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-sh"><code>ocamlc -version\nocamlmerlin -version</code></pre>\n      </div>\n</li>\n</ul>'}}},{node:{relativePath:"guide/getting-started.md",childMarkdownRemark:{frontmatter:{title:"Getting started",order:0},html:'<p>Here\'s how you start!</p>\n<ul>\n<li><a href="/guide/javascript/quickstart">JavaScript quickstart</a></li>\n<li><a href="/guide/native/quickstart">Native quickstart</a></li>\n<li><a href="/guide/editor-setup">Set up your editor</a></li>\n</ul>'}}},{node:{relativePath:"guide/index.md",childMarkdownRemark:{frontmatter:{title:"The Reason Guide",order:0},html:"<p>Here's the guide! Hope you enjoy it.</p>"}}},{node:{relativePath:"guide/tools.md",childMarkdownRemark:{frontmatter:{title:"Tools",order:4},html:'<h2>Reason-tools</h2>\n<p><a href="https://github.com/reasonml/reason-tools">Reason-tools</a> is a convenient browser\nextension for quickly toggling between OCaml syntax and Reason syntax. It also\nprettifies the OCaml libraries documentation pages.\n<a href="https://reasonml.github.io/reason-tools/popup.html">Here</a>\'s the standalone\nversion.</p>\n<h2>Command Line Utilities</h2>\n<p>The Reason toolchain uses a few important tools that are used in the terminal,\nand/or with your editor.</p>\n<p><strong>Note</strong>: the <a href="/guide/javascript">JavaScript</a>\nand <a href="/guide/native">native</a>\nworkflow have different ways of installing  these tools. Please consult their\nrespective sections for the installation proper. This section only describes\nwhat they are.</p>\n<h3>Refmt</h3>\n<p><code>refmt</code> ("Reason format") takes in your code text and spits it out, nicely formatted. Developers\nuse it pervasively to prettify their code, either through invoking it in the\nterminal, or through an editor shortcut. It also serves to convert to/from\nReason/OCaml syntax.</p>\n<p><code>refmt</code> optionally takes in a column width, and <strong>responsively</strong> formats your\ncode based on it. In other words, it doesn\'t just naively break to the next line\nat a certain characters limit; it solves the constrains and arranges your code\naccordingly. Here\'s <code>refmt</code> inside Vim, called once per window resize (just to\nshow the point):</p>\n<html><head></head><body><img src="images/LiquidSmallOptCrop.gif" style="width:100%; max-width:466px; max-height:433px;"></body></html>\n<p>The Reason community uses it to enforce a consistent style and avoid time-consuming\nmanual formatting &#x26; stylistic debates.</p>\n<p>See <code>refmt --help</code> for the options.</p>\n<h3>Merlin</h3>\n<p><a href="https://github.com/ocaml/merlin">Merlin</a> provides type hint, refactor, real-\ntime errors, jump to definitions, etc. to our editors.</p>\n<p>Merlin\'s command line name is called <code>ocamlmerlin</code>, though you wouldn\'t call it\nmanually (editors start it themselves and query it). To configure Merlin to\nunderstand your project, you\'d write a <code>.merlin</code> file at the root (documentation\n<a href="https://github.com/ocaml/merlin/wiki/project-configuration">here</a>).</p>\n<p><strong>Note</strong>: For the JS workflow, we generate the <code>.merlin</code> file for you, so no\nneed to worry about it.</p>\n<p>Merlin is for OCaml, but has first-class support for Reason. <strong>For the support to\nwork, you\'d need the <code>ocamlmerlin-reason</code> binary</strong>. Again, the installation of\nthese utilities are described in the <a href="/guide/javascript">JS Workflow</a>\nand <a href="/guide/native">Native Workflow</a>\npage.</p>\n<h3>REPL</h3>\n<p>Reason comes with a REPL called <code>rtop</code> which lets you interactively evaluate\nReason. It features intelligent, type-driven autocompletion.</p>\n<html><head></head><body><img src="images/RtopOptCrop.gif" style="width:100%; max-width:466px; max-height:433px;"></body></html>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-sh"><code><span class="hljs-comment"># The rtop command begins a REPL session</span>\nrtop</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-sh"><code><span class="hljs-built_in">let</span> myVar = <span class="hljs-string">"Hello Reason!"</span>;\n<span class="hljs-comment"># myVar: bytes = "Hello Reason!"</span>\n\n<span class="hljs-built_in">let</span> result = <span class="hljs-number">100</span> + <span class="hljs-number">200</span>;\n<span class="hljs-comment"># result : int = 300;</span></code></pre>\n      </div>\n<p>Use <code>#quit;</code> to close your REPL session.</p>\n<h1>Editor Integration</h1>\n<p>All our editor integrations provides at minimum:</p>\n<ul>\n<li>Displaying types.</li>\n<li><code>refmt</code>-ing a file.</li>\n<li>Showing errors</li>\n<li>Syntax highlighting.</li>\n</ul>\n<p>They\'re powered by Reason\'s <code>refmt</code> and Merlin, mentioned in the previous sections.</p>\n<h3>VSCode (recommended)</h3>\n<p>The Visual Studio Code Reason plugin offers lots of great features and polish.\n<a href="https://github.com/freebroccolo/vscode-reasonml">https://github.com/freebroccolo/vscode-reasonml</a></p>\n<h3>Atom</h3>\n<p>You can install the <a href="https://atom.io/">Atom</a> Reason integration through either\n<a href="https://atom.io/packages/ocaml-merlin">atom-ocaml-merlin</a> or\n<a href="https://nuclide.io/">Nuclide</a>. The former is lighter.</p>\n<html><head></head><body></body></html>\n<h4>OCaml-Merlin</h4>\n<p>As per the instructions <a href="https://atom.io/packages/ocaml-merlin">here</a>, you\'ll also need:</p>\n<ul>\n<li><a href="https://atom.io/packages/language-reason">language-reason</a></li>\n<li><a href="https://atom.io/packages/linter-refmt">linter-refmt</a></li>\n<li><a href="https://atom.io/packages/reason-refmt">reason-refmt</a></li>\n</ul>\n<p>As noted on the page, you\'ll also need the linter (which itself needs Linter-ui-default,\nIntention and Busy-signal).</p>\n<p><strong>Note</strong>: if you\'ve installed the global binaries through the <a href="./gettingStarted.html#javascript-workflow-project-setup">JS Workflow</a> then you can ignore the <code>opam install merlin</code> instructions at the end.</p>\n<h4>Nuclide</h4>\n<p>Alternatively, if you use Nuclide:</p>\n<ul>\n<li>Open the package installer from the menu <code>Packages > Settings View > Install Packages and Themes</code>.</li>\n<li>Search for and install <code>nuclide</code> if not already installed.</li>\n<li>\n<p>If you don\'t want to turn on all of Nuclide\'s features, you can disable most of it except for:</p>\n<ul>\n<li>nuclide-ocaml</li>\n<li>hyperclick</li>\n<li>autocomplete</li>\n<li>linter</li>\n<li>nuclide-code-format</li>\n<li>nuclide-outline-view</li>\n<li>nuclide-datatip</li>\n<li>nuclide-language-reason</li>\n<li>nuclide-type-hint</li>\n</ul>\n</li>\n</ul>\n<p>We piggy back on Nuclide\'s facilities (formatting, diagnosis, datatip). <code>⌘+shift+p</code> and search for these keywords).</p>\n<h3>Vim</h3>\n<p>Install <a href="https://github.com/reasonml-editor/vim-reason">vim-reason</a> like you would any Vim plugin.</p>\n<p>For example, through <a href="https://github.com/Shougo/neobundle.vim">NeoBundle</a>:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-none"><code><span class="hljs-type">NeoBundle</span> <span class="hljs-symbol">\'reasonml</span>-editor/vim-reason\'</code></pre>\n      </div>\n<p>Likewise for <a href="https://github.com/junegunn/vim-plug">vim-plug</a> and others.</p>\n<html><head></head><body></body></html>\n<h4>Merlin</h4>\n<p><code>merlin</code> has built in <code>Vim</code> support.</p>\n<p>Completion is provided using <code>omnifunc</code>. By default you can trigger it with <code>&#x3C;C-X>&#x3C;C-O></code> while in insert mode.\nIf you use completion plugins, most of them can use <code>omni</code> as a source.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-none"><code><span class="hljs-string">" deoplete\n\nlet g:deoplete#omni_patterns = {}\nlet g:deoplete#omni_patterns.reason = \'[^. *\\t]\\.\\w*\\|\\h\\w*|#\'\nlet g:deoplete#sources = {}\nlet g:deoplete#sources.reason = [\'omni\', \'buffer\']\n\n"</span> neocomplete <span class="hljs-keyword">and</span> <span class="hljs-type">YouCompleteMe</span> work out <span class="hljs-keyword">of</span> the box</code></pre>\n      </div>\n<p>You can use syntactic checks with plugins like <a href="https://github.com/vim-syntastic/syntastic">Syntastic</a> (vim-reason should just work with it out of the box), ALE, and others.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-none"><code>" For ALE\n\nlet g:ale_linter_aliases = {\'reason\': \'ocaml\'}</code></pre>\n      </div>\n<p>See the other provided Merlin features in the <a href="https://github.com/reasonml-editor/vim-reason#merlin">README</a>.</p>\n<p>The command <code>:ReasonPrettyPrint</code> invokes the binary <code>refmt</code> and formats text in the current buffer.\nYou can set <code>g:vimreason_extra_args_expr_reason</code> variable to control the arguments passed to <code>refmt</code> (such as <code>--print-width</code>).</p>\n<h3>Emacs</h3>\n<p><a href="https://github.com/arichiardi/reason-mode">Reason-mode</a> provides <code>refmt</code> and optional REPL support.\nFor Merlin support, merlin-mode is on <a href="https://www.emacswiki.org/emacs/ELPA">Elpa</a>. Please see merlin-mode\'s usage <a href="https://github.com/ocaml/merlin/wiki/emacs-from-scratch#discovering-the-emacs-mode">here</a> (ignore the installation part above).</p>\n<h3>Sublime Text</h3>\n<p><em>Experimental</em>. Doesn\'t support Merlin yet!\n<a href="https://github.com/reasonml-editor/sublime-reason">https://github.com/reasonml-editor/sublime-reason</a></p>\n<h3>IDEA</h3>\n<p><em>Experimental</em>.\n<a href="https://github.com/reasonml-editor/reasonml-idea-plugin">https://github.com/reasonml-editor/reasonml-idea-plugin</a></p>'}}},{node:{relativePath:"guide/ocaml.md",childMarkdownRemark:{frontmatter:{title:"Comparison to OCaml",order:10},html:'<p>A quick reference for OCaml programmers.</p>\n<h3>Comments</h3>\n<p>Reason comments use the C-family style of comments, and OCaml comments use <code>(* *)</code> style comments. In Reason, nested <code>/**/</code> comments are validated at parse\ntime, and in OCaml, nested <code>(* *)</code> are validated at parse time.\nReason will also <em>eventually</em> support line comments, which are not supported in OCaml.</p>\n<table>\n  <thead><tr> <th scope="col"><p >OCaml</p></th> <th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <code>\n(* OCaml (*nest*) *)\n      </code>\n    </td>\n    <td>\n      <code>\n/* Reason /*nest*/  */\n      </code>\n    </td>\n  </tr>\n</table>\n<h3>REPL (<a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">Read-Eval-Print-Loop</a>)</h3>\n<p>In Reason\'s repl <code>rtop</code> (a customized <code>utop</code>), each input is submitted via\na single <code>;</code> semicolon. OCaml\'s repl requires two semicolons <code>;;</code>.</p>\n<table>\n  <thead><tr> <th scope="col"><p >OCaml REPL</p></th> <th scope="col"><p>Reason REPL</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>;;</pre>\n    </td>\n    <td>\n      <pre>;</pre>\n    </td>\n  </tr>\n</table>\n<h3>Operator Renaming</h3>\n<p>Reason has all of OCaml\'s infix operators, but a couple of operators\nare <em>expressed</em> differently.\nIn Reason, structural equality is written as <code>==</code>, and reference equality\n(physical equality)\nis written as <code>===</code> (so just remember to add an extra <code>=</code> to what OCaml\nrequires). In Reason, to achieve the corresponding <em>inequality</em>,\nsimply swap the first character with a <code>!</code> character. (<code>!=</code> for structural\ninequality, and <code>!==</code> for reference inequality). Reason\'s\nsymbol choices are slightly more consistent and follow the ES6 conventions.</p>\n<table>\n  <thead><tr><th scope="col"><p>Equality</p></th> <th scope="col"><p>Expressed in OCaml via</p></th> <th scope="col"><p>Expressed in Reason via</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nstructural</pre>\n    </td>\n    <td>\n      <pre>\nx = y</pre>\n    </td>\n    <td>\n      <pre>\nx == y</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nreference</pre>\n    </td>\n    <td>\n      <pre>\nx == y</pre>\n    </td>\n    <td>\n      <pre>\nx === y</pre>\n    </td>\n  </tr>\n  <thead><tr><th scope="col"><p>Inequality</p></th> <th scope="col"><p>Expressed in OCaml via</p></th> <th scope="col"><p>Expressed in Reason via</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nstructural</pre>\n    </td>\n    <td>\n      <pre>\nx <> y</pre>\n    </td>\n    <td>\n      <pre>\nx != y</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nreference</pre>\n    </td>\n    <td>\n      <pre>\nx != y</pre>\n    </td>\n    <td>\n      <pre>\nx !== y</pre>\n    </td>\n  </tr>\n</table>\n<h3>Local Scope</h3>\n<p>Reason\'s lexical scoping is exactly the same as OCaml\'s, but let bindings\nsyntactically resemble "block scope" which is more familiar to many\ndevelopers. In Reason, they are created with <code>{}</code> braces, which\nmay contain both <code>let</code> bindings and imperative commands, separated by <code>;</code>.\nAll blocks <em>evaluate</em> to the last line and the semicolon on the last line is\noptional. <code>{}</code> braces are only needed if you have more than one item to chain\ntogether via <code>;</code>.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet _ =\n  let msg = "Hello" in\n  print_string msg;\n  let msg2 = "Goodbye" in\n  print_string msg2</pre>\n    </td>\n    <td>\n      <pre>\n{\n  let msg = "Hello";\n  print_string msg;\n  let msg2 = "Goodbye";\n  print_string msg2\n};</pre>\n    </td>\n  </tr>\n</table>\n<p>Reason\'s <code>{}</code> syntax removes many commonly reported pain points in OCaml\'s\nsyntax:</p>\n<ul>\n<li>Double semicolons are removed entirely.</li>\n<li><code>begin</code>/<code>end</code> is removed entirely.</li>\n<li>Infamous imperative parsing <a href="https://github.com/ocaml/ocaml/pull/278">issues</a> are gone.</li>\n<li>Module bodies and local scope are unified.</li>\n</ul>\n<h3>Local Scope Vs. Module Bodies</h3>\n<p>In Reason, everything that can go between the <code>{}</code> in <a href="#reason-vs-ml-syntax-local-scope">Local\nScopes</a> and in module bodies. You can usually\neven cut/paste code between the two contexts. In OCaml, the syntaxes for the two\ncontexts are very different. (Local scope requires trailing <code>in</code>, but module bodies do\nnot and some imperative statements must be assigned to <code>_</code> or <code>()</code>, or else use double <code>;;</code>).\nReason greatly simplifies the syntax for new <em>and</em> experienced ML programmers.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml Module Body</p></th><th scope="col"><p>Reason Module Body</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet ten = 10\nlet () = imperativeFunc ten ten\nlet () = imperativeFunc 0 0</pre>\n    </td>\n    <td>\n      <pre>\nlet ten = 10;\nimperativeFunc ten ten;\nimperativeFunc 0 0;</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet ten = 10;;\nimperativeFunc ten ten;;\nimperativeFunc 0 0;;</pre>\n    </td>\n    <td>*Same as above*</td>\n  </tr>\n  <thead><tr> <th scope="col"><p>OCaml Local Scope</p></th><th scope="col"><p>Reason Local Scope</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet ten = 10 in\nlet _ = imperativeFunc ten ten in\nimperativeFunc 0 0</pre>\n    </td>\n    <td>\n       *same as above*\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet ten = 10 in begin\n  imperativeFunc ten ten;\n  imperativeFunc 0 0\nend</pre>\n    </td>\n    <td>\n       *same as above*\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet ten = 10 in (\n  imperativeFunc ten ten;\n  imperativeFunc 0 0\n)</pre>\n    </td>\n    <td>\n       *same as above*\n    </td>\n  </tr>\n</table>\n<h3>Tuples and Records</h3>\n<p>In Reason, tuples always require parentheses. This requirement makes Reason easier to\nread and also removes the need for type annotations inside of tuple members\nto be wrapped in <em>additional</em> parentheses.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>let tup = 4, 5</pre>\n    </td>\n    <td>\n      <pre>let tup = (4, 5);</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>let tup = ((1: int), (2:int))</pre>\n    </td>\n    <td>\n      <pre>let tup = (1: int, 2:int);</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>fun ((a:int), (b:int)) -> a </pre>\n    </td>\n    <td>\n      <pre>fun (a:int, b:int) => a</pre>\n    </td>\n  </tr>\n</table>\n<p>In Reason, records resemble JavaScript, using <code>:</code> instead of <code>=</code>. Because\nReason tuples always require wrapping parens, records may contain lambdas as values\nwithout needing extra parens.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet myRec = {x = 0; y = 10}</pre>\n    </td>\n    <td>\n      <pre>\nlet myRec = {x: 0, y: 10};</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet myFuncs = {\n  myFun = (fun x -> x + 1);\n  your = (fun a b -> a + b);\n}</pre>\n    </td>\n    <td>\n      <pre>\nlet myFuncs = {\n  myFun: fun x => x + 1,\n  your: fun a b => a + b\n};</pre>\n    </td>\n</table>\n<h3>Lists</h3>\n<p>Lists in Reason are delimited with commas rather than semi-colons as they are in JavaScript. Reason also uses JavaScript\'s spread syntax for list concatenation instead of the <code>::</code> operator.</p>\n<table>\n<thead><tr> <th scope="col"><p>OCaml Lists</p></th><th scope="col"><p>Reason Lists</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>let list = [1; 2; 3]</pre>\n      <pre>let list = hd :: tl</pre>\n    </td>\n    <td>\n      <pre>let list = [1, 2, 3];</pre>\n      <pre>let list = [hd, ...tl];</pre>\n    </td>\n  </tr>\n</table>\n<h3>Type Definitions</h3>\n<p>With Reason, types generally look like the values they represent.  There is\nonly one syntactic pattern to learn for each kind of type. Whereas in OCaml,\nthere are separate syntaxes for tuple types <code>(x * y)</code> and tuple values\n<code>(x, y)</code>).</p>\n<table>\n<thead><tr> <th scope="col"><p>OCaml Tuples</p></th><th scope="col"><p>Reason Tuples</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\ntype tuple = int * int\nlet tup: tuple = (10, 30)</pre>\n    </td>\n    <td>\n      <pre>\ntype tuple = (int, int);\nlet tup: tuple = (10, 30);</pre>\n    </td>\n  </tr>\n<thead><tr> <th scope="col"><p>OCaml Records</p></th><th scope="col"><p>Reason Records</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\ntype r =\n  {x: int; y: int};\nlet myRec: r = {x = 0; y = 10};</pre>\n    </td>\n    <td>\n      <pre>\ntype r =\n  {x: int, y: int};\nlet myRec: r = {x: 0, y: 10};</pre>\n    </td>\n  </tr>\n<thead><tr> <th scope="col"><p>OCaml Functions</p></th><th scope="col"><p>Reason Functions</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\ntype func = int -> int;\nlet x: func = fun a -> a + 1;</pre>\n    </td>\n    <td>\n      <pre>\ntype func = int => int;\nlet x: func = fun a => a + 1;</pre>\n    </td>\n  </tr>\n</table>\n<h3>Functions</h3>\n<p>OCaml has three ways to define functions:</p>\n<ul>\n<li>Some OCaml forms use arrows <code>-></code>, some use equals <code>=</code>.</li>\n<li>Some OCaml forms use the <code>fun</code> keyword, others use the <code>function</code> keyword.</li>\n</ul>\n<p>Reason also supports the same three ways to define lambdas, but for\nconsistency:</p>\n<ul>\n<li>Every Reason form uses an <code>=></code> arrow in one way or another.</li>\n<li>Reason uses at most one keyword (<code>fun</code>).</li>\n<li>As with all pattern matching, the leading bar <code>|</code> is required in the single\nargument pattern match form.</li>\n</ul>\n<h6>Single argument match functions</h6>\n<p>OCaml has a function definition (<code>function |</code>) which is considered to be\nequivalent of <code>function a -> match a with ...</code>. Reason has the same, but\nthe syntax makes it clear how it is actually an extension of a single argument\nfunction. The single case match is a natural extension of the simple lambda,\nand the multicase lambda is a natural extension of the single case lambda.</p>\n<table>\n  <thead><tr> <th scope="col"><p>Form</p></th><th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      lambda\n    </td>\n    <td>\n      <pre>\nfun pat -> e</pre>\n    </td>\n    <td>\n      <pre>\nfun pat => e</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      one match case\n    </td>\n    <td>\n      <pre>\nfunction | pat -> e</pre>\n    </td>\n    <td>\n      <pre>\nfun | pat => e</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      many cases\n    </td>\n    <td>\n      <pre>\nfunction | pat -> e\n         | pat2 -> e</pre>\n    </td>\n    <td>\n      <pre>\nfun | pat => e\n    | pat2 => e</pre>\n    </td>\n  </tr>\n</table>\n<h6>Let binding for curried functions</h6>\n<p>Both OCaml and Reason syntax offer a syntactic sugar for expressing curried\nfunctions. The following table shows three equivalent definitions which are\nidentical once parsed. As always, all Reason functions include an <code>=></code> arrow.</p>\n<table> <thead><tr><th scope="col"><p>OCaml</p></th><th\n        scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet x = fun a -> fun b -> e</pre>\n    </td>\n    <td>\n      <pre>\nlet x = fun a => fun b => e;</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet x = fun a b -> e</pre>\n    </td>\n    <td>\n      <pre>\nlet x = fun a b => e;</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet x a b = e</pre>\n    </td>\n    <td>\n      <pre>\nlet x a b => e;</pre>\n    </td>\n  </tr>\n</table>\n<h3>Annotating Function Arguments</h3>\n<p>In both Reason and OCaml, arguments are annotated with types by (as with\neverything else), wrapping them in parenthesis after appending\n<code>:typeAnnotation</code>.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> (arg<span class="hljs-params"> :<span class="hljs-params"> argType)<span class="hljs-params"> </span></span></span></span></span>=&gt; returnValue;</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> (arg<span class="hljs-params"> :<span class="hljs-params"> argType)<span class="hljs-params"> </span></span></span></span></span>=&gt; <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> (arg2<span class="hljs-params"> :<span class="hljs-params"> arg2Type)<span class="hljs-params"> </span></span></span></span></span>=&gt; returnValue;</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> (arg<span class="hljs-params"> :<span class="hljs-params"> argType)<span class="hljs-params"> (arg2<span class="hljs-params"> :<span class="hljs-params"> arg2Type)<span class="hljs-params"> </span></span></span></span></span></span></span></span>=&gt; returnValue;</code></pre>\n      </div>\n<p>Both Reason and OCaml allow annotating the return type, when using the\n"super sugared let binding" form.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code><span class="hljs-comment">(* OCaml *)</span>\n<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span> = (a, b)\n<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>]\n<span class="hljs-keyword">let</span> myFunc (a:<span class="hljs-built_in">int</span>) (b:<span class="hljs-built_in">int</span>) :<span class="hljs-built_in">int</span> -&gt; <span class="hljs-built_in">int</span> = <span class="hljs-keyword">fun</span> x -&gt; x + a + b</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* Reason */</span>\n<span class="hljs-keyword">let</span> myFunc (a:int) (b:int) :(int, int) =&gt; (a, b);\n<span class="hljs-keyword">let</span> myFunc (a:int) (b:int) :list int =&gt; [<span class="hljs-number">1</span>];\n<span class="hljs-keyword">let</span> myFunc (a:int) (b:int) :(int =&gt; int) =&gt; <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> x<span class="hljs-params"> </span></span></span>=&gt; x + a + b;</code></pre>\n      </div>\n<blockquote>\n<p>Because we\'re using <code>=></code> for all functions everywhere in Reason, there\'s\none case where we need to add extra parens around a return type that is\nitself a function type.</p>\n</blockquote>\n<h3>Type Parameters</h3>\n<h6>OCaml:</h6>\n<p>OCaml\'s type applications (think "generics"), are applied in reverse order.</p>\n<p>With OCaml, there are some unintuitive consequences of this.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code>    <span class="hljs-keyword">let</span> x: <span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> = [<span class="hljs-number">2</span>]\n\n    <span class="hljs-keyword">type</span> listOfListOfInts = <span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span> <span class="hljs-built_in">list</span>\n\n    <span class="hljs-comment">(* Parsed as: *)</span>\n    <span class="hljs-keyword">type</span> listOfListOfInts = (<span class="hljs-built_in">int</span> <span class="hljs-built_in">list</span>) <span class="hljs-built_in">list</span></code></pre>\n      </div>\n<p>Things get even more strange when type constructors accept multiple parameters.\nMultiple arguments require parenthesis and commas to separate type parameters,\nbut those parentheses don\'t represent tuples. The parentheses/comma form must\nalso be given when constructing type instances such as <code>(int, string) tuple</code>.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code>    <span class="hljs-keyword">type</span> (<span class="hljs-symbol">\'a</span>, <span class="hljs-symbol">\'b</span>) tuple = <span class="hljs-symbol">\'a</span> * <span class="hljs-symbol">\'b</span>\n\n    <span class="hljs-keyword">type</span> listOfTuplesOfStringAndInt = (<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) tuple <span class="hljs-built_in">list</span>\n\n    <span class="hljs-comment">(* Which is parsed as: *)</span>\n    <span class="hljs-keyword">type</span> listOfTuplesOfStringAndInt = ((<span class="hljs-built_in">string</span>, <span class="hljs-built_in">int</span>) tuple) <span class="hljs-built_in">list</span>\n\n    <span class="hljs-comment">(* Which allows a list of (tuples of (string and int)) *)</span>\n    <span class="hljs-keyword">let</span> tuples: listOfTuplesOfStringAndInt = [(<span class="hljs-string">"asdf"</span>, <span class="hljs-number">3</span>)]</code></pre>\n      </div>\n<h6>Reason:</h6>\n<p>In summary, Reason unifies almost all of the syntax into simple "function\napplication" style meaning that type parameters follow the same space-separated\nlist pattern seen everywhere else in the syntax. As with everything else,\nparentheses may be used to enforce precedence. This results in fewer syntactic\npatterns to learn.</p>\n<p>For example, you can imagine <code>list</code> being a "function" for types that accepts a\ntype and returns a new type.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet x: int list = [2]\ntype listOfListOfInts =\n  int list list\ntype (\'a, \'b) tup = (\'a * \'b)\ntype pairs = (int, int) tup list\nlet tuples: pairs = [(2, 3)]</pre>\n    </td>\n    <td>\n      <pre>\nlet x: list int = [2];\ntype listOfListOfInts =\n  list (list int);\ntype tup \'a \'b = (\'a, \'b);\ntype pairs = list (tup int int)\nlet tuples: pairs = [(2, 3)]</pre>\n    </td>\n  </tr>\n</table>\n<h3>Tuples as Type Parameters</h3>\n<p>Because OCaml uses parens and commas to represent multiple arguments to type\nconstructors, it\'s confusing when one of the arguments to a type constructor is\nitself a tuple. In OCaml, it\'s difficult to remember the difference between a\ntype constructor accepting multiple arguments and a type constructor accepting\na single argument which happens to be a tuple.</p>\n<p>The following examples shows the difference between passing <em>two</em> type\nparameters to <code>pair</code>, and a <em>single</em> type parameter that happens to be a tuple.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\ntype intPair = (int, int) pair\ntype pairList = (int * int) list</pre>\n    </td>\n    <td>\n      <pre>\ntype intPair = pair int int;\ntype pairList = list (int, int);</pre>\n    </td>\n  </tr>\n</table>\n<ul>\n<li>In Reason, syntax that represent tuple or tuple types, always looks like\ntuples.</li>\n<li>In Reason, syntax that represent records or record types, always look like\nrecords.</li>\n<li>Just about everything else uses the syntactic pattern of function application\n(space separated arguments).</li>\n</ul>\n<h3>Variants</h3>\n<h6>OCaml</h6>\n<ul>\n<li>OCaml already expects constructor argument types to be specified in tuple\nform, so it\'s confusing when a single constructor expects a single argument\nthat <em>happens</em> to be a tuple type.</li>\n<li>What\'s even more confusing is that the constructors don\'t <em>actually</em> accept\ntuples, yet the syntax appear to resemble tuples.</li>\n<li>Sometimes the syntax for instantiating a constructor with multiple arguments\noverlaps the syntax for constructing a variant with a single argument that\nhappens to be a tuple - so it looks <em>exactly</em> like you <em>are</em> supplying a\ntuple when you are not actually supplying a tuple.</li>\n</ul>\n<h6>Reason</h6>\n<ul>\n<li>Variant constructor types are expected to be listed as space separated lists,\nusing parenthesis to group precedence (as with <strong>everything</strong> else).</li>\n<li>Constructing instances of the variant (as you would have guessed) follows\nfunction application style (space separated lists).</li>\n<li>Tuples <strong>always</strong> <em>look</em> like tuples, and anything that looks like a tuple\n<em>is</em> a tuple.</li>\n</ul>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\ntype myVariant =\n   | HasNothing\n   | HasSingleInt of int\n   | HasSingleTuple of (int * int)\n   | HasMultipleInts of int * int\n   | HasMultipleTuples\n      of (int * int) * (int * int)\n<p>let a = HasSingleInt 10\nlet a = HasSingleTuple (10, 10)\nlet a = HasMultipleInts (10, 10)\nlet a =\nHasMultipleTuples (\n(10, 10),\n(10, 10)\n)</p>\n<p>let res = match x with\n| HasNothing -> 0\n| HasSingleInt x -> 0\n| HasSingleTuple (x, y) -> 0\n| HasMultipleInts (x, y) -> 0\n| HasMultipleTuples\n((x, y),\n(q, r)) -> 0</pre>\n</td>\n<td>\n<pre>\ntype myVariant =\n| HasNothing\n| HasSingleInt int\n| HasSingleTuple (int, int)\n| HasMultipleInts int int\n| HasMultipleTuples\n(int, int) (int, int);</p>\n<p>let a = HasSingleInt 10;\nlet a = HasSingleTuple (10, 10);\nlet a = HasMultipleInts 10 10;\nlet a =\nHasMultipleTuples\n(10, 10)\n(10, 10);</p>\n<p>let res = switch x {\n| HasNothing => 0\n| HasSingleInt x => 0\n| HasSingleTuple (x, y) => 0\n| HasMultipleInts x y => 0\n| HasMultipleTuples\n(x, y)\n(q, r) => 0\n};</pre>\n</td></p>\n  </tr>\n</table>\n<h3>Pattern Matching</h3>\n<h6>OCaml</h6>\n<h6>Reason</h6>\n<ul>\n<li>Uses the <code>switch</code> keyword, and doesn\'t require <code>with</code>.</li>\n<li><em>Requires</em> wrapping <code>switch</code> cases in <code>{}</code> to avoid confusing and error\nprone mis-parsing when pattern matching is embedded in other pattern\nmatching.</li>\n<li>Uses the <code>=></code>.</li>\n<li>Requires the leading bar. This is a good idea because it frees up other\npossibilities in the grammar without conflicts.</li>\n</ul>\n<p>Can you spot the error in the OCaml example? This is one of the most common\nmistakes among OCaml programmers. The second <code>match</code> <em>must</em> be wrapped in\nparentheses, otherwise the <code>Some</code> case is parsed as belonging to the outer\n<code>match</code>. Reason\'s required <code>{}</code> blocks around match cases prevent this\nissue.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml (BROKEN)</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet res = match x with\n  | A (x, y) -> match y with\n    | None -> 0\n    | Some i -> 10\n  | B (x, y) -> 0</pre>\n    </td>\n    <td>\n      <pre>\nlet res = switch x {\n  | A (x, y) => switch y {\n    | None => 0\n    | Some i => 10\n  }\n  | B x y => 0\n};</pre>\n    </td>\n  </tr>\n</table>\n<h3>Modules and Signatures</h3>\n<h6>Defining Modules/Signatures</h6>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nmodule type MySig = sig\n  type t = int\n  val x: int\nend\nmodule MyModule: MySig = struct\n  type t = int\n  let x = 10\nend\nmodule MyModule = struct\n  module NestedModule = struct\n     let msg = "hello";\n  end\nend\n      </pre>\n    </td>\n    <td>\n      <pre>\nmodule type MySig = {\n  type t = int;\n  let x: int;\n};\nmodule MyModule: MySig = {\n  type t = int;\n  let x = 10;\n};\nmodule MyModule = {\n  module NestedModule = {\n     let msg = "hello";\n  };\n};\n      </pre>\n    </td>\n  </tr>\n</table>\n<h5>Functors Types</h5>\n<p>In the same way that type parameters (think generics) were made consistent with\nfunction application syntax, Reason also unifies the syntax for Functors.</p>\n<p>In Reason, functor parsing rules are almost identical to the function\nparsing rules, using <code>=></code> to represent curried application.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nmodule type FType =\n    functor (A: ASig) ->\n    functor (B:BSig) -> Result\n      </pre>\n    </td>\n    <td>\n      <pre>\nmodule type FType =\n    (A: ASig) =>\n    (B:BSig) => Result;\n      </pre>\n    </td>\n  </tr>\n</table>\n<h3>Functors</h3>\n<p>In Reason, the syntax for creating and applying functors is nearly identical\nto the syntax for creating/applying functions. Also, functor <em>application</em> is\nconsistent with function application (again, space separated lists).</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nmodule F =\n  functor (A:ASig) ->\n  functor (B:BSig) ->\n    struct end</pre>\n    </td>\n    <td>\n      <pre>\nmodule F =\n  fun (A:ASig) =>\n  fun (B:BSig) =>\n    {};</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nmodule F =\n  functor\n    (A:ASig)\n    (B:BSig) -> struct end</pre>\n    </td>\n    <td>\n      <pre>\nmodule F =\n  fun (A:ASig)\n      (B:BSig) => {};</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nmodule F\n       (A:ASig)\n       (B:BSig) =\n         struct end</pre>\n    </td>\n    <td>\n      <pre>\nmodule F\n           (A:ASig)\n           (B:BSig) =>\n             {};</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nmodule Res = F(A)(B)</pre>\n    </td>\n    <td>\n      <pre>\nmodule Res = F A B;</pre>\n    </td>\n  </tr>\n</table>\n<p><strong>Note: There is currently a known inconsistency where functors do not\nconform to function application syntax when in type annotation position - see\n<code>formatTest/modules.re</code>.</strong></p>\n<h3>Various Improvements</h3>\n<p>OCaml doesn\'t require parens around sequences <code>(a;b;c;d)</code> or tuples <code>(x,y)</code>, so\nthat ends up ruling out a bunch of other very convenient syntax rules.  Since\nReason always uses <code>{}</code> to enclose sequences or let bindings, and Reason\nalways requires <code>()</code> around tuples, many other syntax constructs are expressed\nmore intuitively, without requiring extra wrapping in parenthesis.</p>\n<h6>Lambdas as record fields no longer need extra parens</h6>\n<p>This is a welcomed improvement because the OCaml type errors the user would\nsee were very confusing when it would believe the function\'s return value\nwas a tuple with infix <code>,</code> comma.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet myFuncs = {\n  myFun = (fun x -> x + 1);\n  your = (fun a b -> a + b);\n}</pre>\n    </td>\n    <td>\n      <pre>\nlet myFuncs = {\n  myFun: fun x => x + 1,\n  your: fun a b => a + b\n}</pre>\n    </td>\n  </tr>\n</table>\n<h6>Lambdas as match results no longer need extra parens</h6>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet x = match prnt with\n  | None -> fun a -> blah\n  (* Extra () required ! *)\n  | Some "_" -> (fun a -> ())\n  | Some "ml" -> blah\n      </pre>\n    </td>\n    <td>\n      <pre>\nlet x = switch prnt {\n| None => fun a => blah\n| Some "_" => fun a => ()\n| Some "ml" => blah\n};</pre>\n    </td>\n  </tr>\n</table>\n<h6>Lambdas and type annotations in tuples no longer require extra parens</h6>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet tuple =\n  ((fun x -> x), 20)\nlet tuple =\n  (("hi": string), (20: int))\n      </pre>\n    </td>\n    <td>\n      <pre>\nlet tuple =\n  (fun x => x, 20);\nlet tuple =\n  ("hi": string, 20: int);\n      </pre>\n    </td>\n  </tr>\n</table>\n<h3>Various Differences</h3>\n<h5><code>as</code> precedence</h5>\n<p>With Reason, <code>as</code> has a higher precedence than <code>|</code> bar. This allows creating <code>as</code> aliases\nfor entire rows in pattern matching.</p>\n<table>\n  <thead><tr> <th scope="col"><p>OCaml</p></th><th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet ppp = match MyThing 20 with\n  | (MyThing x as ppp)\n  | (YourThing x as ppp) -> ppp;\n      </pre>\n    </td>\n    <td>\n      <pre>\nlet ppp = switch (MyThing 20) {\n| MyThing x as ppp\n| YourThing x as ppp => ppp;\n};\n      </pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet | (MyThing _ as ppp)\n    | (YourThing _ as ppp) = ppp;</pre>\n    </td>\n    <td>\n      <pre>\nlet | MyThing _ as ppp\n    | YourThing _ as ppp = ppp;</pre>\n    </td>\n  </tr>\n</table>\n<h3>Mutable Record Field Updates</h3>\n<p>Because equalities and their negations have been made more consistent in Reason,\nthe <code>=</code> operator is available for mutable field update.</p>\n<table>\n  <thead><tr> <th scope="col"><p >OCaml</p></th> <th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nmyRec.field <- "next"</pre>\n    </td>\n    <td>\n      <pre>\nmyRec.field = "next"</pre>\n    </td>\n  </tr>\n</table>\n<h5>Prefix operators</h5>\n<p>In Reason, <code>!</code> and other prefix operators have lower precedence than dot <code>.</code> or send <code>#</code>.\nThis is more consistent with what other languages do, and is more practical\nwhen (or if) the <code>!</code> symbol is used to represent boolean <code>not</code>.</p>\n<table>\n<thead>\n<tr>\n<th>OCaml</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><pre>\n   let x = !(foo.bar);    \n</pre></td>\n<td><pre>\n    let x = !foo.bar;        \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !(foo#bar);    \n</pre></td>\n<td><pre>\n    let x = !foo#bar;        \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !(!foo.bar);   \n</pre></td>\n<td><pre>\n    let x = !(!foo).bar;     \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !(!foo#bar);   \n</pre></td>\n<td><pre>\n    let x = !(!foo)#bar;     \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !(!(foo.bar)); \n</pre></td>\n<td><pre>\n    let x = !(!foo.bar);     \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !(!(foo#bar)); \n</pre></td>\n<td><pre>\n    let x = !(!foo#bar);     \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !!(foo.bar);   \n</pre></td>\n<td><pre>\n    let x = !!foo.bar;       \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !!(foo#bar);   \n</pre></td>\n<td><pre>\n    let x = !!foo#bar;       \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !~(foo.bar);   \n</pre></td>\n<td><pre>\n    let x = !~foo.bar;       \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n   let x = !~(foo#bar);   \n</pre></td>\n<td><pre>\n    let x = !~foo#bar;       \n</pre></td>\n</tr>\n</tbody>\n</table>\n<h6>Comment Escaping</h6>\n<p>Because Reason uses C-style comments, some obscure custom prefix/infix\noperators must be written differently.  The rules for prefix/infix operators\nare the same as in OCaml syntax, but with the following exceptions:</p>\n<p>Specifically, if any character except the first in an prefix/infix operator is\na star or forward slash, that must be first escaped with a backslash. These will\nbe parsed <em>without</em> the backslash when added to the AST. When reprinted, the\nescape backslashes are added back in automatically.</p>\n<table>\n<thead>\n<tr>\n<th>OCaml</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>\nlet (/*) a b => a + b;       \n</code></td>\n<td><code>\n     let (/\n\\\n*) a b => a + b;         \n</code></td>\n</tr>\n<tr>\n<td><code>\nlet x = 12 /-* 23 /-* 12;  \n</code></td>\n<td><code>\n     let x = 12 /-\n\\\n* 23 /-\n\\\n* 12; \n</code></td>\n</tr>\n<tr>\n<td><code>\nlet y = (/*) a b;            \n</code></td>\n<td><code>\n     let y = (/\n\\\n*) a b;            \n</code></td>\n</tr>\n<tr>\n<td><code>\nlet (!=*) q r => q + r;      \n</code></td>\n<td><code>\n     let (!=\n\\\n*) q r => q + r;      \n</code></td>\n</tr>\n<tr>\n<td><code>\nlet res = q (!=*) r;         \n</code></td>\n<td><code>\n     let res = q (!=\n\\\n*) r;         \n</code></td>\n</tr>\n<tr>\n<td><code>\nlet (!=/*) q r => q + r;     \n</code></td>\n<td><code>\n     let (!=\n/\n\\\n*) q r => q + r;    \n</code></td>\n</tr>\n<tr>\n<td><code>\nlet res = q (!=/*) r;        \n</code></td>\n<td><code>\n     let res = q (!=\n/\n\\\n*) r;       \n</code></td>\n</tr>\n</tbody>\n</table>\n<h6>Operator Renaming</h6>\n<p>If Reason uses <code>==</code> to represent OCaml\'s <code>=</code>, and\nuses <code>===</code> to represent OCaml\'s <code>==</code>, then how would Reason represent OCaml\'s\n<code>===</code> symbol (if it were defined)? Reason provides a way! "Escape" the triple\nequals symbol!</p>\n<table>\n  <thead><tr> <th scope="col"><p>Identifier</p></th><th scope="col"><p>Meaning</p></th> <th scope="col"><p>Expressed in OCaml via</p></th> <th scope="col"><p>Expressed in Reason via</p></th></tr></thead>\n  <tr>\n  <tr>\n    <td>\n      <pre>\n"==="</pre>\n    </td>\n    <td>\n      <pre>\nCustom value</pre>\n    </td>\n    <td>\n      <pre>\nx === y</pre>\n    </td>\n    <td>\n      <pre>\nx \\=== y</pre>\n    </td>\n  </tr>\n</table>'
}}},{node:{relativePath:"guide/native/index.md",childMarkdownRemark:{frontmatter:{title:"Native",order:5},html:'<p>We currently use the default OCaml workflow to compile to native, although <a href="https://github.com/bsansouci/bsb-native">there\'s work underway</a> to bring native compilation support to the BuckleScript builder.</p>\n<blockquote>\n<p><strong>Note</strong>: some parts of the native workflow likely don\'t work on Windows. The native workflow is currently <strong>work in progress</strong>, as we\'re currently focusing on polishing the JS workflow. Contribution welcome!</p>\n</blockquote>\n<p>Reason integrates well into existing toolchains such as <code>ocamlbuild</code>, and ships\nwith a binary called <code>rebuild</code>, a thin wrapper around <a href="https://ocaml.org/learn/tutorials/ocamlbuild/"><code>ocamlbuild</code></a>\nthat ensures the right flags to be passed to the compiler for any files ending\nin <code>.re</code>.</p>\n<p>For native compilation, we use <a href="https://opam.ocaml.org">OPAM</a>.</p>'}}},{node:{relativePath:"guide/native/convert-from-ocaml.md",childMarkdownRemark:{frontmatter:{title:"Converting from OCaml",order:4},html:'<p>Since Reason is just another syntax for OCaml, converting an OCaml project over is straightforward and doesn\'t require semantic changes. However, there are a few build setup and miscellaneous changes required.</p>\n<h4>OCamlBuild -> Rebuild</h4>\n<p>Reason comes with a drop in replacement for <code>ocamlbuild</code> called <code>rebuild</code>, that\nwill automatically build any Reason file along with your OCaml files, with\nno additional configuration. This allows you to add Reason files to your existing\nOCaml project bit by bit. Wherever your script refers to <code>ocamlbuild</code>, just replace\nit with <code>rebuild</code>.</p>\n<h4>Makefile</h4>\n<p>If your build system executes explicit build commands, then the easiest way to\nuse Reason with <code>ocamlopt/ocamlc</code> is by adding the following flags to each\ncompilation step:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-sh"><code><span class="hljs-comment"># intf-suffix tells the compiler where to look for corresponding interface files</span>\nocamlopt -pp refmt -intf-suffix rei -impl myFile.re\nocamlopt -pp refmt -intf myFile.rei</code></pre>\n      </div>\n<p>If you are using <code>ocamlbuild</code> without <code>rebuild</code>, add the following to your\n<code>_tags</code> file, but this likely won\'t be enough because <code>ocamlc</code>/<code>ocamlopt</code> will\nneed the <code>-intf/-impl/-intf-suffix</code> flags:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-none"><code>&lt;**/*.{re,.rei}&gt;: package(reason), syntax(utf8)</code></pre>\n      </div>\n<h4>Constructor Syntax Fix</h4>\n<p>The converted Reason code may attach <code>[@implicit_arity]</code> to variant constructors, like so: <code>C 1 2 [@implicit_arity]</code>.\nThis is due to the fact that OCaml has the ambiguous syntax where a multi-arguments\nconstructor is expecting argument in a tuple form. So at parsing time we don\'t\nknow if <code>C (1, 2)</code> in OCaml should be translated to <code>C (1, 2)</code> or <code>C 1 2</code> in Reason.\nBy default, we will convert it to <code>C 1 2 [@implicit_arity]</code>, which tells the compiler\nthis can be either <code>C 1 2</code> or <code>C (1, 2)</code>.</p>\n<p>To prevent <code>[@implicit_arity]</code> from being generated, one can supply <code>--assume-explicit-arity</code>\nto <code>refmt</code>. This forces the formatter to generate <code>C 1 2</code> instead of <code>C 1 2 [@implicit_arity]</code>.</p>\n<p>However, since <code>C 1 2</code> requires multiple arguments, it may fail the compilation if it is actually\na constructor with a single tuple as an argument (e.g., <code>Some</code>).\nWe already have some internal exception rules to cover the common constructors who requires a single tuple\nas argument so that they will be converted correctly (e.g., <code>Some (1, 2)</code> will be converted\nto <code>Some (1, 2)</code> instead of <code>Some 1 2</code>, which doesn\'t compile).</p>\n<p>To provide your own exception list, create a line-separated file that contains all constructors (without module prefix)\nin your project that expects a single tuple as argument, and use <code>--heuristics-file &#x3C;filename></code>\nto tell <code>refmt</code> that all constructors\nlisted in the file will be treated as constructor with a single tuple as argument:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-sh"><code>&gt; cat heuristics.txt\n  TupleConstructor\n  And\n  Or</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-sh"><code>&gt; cat test.ml</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code><span class="hljs-keyword">type</span> tm =\n  <span class="hljs-type">TupleConstructor</span> <span class="hljs-keyword">of</span> (<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span>)\n| <span class="hljs-type">MultiArgumentsConstructor</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span>\n<span class="hljs-keyword">let</span> x = <span class="hljs-type">TupleConstructor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)\n<span class="hljs-keyword">let</span> y = <span class="hljs-type">MultiArgumentsConstructor</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)\n<span class="hljs-keyword">module</span> <span class="hljs-type">Test</span> = <span class="hljs-keyword">struct</span>\n  <span class="hljs-keyword">type</span> a = | <span class="hljs-type">And</span> <span class="hljs-keyword">of</span> (<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span>) | <span class="hljs-type">Or</span> <span class="hljs-keyword">of</span> (<span class="hljs-built_in">int</span> * <span class="hljs-built_in">int</span>)\n<span class="hljs-keyword">end</span>;;\n<span class="hljs-keyword">let</span> a = <span class="hljs-type">Test</span>.<span class="hljs-type">And</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)\n<span class="hljs-keyword">let</span> b = <span class="hljs-type">Test</span>.<span class="hljs-type">Or</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)\n<span class="hljs-keyword">let</span> c = <span class="hljs-type">Some</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)</code></pre>\n      </div>\n<p>Then only the constructor identifiers that were listed will be assumed to accept tuples instead of multiple arguments.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-sh"><code>&gt; refmt --heuristics-file \\\n    ./heuristics.txt --assume-explicit-arity \\\n    --parse ml --print re test.ml</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code>  <span class="hljs-keyword">type</span> tm =\n    | <span class="hljs-type">TupleConstructor</span> <span class="hljs-keyword">of</span> (int, int)\n    | <span class="hljs-type">MultiArgumentsConstructor</span> <span class="hljs-keyword">of</span> int int;\n\n<span class="hljs-keyword">let</span> x = <span class="hljs-type">TupleConstructor</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);\n<span class="hljs-keyword">let</span> y = <span class="hljs-type">MultiArgumentsConstructor</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>;\n<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Test</span> = </span>{\n  <span class="hljs-keyword">type</span> a = | <span class="hljs-type">And</span> <span class="hljs-keyword">of</span> (int, int) | <span class="hljs-type">Or</span> <span class="hljs-keyword">of</span> (int, int);\n};\n<span class="hljs-keyword">let</span> a = <span class="hljs-type">Test</span>.<span class="hljs-type">And</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);\n<span class="hljs-keyword">let</span> b = <span class="hljs-type">Test</span>.<span class="hljs-type">Or</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);\n<span class="hljs-keyword">let</span> <span class="hljs-built_in">c</span> = <span class="hljs-type">Some</span> (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);</code></pre>\n      </div>'}}},{node:{relativePath:"guide/native/quickstart.md",childMarkdownRemark:{frontmatter:{title:"Quickstart",order:0},html:'<div class="gatsby-highlight">\n      <pre class="hljs lang-sh"><code><span class="hljs-comment"># On OSX, install opam via Homebrew:</span>\nbrew update\nbrew install opam\n<span class="hljs-comment"># On Linux, see here (you\'ll need opam &gt;= 1.2.2): http://opam.ocaml.org/doc/Install.html</span>\nopam init\n<span class="hljs-comment"># **Note**: add the line below to your ~/.bashrc or ~/.zshrc too; it\'s needed at every shell startup</span>\n<span class="hljs-built_in">eval</span> $(opam config env)\nopam update\nopam switch <span class="hljs-number">4.02</span>.<span class="hljs-number">3</span></code></pre>\n      </div>\n<p>Then clone our example <a href="https://github.com/reasonml/ReasonNativeProject"><code>ReasonNativeProject</code></a> repo, and you\'re good to go!</p>'}}},{node:{relativePath:"guide/language/data-types.md",childMarkdownRemark:{frontmatter:{title:"Built-in Data Types",order:2},html:'<h3>Tuple</h3>\n<p>Tuples are</p>\n<ul>\n<li>immutable</li>\n<li>ordered</li>\n<li>fixed-sized</li>\n<li>heterogeneous</li>\n</ul>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> myThreeFloats = (<span class="hljs-number">20.0</span>, <span class="hljs-number">30.0</span>, <span class="hljs-number">100.0</span>);\n<span class="hljs-keyword">let</span> myIntAndString = (<span class="hljs-number">20</span>, <span class="hljs-string">"totallyNotAnInteger"</span>);</code></pre>\n      </div>\n<p>Tuples\' types can be used in type annotations as well. Tuple types visually resemble tuples values.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> myThreeFloats: (float, float, float) = (<span class="hljs-number">20.0</span>, <span class="hljs-number">30.0</span>, <span class="hljs-number">100.0</span>);\n<span class="hljs-comment">/* a tuple type alias */</span>\n<span class="hljs-keyword">type</span> myPair = (int, string);\n<span class="hljs-keyword">let</span> myIntAndString: myPair = (<span class="hljs-number">20</span>, <span class="hljs-string">"totallyNotAnInteger"</span>);</code></pre>\n      </div>\n<p><strong>Note</strong>: there\'s no tuple of size 1.</p>\n<h3>Record</h3>\n<p>Records are a set of named values. They resemble "objects" but are</p>\n<ul>\n<li>lighter</li>\n<li>immutable by default</li>\n<li>less flexible</li>\n<li>much faster</li>\n</ul>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> person = {age: int, name: string}; <span class="hljs-comment">/* type */</span>\n<span class="hljs-keyword">let</span> me = {age: <span class="hljs-number">30</span>, name: <span class="hljs-string">"Jordan"</span>}; <span class="hljs-comment">/* value */</span>\nprint_string me.name; <span class="hljs-comment">/* field access */</span></code></pre>\n      </div>\n<p><strong>Note</strong>: Records must have a type definition.</p>\n<p>New records can be created from old records with the <code>...</code> spread operator. The\noriginal record isn\'t mutated.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> meNextYear = {...me, age: me.age + <span class="hljs-number">1</span>};</code></pre>\n      </div>\n<p><strong>Note</strong>: spread cannot add new fields.</p>\n<h5>Sugar</h5>\n<p>To reduce redundancy, we provide <strong>punning</strong> for a record\'s types and values. You can use it when the name of a record field matches the name of its value/type.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> horsePower = {power: int, metric: bool};\n\n<span class="hljs-keyword">let</span> metric = <span class="hljs-literal">true</span>;\n<span class="hljs-keyword">let</span> horsePower1 = {power: <span class="hljs-number">10</span>, metric};\n<span class="hljs-comment">/* same as the value {power: 10, metric: metric}; */</span>\n\n<span class="hljs-keyword">type</span> car = {name: string, horsePower};\n<span class="hljs-comment">/* same as the type {name: string, horsePower: horsePower}; */</span></code></pre>\n      </div>\n<p><strong>Note</strong>: there\'s no punning for a single record field! <code>{foo}</code> doesn\'t do what you expect (it\'s a block that returns the value <code>foo</code>).</p>\n<h5>Mutable Fields</h5>\n<p>Record fields can optionally be mutable. This allows you to update those fields in-place with the <code>=</code> operator.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> person = {\n  name: string,\n  <span class="hljs-keyword">mutable</span> age: int\n};\n<span class="hljs-keyword">let</span> me = {name: <span class="hljs-string">"Jordan"</span>, age: <span class="hljs-number">30</span>};\nme.age = me.age + <span class="hljs-number">1</span>; <span class="hljs-comment">/* alter `me`. Happy birthday! */</span></code></pre>\n      </div>\n<h3>Variant</h3>\n<p>Most data structures are about "this <strong>and</strong> that". A variant allows us to express "this <strong>or</strong> that".</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> response =\n| <span class="hljs-type">Yes</span>\n| <span class="hljs-type">No</span>\n| <span class="hljs-type">PrettyMuch</span>;\n\n<span class="hljs-keyword">let</span> areYouCrushingIt = <span class="hljs-type">Yes</span>;</code></pre>\n      </div>\n<p><code>Yes</code>, <code>No</code> and <code>PrettyMuch</code> aren\'t strings, nor references, nor some special data type. They\'re called "constructors" (or "tag"). The <code>|</code> bar separates each constructor.</p>\n<p><strong>Note</strong>: variant constructors need to be capitalized.</p>\n<p>A <code>switch</code> expression is like a large <code>if/elseif/elseif..</code> that allows you to check every possible case of a variant. To use it, enumerate every variant constructor, each followed by an <code>=></code> and the expression corresponding to that case.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> message = <span class="hljs-keyword">switch</span> (areYouCrushingIt) {\n| <span class="hljs-type">No</span> =&gt; <span class="hljs-string">"No worries. Keep going!"</span>\n| <span class="hljs-type">Yes</span> =&gt; <span class="hljs-string">"Great!"</span>\n| <span class="hljs-type">PrettyMuch</span> =&gt; <span class="hljs-string">"Nice!"</span>\n};\n<span class="hljs-comment">/* message is "Great!" */</span></code></pre>\n      </div>\n<p>The compiler will raise a type error if you\'ve forgotten to cover a case of your\nvariant, or if two cases are redundant!</p>\n<h5>Constructor Arguments</h5>\n<p>Constructors can carry extra data in a space-separated list.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> account =\n| <span class="hljs-type">None</span>\n| <span class="hljs-type">Instagram</span> string\n| <span class="hljs-type">Facebook</span> string int;</code></pre>\n      </div>\n<p>Here, <code>Instagram</code> carries a <code>string</code> and <code>Facebook</code> carries a <code>string</code> and an <code>int</code>. Usage:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> myAccount = <span class="hljs-type">Facebook</span> <span class="hljs-string">"Josh"</span> <span class="hljs-number">26</span>;\n<span class="hljs-keyword">let</span> friendAccount = <span class="hljs-type">Instagram</span> <span class="hljs-string">"Jenny"</span>;</code></pre>\n      </div>\n<p><strong>Note</strong> how using a constructor is like calling a function! It\'s as if <code>Facebook</code> was a function that accepts two arguments. This isn\'t a coincidence; there\'s a reason why a constructor\'s data is called "argument".</p>\n<p><strong>Note</strong>: be careful not to confuse a constructor carrying 2 arguments with a constructor carrying a single tuple argument:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> account =\n| <span class="hljs-type">Facebook</span> string int <span class="hljs-comment">/* 2 arguments */</span>\n<span class="hljs-keyword">type</span> account2 =\n| <span class="hljs-type">Instagram</span> (string, int) <span class="hljs-comment">/* 1 argument - happens to be a 2-tuple */</span></code></pre>\n      </div>\n<h5>Using Switch with Constructors Arguments</h5>\n<p>The <code>switch</code> expression can also let you "open up" a variant and bind its arguments to names you can refer to.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> account =\n| <span class="hljs-type">None</span>\n| <span class="hljs-type">Instagram</span> string;\n| <span class="hljs-type">Facebook</span> string int\n<span class="hljs-keyword">let</span> myAccount = <span class="hljs-type">Facebook</span> <span class="hljs-string">"Josh"</span> <span class="hljs-number">26</span>;\n...\n<span class="hljs-keyword">let</span> greeting = <span class="hljs-keyword">switch</span> (myAccount) {\n| <span class="hljs-type">None</span> =&gt; <span class="hljs-string">"Hi!"</span>\n| <span class="hljs-type">Facebook</span> name age =&gt;\n  <span class="hljs-string">"Hi "</span> ^ name ^ <span class="hljs-string">", you\'re "</span> ^ (string_of_int age) ^ <span class="hljs-string">"-year-old."</span>\n| <span class="hljs-type">Instagram</span> name =&gt; <span class="hljs-string">"Hello "</span> ^ name ^ <span class="hljs-string">"!"</span>\n}</code></pre>\n      </div>\n<p>This is called pattern-matching. It\'s a stronger version of destructuring, often found in other languages.</p>\n<h3>(Linked) List</h3>\n<p>Lists are homogeneous, immutable, and support fast <code>O(1)</code> append at the head of the list.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> myList = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];\n<span class="hljs-keyword">let</span> anotherList = [<span class="hljs-number">0</span>, ...myList]; <span class="hljs-comment">/* myList didn\'t mutate */</span></code></pre>\n      </div>\n<p>Under the hood, a list is just a normal variant with a neat syntax. To illustrate this, here\'s how you would declare your own int list type, without the nice syntax:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> myListType = <span class="hljs-type">Empty</span> | <span class="hljs-type">NonEmpty</span> int myListType;\n<span class="hljs-keyword">let</span> myList = <span class="hljs-type">NonEmpty</span> <span class="hljs-number">1</span> (<span class="hljs-type">NonEmpty</span> <span class="hljs-number">2</span> (<span class="hljs-type">NonEmpty</span> <span class="hljs-number">3</span> <span class="hljs-type">Empty</span>));\n<span class="hljs-comment">/* basically [1, 2, 3] */</span></code></pre>\n      </div>\n<h3>Array</h3>\n<p>Arrays are like lists, except they are mutable and support fast random access for performance-sensitive scenarios.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> myArray = [|<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>, <span class="hljs-string">"how are you"</span>|];\n<span class="hljs-keyword">let</span> world = myArray.(<span class="hljs-number">1</span>);\n<span class="hljs-type">Array</span>.<span class="hljs-keyword">set</span> myArray <span class="hljs-number">0</span> <span class="hljs-string">"hey"</span>;\n<span class="hljs-comment">/* now [|"hey", "world", "how are you"|] */</span></code></pre>\n      </div>'}}},{node:{relativePath:"guide/language/conditionals.md",childMarkdownRemark:{frontmatter:{title:"Conditionals",order:4},html:'<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">if</span> (showMenu) {\n  displayMenu ();\n};</code></pre>\n      </div>\n<p>Reason <code>if</code>s are expressions; they\'re evaluated to their body\'s content:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> message = <span class="hljs-keyword">if</span> (isMorning) {\n  <span class="hljs-string">"Good morning!"</span>\n} <span class="hljs-keyword">else</span> {\n  <span class="hljs-string">"Hello!"</span>\n};</code></pre>\n      </div>\n<p>We also have ternary sugar.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> message = isMorning ? <span class="hljs-string">"Good morning!"</span> : <span class="hljs-string">"Hello!"</span>;</code></pre>\n      </div>'}}},{node:{relativePath:"guide/language/destructuring.md",childMarkdownRemark:{frontmatter:{title:"Destructuring & Pattern Matching",order:5},html:'<p>"Destructuring" is a visually concise way of extracting fields from a data structure while binding them to variables. You can use destructuring anywhere you\'d normally use a variable. To destructure, instead\nof writing the variable name as usual, write out the shape of the object.</p>\n<p>The following binds variables: <code>ten = 10</code>, <code>twenty = 20</code></p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> someInts = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>);\n<span class="hljs-keyword">let</span> (ten, twenty) = someInts;</code></pre>\n      </div>\n<p>The following binds variables: <code>n = "Guy"</code>, <code>a = 30</code></p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> person = {name: string, age: int};\n<span class="hljs-keyword">let</span> somePerson = {name: <span class="hljs-string">"Guy"</span>, age: <span class="hljs-number">30</span>};\n<span class="hljs-keyword">let</span> {name: n, age: a} = somePerson;</code></pre>\n      </div>\n<p>Destructuring also allows type annotations.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> (ten: int, twenty: int) = someInts;\n<span class="hljs-keyword">let</span> {name: (n:string), age: (a:int)} = somePerson;</code></pre>\n      </div>\n<p>Destructuring labeled arguments is also possible.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> person = {name: string, age: int};\n\n<span class="hljs-keyword">let</span> someFunction person::{name} =&gt; {\n  <span class="hljs-comment">/* you can use `name` here */</span>\n}\n\n<span class="hljs-keyword">let</span> otherFunction person::({name} <span class="hljs-keyword">as</span> thePerson) =&gt; {\n  <span class="hljs-comment">/* you can use both `name` and the whole record as `thePerson` here */</span>\n}</code></pre>\n      </div>\n<p>A more advanced form of destructuring is called <strong>pattern matching</strong>. The latter looks like destructuring, but comes with even more help from the type system. Consider a variant:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> payload =\n| <span class="hljs-type">BadResult</span> int\n| <span class="hljs-type">GoodResult</span> string\n| <span class="hljs-type">NoResult</span>;</code></pre>\n      </div>\n<p>While using the <code>switch</code> expression on it, you can "destructure" it:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> data = <span class="hljs-type">GoodResult</span> <span class="hljs-string">"Product shipped!"</span>;\n\n<span class="hljs-keyword">let</span> message =\n  <span class="hljs-keyword">switch</span> data {\n  | <span class="hljs-type">GoodResult</span> theMessage =&gt; <span class="hljs-string">"Success! "</span> ^ theMessage\n  | <span class="hljs-type">BadResult</span> errorCode =&gt;\n    <span class="hljs-string">"Something\'s wrong. The error code is: "</span> ^ (string_of_int errorCode)\n  };</code></pre>\n      </div>\n<p>Notice how we\'ve destructured <code>data</code> while handling each different case. The above <code>switch</code> will give you a compiler warning:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-none"><code><span class="hljs-type">Warning</span> <span class="hljs-number">8</span>: this pattern-matching <span class="hljs-keyword">is</span> not exhaustive.\n<span class="hljs-type">Here</span> <span class="hljs-keyword">is</span> an example <span class="hljs-keyword">of</span> a value that <span class="hljs-keyword">is</span> not matched:\n<span class="hljs-type">NoResult</span></code></pre>\n      </div>\n<p>Isn\'t that great? While matching on the shape of your data, the type system warned of an unhandled case. This <strong>conditional</strong> aspect is the essence of pattern matching. Most data structures with a "if this then that" aspect works with it:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">switch</span> myList {\n| [] =&gt; print_endline <span class="hljs-string">"Empty list"</span>\n| [a, ...theRest] =&gt;\n  print_endline (<span class="hljs-string">"list with the head value "</span> ^ a)\n};\n\n<span class="hljs-keyword">switch</span> myArray {\n| [|<span class="hljs-number">1</span>, <span class="hljs-number">2</span>|] =&gt; print_endline <span class="hljs-string">"This is an array with item 1 and 2"</span>\n| <span class="hljs-number">_</span> =&gt; print_endline <span class="hljs-string">"This is an array"</span>\n}</code></pre>\n      </div>\n<p>You can even switch on string, int and others. You can even have many patterns going to the same result!</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> reply =\n  <span class="hljs-keyword">switch</span> message {\n  | <span class="hljs-string">"Reason\'s pretty cool"</span> =&gt; <span class="hljs-string">"Yep"</span>\n  | <span class="hljs-string">"good night"</span> =&gt; <span class="hljs-string">"See ya!"</span>\n  | <span class="hljs-string">"hello"</span>\n  | <span class="hljs-string">"hi"</span>\n  | <span class="hljs-string">"heya"</span>\n  | <span class="hljs-string">"hey"</span> =&gt; <span class="hljs-string">"hello to you too!"</span>\n  | <span class="hljs-number">_</span> =&gt; <span class="hljs-string">"Nice to meet you!"</span>\n  };</code></pre>\n      </div>\n<p>Combined with other data structures, pattern matching can produce extremely concise, compiler-verified, performant code:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> message =\n  <span class="hljs-keyword">switch</span> data {\n  | <span class="hljs-type">GoodResult</span> theMessage =&gt; <span class="hljs-string">"Success! "</span> ^ theMessage\n  | <span class="hljs-type">BadResult</span> (<span class="hljs-number">0</span> | <span class="hljs-number">1</span> | <span class="hljs-number">5</span>) =&gt; <span class="hljs-string">"Something\'s wrong. It\'s a server side problem."</span>\n  | <span class="hljs-type">BadResult</span> errorCode =&gt; <span class="hljs-string">"Unknown error occurred. Code: "</span> ^ string_of_int errorCode\n  | <span class="hljs-type">NoResult</span> =&gt; <span class="hljs-string">"Things look fine"</span>\n  };</code></pre>\n      </div>\n<p>When you really need to use arbitrary logic with an otherwise clean pattern match, you can slip in some <code>when</code> clauses, which are basically <code>if</code> sugar:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> message =\n  <span class="hljs-keyword">switch</span> data {\n  | <span class="hljs-type">GoodResult</span> theMessage =&gt; ...\n  | <span class="hljs-type">BadResult</span> errorCode when isServerError errorCode =&gt; ...\n  | <span class="hljs-type">BadResult</span> errorCode =&gt; ... <span class="hljs-comment">/* otherwise */</span>\n  | <span class="hljs-type">NoResult</span> =&gt; ...\n  };</code></pre>\n      </div>'}}},{node:{relativePath:"guide/language/externals.md",childMarkdownRemark:{frontmatter:{title:"Externals",order:11},html:'<p><code>external</code>, or "FFI" (foreign function interface), or simply "interop" is how Reason/OCaml communicates with other languages, like C or JavaScript. It\'s like mandatorily typing a let-binding.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code>external myCFunction: int -&gt; string = <span class="hljs-string">"theCFunction"</span>;</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code>external getElementsByClassName : string =&gt; array <span class="hljs-type">Dom</span>.element =\n  <span class="hljs-string">"document.getElementsByClassName"</span> [@@bs.<span class="hljs-keyword">val</span>];</code></pre>\n      </div>\n<p>You\'d often see <code>external</code>s when working with BuckleScript, since we\'re interoping with existing JavaScript libraries a lot. More info on BS externals <a href="http://bucklescript.github.io/bucklescript/Manual.html#_binding_to_simple_js_functions_values">here</a>.</p>'}}},{node:{relativePath:"guide/language/functions.md",childMarkdownRemark:{frontmatter:{title:"Functions",order:3},html:'<p>Functions are declared with <code>fun</code> and return the expression.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> greet = <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> name<span class="hljs-params"> </span></span></span>=&gt; <span class="hljs-string">"Hello "</span> ^ name;</code></pre>\n      </div>\n<p>This declares a function and assigns to it the name <code>greet</code>, which you can call like so:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code>greet <span class="hljs-string">"world!"</span>; <span class="hljs-comment">/* "Hello world!" */</span></code></pre>\n      </div>\n<p>Multi-arguments functions have arguments separated by space:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> add = <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> x<span class="hljs-params"> y<span class="hljs-params"> z<span class="hljs-params"> </span></span></span></span></span>=&gt; x + y + z;\nadd <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>; <span class="hljs-comment">/* 6 */</span></code></pre>\n      </div>\n<p>For longer functions, you\'d surround the body with a block:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> greetMore = <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> name<span class="hljs-params"> </span></span></span>=&gt; {\n  <span class="hljs-keyword">let</span> part1 = <span class="hljs-string">"Hello"</span>;\n  part1 ^ <span class="hljs-string">" "</span> ^ name\n};</code></pre>\n      </div>\n<p><strong>Since function definitions occur often</strong>, we gave <code>let + fun</code> a shorthand:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> add x y z =&gt; x + y + z;\n<span class="hljs-comment">/* same as: let add = fun x y z =&gt; x + y + z; */</span></code></pre>\n      </div>\n<p><strong>Be mindful of function\'s precedence</strong>! You need to wrap the call with parentheses in some situations:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> increment x =&gt; x + <span class="hljs-number">1</span>;\n<span class="hljs-keyword">let</span> double x =&gt; x + x;\n\n<span class="hljs-keyword">let</span> eleven = increment (double <span class="hljs-number">5</span>);</code></pre>\n      </div>\n<p>If you forget to wrap <code>double 5</code> in parentheses, you\'d get <code>increment double 5</code>, as if the <code>increment</code> function wrongly takes two arguments.</p>\n<h4>No Argument</h4>\n<p>A function always takes an argument; but sometimes, we\'d use it for e.g. side-effects, and don\'t have anything to pass to it. In other languages, we\'d conceptually pass "no argument". In Reason, every function takes an argument; here we\'d conventionally pass it the value <code>()</code>, called "unit".</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* receive &amp; destructure the unit argument */</span>\n<span class="hljs-keyword">let</span> logSomething () =&gt; {\n  print_endline <span class="hljs-string">"hello"</span>;\n  print_endline <span class="hljs-string">"world"</span>;\n};\n\n<span class="hljs-comment">/* call the function with the value of type unit */</span>\nlogSomething ();</code></pre>\n      </div>\n<p><code>()</code> is a totally normal value, the single possible value in <code>unit</code>. Reason/OCaml gave it a special syntax out of convenience.</p>\n<h4>Labeled Arguments</h4>\n<p>Multi-arguments functions, especially those whose arguments are of the same type, can be confusing to call.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> addCoordinates x y =&gt; {\n  <span class="hljs-comment">/* use x and y here */</span>\n};\n...\naddCoordinates <span class="hljs-number">5</span> <span class="hljs-number">6</span>; <span class="hljs-comment">/* which is x, which is y? */</span></code></pre>\n      </div>\n<p>In OCaml/Reason, you can attach labels to an argument:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> addCoordinates x::x y::y =&gt; {\n  <span class="hljs-comment">/* use x and y here */</span>\n};\n...\naddCoordinates x::<span class="hljs-number">5</span> y::<span class="hljs-number">6</span>;</code></pre>\n      </div>\n<p>Since we have currying (more on that <a href="#diving-deeper-more-on-function">here</a>), we can provide the arguments in any order:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code>addCoordinates y::<span class="hljs-number">6</span> x::<span class="hljs-number">5</span>;</code></pre>\n      </div>\n<p>The <code>x::x</code> part during declaration means the function accepts an argument labeled <code>x</code> and can refer to it in the function body as the variable <code>x</code>. This is so that we can have the following pattern, where labeled arguments are renamed inside the function for conciseness:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> drawCircle radius::r color::<span class="hljs-built_in">c</span> =&gt; {\n  setColor <span class="hljs-built_in">c</span>;\n  startAt r r;\n  ...\n};\n\ndrawCircle radius::<span class="hljs-number">10</span> color::<span class="hljs-string">"red"</span>;</code></pre>\n      </div>\n<p>For the common case of <code>radius::radius</code> (where the label is the same as the local variable name), we have the syntax shorthand <code>::x</code>:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> drawCircle ::radius ::color =&gt; {\n  setColor color;\n  startAt radius radius;\n  ...\n}</code></pre>\n      </div>\n<p>Here\'s the syntax for typing the arguments:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> drawCircle radius::(r: int) color::(<span class="hljs-built_in">c</span>: string) =&gt; ...;</code></pre>\n      </div>\n<h4>Optional Labeled Arguments</h4>\n<p>Labeled function arguments can be made optional during declaration. You can then omit them when calling the function.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* radius can be omitted */</span>\n<span class="hljs-keyword">let</span> drawCircle ::color ::radius=? () =&gt; {\n  setColor color;\n  <span class="hljs-keyword">switch</span> radius {\n  | <span class="hljs-type">None</span> =&gt; startAt <span class="hljs-number">1</span> <span class="hljs-number">1</span>;\n  | <span class="hljs-type">Some</span> r_ =&gt; startAt r_ r_;\n  }\n};</code></pre>\n      </div>\n<p>If omitted, <code>radius</code> is <strong>wrapped</strong> in the standard library\'s <code>option</code> type, defaulting to <code>None</code>. If provided, it\'ll be wrapped with a <code>Some</code>. So <code>radius</code>\'s type value is either <code>None</code> or <code>Some int</code> here.</p>\n<p><strong>Note</strong>: <code>None | Some foo</code> is a data structure type called variant, described <a href="./#built-in-data-types-variant">below</a>. This particular variant type is provided by the standard library. It\'s called <code>option</code>. Its definition: <code>type option \'a = None | Some \'a</code>.</p>\n<p><strong>Note</strong> the unit <code>()</code> at the end of <code>drawCircle</code>. Without it, since <code>radius</code> and <code>color</code> are both labeled, can be curried, and can be applied out-of-order, it\'s unclear what the following mean:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> whatIsThis = drawCircle ::color;</code></pre>\n      </div>\n<p>Is <code>whatIsThis</code> a curried <code>drawCircle</code> function, waiting for the optional <code>radius</code> to be applied? Or did it finish applying? To address this confusion, append a positional (aka non-labeled) argument to <code>drawCircle</code> (conventionally <code>()</code>), and OCaml will, as a rule of thumb, presume the optional labeled argument is omitted when the positional argument is provided.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> curriedFunction = drawCircle ::color;\n<span class="hljs-keyword">let</span> actualResultWithoutProvidingRadius = drawCircle ::color ();</code></pre>\n      </div>\n<h5>Explicitly Passed Optional</h5>\n<p>Sometimes, you might want to forward a value to a function without knowing whether the value is <code>None</code> or <code>Some a</code>. Naively, you\'d do:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> result = <span class="hljs-keyword">switch</span> payloadRadius {\n| <span class="hljs-type">None</span> =&gt; drawCircle ::color ()\n| <span class="hljs-type">Some</span> r =&gt; drawCircle ::color radius::r ()\n};</code></pre>\n      </div>\n<p>This quickly gets tedious. We provide a shortcut:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> result = drawCircle ::color radius::?payloadRadius ();</code></pre>\n      </div>\n<p>This means "I understand <code>radius</code> is optional, and that when I pass it a value it needs to be an <code>int</code>, but I don\'t know whether the value I\'m passing is <code>None</code> or <code>Some val</code>, so I\'ll pass you the whole <code>option</code> wrapper".</p>\n<h5>Optional with Default Value</h5>\n<p>Optional labeled arguments can also be provided a default value. They aren\'t wrapped in an <code>option</code> type.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> drawCircle ::radius=<span class="hljs-number">1</span> ::color () =&gt; {\n  setColor color;\n  startAt r r;\n};</code></pre>\n      </div>'
}}},{node:{relativePath:"guide/language/imperative-loops.md",childMarkdownRemark:{frontmatter:{title:"Imperative Loops",order:9},html:'<h4>For Loops</h4>\n<p>For loops iterate from a starting value up to (and including) the ending value.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">for</span> myBinding <span class="hljs-keyword">in</span> (startValue) <span class="hljs-keyword">to</span> (endValue) {\n  <span class="hljs-comment">/* use myBinding here */</span>\n};</code></pre>\n      </div>\n<p>The parenthesis around <code>startValue</code> and <code>endValue</code> may be omitted if they are\nunnecessary.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> xStart = <span class="hljs-number">1</span>;\n<span class="hljs-keyword">let</span> xEnd = <span class="hljs-number">3</span>;\n<span class="hljs-comment">/* prints: 1 2 3 */</span>\n<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> xStart <span class="hljs-keyword">to</span> xEnd {\n  print_int x;\n  print_string <span class="hljs-string">" "</span>;\n};</code></pre>\n      </div>\n<p>You can make the <code>for</code> loop count in the opposite direction by using <code>downto</code>.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">for</span> myBinding <span class="hljs-keyword">in</span> (startValue) <span class="hljs-keyword">downto</span> (endValue) {\n  statements\n};</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> xStart = <span class="hljs-number">3</span>;\n<span class="hljs-keyword">let</span> xEnd = <span class="hljs-number">1</span>;\n<span class="hljs-comment">/* prints: 3 2 1 */</span>\n<span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> xStart <span class="hljs-keyword">downto</span> xEnd {\n  print_int x;\n  print_string <span class="hljs-string">" "</span>;\n};</code></pre>\n      </div>\n<h4>While Loops</h4>\n<p>While loops execute a code block while some condition is true. The form of a <code>while</code> loop includes a single expression, the condition to test.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">while</span> (<span class="hljs-forDocGrammarHighlighting">testCondition</span>) {\n  statements;\n};</code></pre>\n      </div>\n<p>The parenthesis around <code>testCondition</code> may be omitted if they are unnecessary.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">while</span> <span class="hljs-literal">true</span> {\n  print_endline <span class="hljs-string">"hello"</span>;\n};</code></pre>\n      </div>\n<h4>Breaking Out of Loop</h4>\n<p>There\'s no loop-breaking <code>break</code> keyword (nor early <code>return</code> from functions, for that matter) in Reason/OCaml. In general, prefer map/filter/reduce over imperative loops. However, we can break out of a while loop easily through using a <a href="#diving-deeper-mutation">mutable binding</a>. Example without the <code>ref</code> syntax sugar:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-type">Random</span>.self_init ();\n<span class="hljs-keyword">let</span> <span class="hljs-keyword">break</span> = {contents: <span class="hljs-literal">false</span>};\n<span class="hljs-keyword">while</span> (not <span class="hljs-keyword">break</span>.contents) {\n  <span class="hljs-keyword">if</span> (<span class="hljs-type">Random</span>.int <span class="hljs-number">10</span> === <span class="hljs-number">3</span>) {\n    <span class="hljs-keyword">break</span>.contents = <span class="hljs-literal">true</span>\n  } <span class="hljs-keyword">else</span> {\n    print_endline <span class="hljs-string">"hello"</span>\n  }\n};</code></pre>\n      </div>'}}},{node:{relativePath:"guide/language/index.md",childMarkdownRemark:{frontmatter:{title:"Language basics",order:1},html:'<h1>What Is Reason</h1>\n<p>Reason is an umbrella project that provides a curated layer for <a href="http://ocaml.org">OCaml</a>. It offers:</p>\n<ul>\n<li>A new, familiar syntax for the battle-tested language that is OCaml.</li>\n<li>A workflow for compiling to JavaScript and native code.</li>\n<li>A set of friendly documentations, libraries and utilities.</li>\n</ul>\n<h1>Why Reason</h1>\n<h4>Worry-free</h4>\n<p>Reason leverages OCaml\'s language design and type system to give immediate feedback in the form of compile-time errors and language features that make it easy to avoid anti-patterns.</p>\n<h4>Low Overhead</h4>\n<p>Reason keeps things simple and lean. Thanks to this, integrating Reason into your existing <a href="/guide/javascript">JavaScript</a> or <a href="/guide/native">OCaml</a> project is hassle-free. Do more with less; reduce your future burden!</p>\n<h4>Performant &#x26; predictable</h4>\n<p>Let the compiler and the type system nudge you toward writing code that\'s fast and easy to think about.</p>\n<h1>How Reason Works</h1>\n<p>The OCaml compiler is organized into several stages, which are exposed as\nlibraries. Reason replaces part of the compiler toolchain with a completely\nnew syntax parser that is more approachable, while still fully compatible with\nthe rest of the compiler. Reason also implements a new source printer which\nintegrates into your IDE and the new custom <a href="/guide/tools#repl"><code>REPL</code></a>.</p>\n<h6>Why OCaml?</h6>\n<p>OCaml is a great language for writing highly expressive, functional\n<em>or</em> imperative code, with type inference and fast runtime performance.\nBecause of these properties, OCaml has helped\nFacebook quickly build scalable infrastructure such as\n<a href="http://hacklang.org/">Hack</a>, <a href="http://flowtype.org/">Flow</a>, and\n<a href="http://fbinfer.com/">Infer</a>. It is also used for other performance sensitive\napplications in the financial industry (Jane Street, Bloomberg).</p>\n<p>Reason\'s non-invasive approach to the OCaml compiler allows Reason code\nto take advantage of all of the existing OCaml compiler\noptimizations/backends such as bare metal ARM, x86, and even JavaScript\ncompilation. OCaml has a very mature (<em>and still growing</em>) ecosystem for targeting\nbrowser and JavaScript environments with a focus on language interoperability\nand integration with existing JavaScript code.</p>'}}},{node:{relativePath:"guide/language/jsx.md",childMarkdownRemark:{frontmatter:{title:"JSX",order:10},html:'<p>Reason supports the JSX syntax, with some slight differences compared to the one in <a href="https://facebook.github.io/react/docs/introducing-jsx.html">ReactJS</a>. JSX tags translate to function calls as shown in these examples:</p>\n<p>Capitalized tag:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code>&lt;<span class="hljs-type">MyComponent</span> foo=bar /&gt;</code></pre>\n      </div>\n<p>becomes</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-type">MyComponent</span>.createElement foo::bar children::[] () [@<span class="hljs-type">JSX</span>]</code></pre>\n      </div>\n<p>Lowercase tag:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code>&lt;div foo=bar&gt;child1 child2&lt;/div&gt;</code></pre>\n      </div>\n<p>becomes</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code>div foo::bar children::[child1, child2] () [@<span class="hljs-type">JSX</span>]</code></pre>\n      </div>\n<p>The <code>[@JSX]</code> syntax attribute can be safely ignored; it\'s a hook for potential\nppx macros to spot them and syntactically transform the preceeding expression\ninto something else. This way, everyone gets to benefit the JSX syntax without\nneeding to opt into a specific library using it, e.g. React.</p>\n<p>Some departures from JS JSX: Children text require double quote. Attributes\ndon\'t mandate curly braces, unless they\'re complex expressions (in which case\nthey\'re formatted to parentheses).</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code>&lt;<span class="hljs-type">NoCurlyBraces</span>\n  booleanAttribute=<span class="hljs-literal">true</span>\n  stringAttribute=<span class="hljs-string">"string"</span>\n  intAttribute=<span class="hljs-number">1</span>\n  floatAttribute=<span class="hljs-number">0.1</span>\n  forcedOptional=?(<span class="hljs-type">Some</span> <span class="hljs-string">"hello"</span>)\n  onClick={updater handleClick}\n  thisWorksToo=(updater handleClick)&gt;\n  <span class="hljs-string">"foo bar"</span>\n&lt;/<span class="hljs-type">NoCurlyBraces</span>&gt;</code></pre>\n      </div>\n<p>There is also support for punning!</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code>&lt;div foo /&gt; <span class="hljs-comment">/* same as &lt;div foo=foo /&gt; */</span></code></pre>\n      </div>\n<p>Note that this would translate to <code>foo=true</code> within JSX in JS code.</p>\n<p>There is no support for JSX spread attributes.</p>\n<p>JSX calls supports the features of <a href="#basics-function">labeled functions</a>: optional, explicitly passed optional and optional with default.</p>'}}},{node:{relativePath:"guide/language/let-bindings.md",childMarkdownRemark:{frontmatter:{title:"Let Bindings",order:2},html:'<p><code>let</code> bindings give names to values. They can be seen and referenced by code that comes after them.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> greeting = <span class="hljs-string">"hello!"</span>;\n<span class="hljs-keyword">let</span> score = <span class="hljs-number">10</span>;\n<span class="hljs-keyword">let</span> newScore = <span class="hljs-number">10</span> + score;\n...</code></pre>\n      </div>\n<h4>Block Scope</h4>\n<p>Bindings can be scoped through <code>{}</code>.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> message = {\n  <span class="hljs-keyword">let</span> part1 = <span class="hljs-string">"hello"</span>;\n  <span class="hljs-keyword">let</span> part2 = <span class="hljs-string">"world"</span>;\n  part1 ^ <span class="hljs-string">" "</span> ^ part2\n};\n<span class="hljs-comment">/* `part1` and `part2` not accessible here! */</span></code></pre>\n      </div>\n<h4>Bindings Are Immutable</h4>\n<p>Once a binding refers to a value, it cannot refer to anything else (unless it\nexplicitly contains a mutable value, discussed later). However, you may create a\nnew binding of the same name which <em>shadows</em> the previous binding; from that\npoint onward, the binding will refer to the newly assigned value.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> message = <span class="hljs-string">"hello"</span>;\nprint_endline message; <span class="hljs-comment">/* Prints "hello" */</span>\n<span class="hljs-keyword">let</span> message = <span class="hljs-string">"bye"</span>;\nprint_endline message; <span class="hljs-comment">/* Prints "bye" */</span></code></pre>\n      </div>'}}},{node:{relativePath:"guide/language/mutation.md",childMarkdownRemark:{frontmatter:{title:"Mutation",order:8},html:'<p>Reason/OCaml exposes mutable features through <a href="#built-in-data-types-array">array</a> and <a href="#built-in-data-types-record">mutable record fields</a>. They\'re sometimes great for performance and expressing certain familiar programming patterns.</p>\n<p>For a single mutable reference (e.g. assigning a value to <code>let</code>), the standard library comes with syntax sugar for a <a href="/api/Pervasives.html#TYPEref">record type called <code>ref</code></a>. You\'d use it like so:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> myValue = <span class="hljs-keyword">ref</span> <span class="hljs-number">10</span>;\n<span class="hljs-keyword">if</span> (...) {\n  myValue := <span class="hljs-number">20</span>;\n};\nprint_int !myValue;</code></pre>\n      </div>\n<p>In reality, this is just:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> myValue = {contents: <span class="hljs-number">10</span>};\n<span class="hljs-keyword">if</span> (...) {\n  myValue.contents = <span class="hljs-number">20</span>;\n};\nprint_int myValue.contents;</code></pre>\n      </div>\n<p>There\'s nothing special about this record, beside the fact that it comes inside the standard library.</p>\n<p>You can also achieve lightweight, local "mutations" through overriding let bindings:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> foo = <span class="hljs-number">10</span>;\n<span class="hljs-keyword">let</span> foo = someCondition ? foo + <span class="hljs-number">5</span> : foo; <span class="hljs-comment">/* either 15 or 10 */</span>\n<span class="hljs-keyword">let</span> foo = <span class="hljs-string">"hello"</span>;\nprint_endline foo; <span class="hljs-comment">/* "hello" */</span></code></pre>\n      </div>\n<p>Notice we\'ve assigned a new type to <code>foo</code> in the before-last line. This is type-safe since, as documented <a href="#basics-let-binding">here</a>, the lines afterward can only see the last assignment of <code>foo</code>.</p>'}}},{node:{relativePath:"guide/language/modules.md",childMarkdownRemark:{frontmatter:{title:"Modules",order:12},html:'<h3>Basics</h3>\n<p><strong>Modules are like mini files</strong>! They can contain type definitions, <code>let</code>\nbindings, nested modules, etc.</p>\n<h4>Creation</h4>\n<p>To create a module, use the <code>module</code> keyword. The module name must start with a\n<strong>capital letter</strong>. Whatever you could place in a <code>.re</code> file, you may place\ninside a module definition\'s <code>{}</code> block.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">School</span> = </span>{\n  <span class="hljs-keyword">type</span> profession = <span class="hljs-type">Teacher</span> | <span class="hljs-type">Director</span>;\n\n  <span class="hljs-keyword">let</span> person1 = <span class="hljs-type">Teacher</span>;\n  <span class="hljs-keyword">let</span> getProfession person =&gt;\n    <span class="hljs-keyword">switch</span> person {\n    | <span class="hljs-type">Teacher</span> =&gt; <span class="hljs-string">"A teacher"</span>\n    | <span class="hljs-type">Director</span> =&gt; <span class="hljs-string">"A director"</span>\n    };\n};</code></pre>\n      </div>\n<p>A module\'s contents (including types!) can be accessed much like a record\'s,\nusing the <code>.</code> notation. This demonstrates modules\' utility for namespacing.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> anotherPerson: <span class="hljs-type">School</span>.profession = <span class="hljs-type">School</span>.<span class="hljs-type">Teacher</span>;\nprint_endline (<span class="hljs-type">School</span>.getProfession anotherPerson); <span class="hljs-comment">/* "A teacher" */</span></code></pre>\n      </div>\n<p>Nested modules work too.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MyModule</span> = </span>{\n  <span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">NestedModule</span> = </span>{\n     <span class="hljs-keyword">let</span> message = <span class="hljs-string">"hello"</span>;\n  };\n};\n\n<span class="hljs-keyword">let</span> message = <span class="hljs-type">MyModule</span>.<span class="hljs-type">NestedModule</span>.message;</code></pre>\n      </div>\n<h4><code>open</code>ing a module</h4>\n<p>Constantly referring to a value/type in a module can be tedious. We can open a\nmodule\'s definition and refer to its contents without prepending them with the\nmodule\'s name. Two ways:</p>\n<p>Local open.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> message =\n  <span class="hljs-type">School</span>.(\n    <span class="hljs-keyword">switch</span> person1 {\n    | <span class="hljs-type">Teacher</span> =&gt; <span class="hljs-string">"Hello teacher!"</span>\n    | <span class="hljs-type">Director</span> =&gt; <span class="hljs-string">"Hello director!"</span>\n    }\n  );</code></pre>\n      </div>\n<p>Global open. <strong>Use this sparingly as it allows convenience at the cost of ease\nof reasoning</strong>:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code>open <span class="hljs-type">School</span>;\n<span class="hljs-keyword">let</span> anotherPerson: profession = <span class="hljs-type">Teacher</span>;\nprintProfession anotherPerson;</code></pre>\n      </div>\n<h4>Extending modules</h4>\n<p>Using <code>include</code> in a module statically "spreads" a module\'s content into\na new one, thus often fulfill the role of "inheritance" or "mixin".</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">BaseComponent</span> = </span>{\n  <span class="hljs-keyword">let</span> defaultGreeting = <span class="hljs-string">"Hello"</span>;\n  <span class="hljs-keyword">let</span> getAudience ::excited =&gt; excited ? <span class="hljs-string">"world!"</span> : <span class="hljs-string">"world"</span>;\n};\n\n<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">ActualComponent</span> = </span>{\n  <span class="hljs-comment">/* the content is copied over */</span>\n  <span class="hljs-keyword">include</span> <span class="hljs-type">BaseComponent</span>;\n  <span class="hljs-comment">/* overrides BaseComponent.defaultGreeting */</span>\n  <span class="hljs-keyword">let</span> defaultGreeting = <span class="hljs-string">"Hey"</span>;\n  <span class="hljs-keyword">let</span> render () =&gt; defaultGreeting ^ <span class="hljs-string">" "</span> ^ getAudience excited::<span class="hljs-literal">true</span>;\n};</code></pre>\n      </div>\n<p><strong>Note</strong>: <code>include</code> and <code>open</code> are very different! The former literally copies\nover definitions into the new module for it to appropriate. The latter simply\nallows refering to items (values, types, constructors, etc.) in the <code>open</code>ed\nmodule\'s scope in an "unqualified" way (aka, <code>foo</code> instead of the qualified\n<code>MyModule.foo</code>).</p>\n<h4>Every <code>.re</code> file is a module</h4>\n<p>An OCaml/Reason file maps to a module; this unlocks some interesting\nexpressivity that\'d previously require code generation in other languages. The\nfile <code>react.re</code> implicitly forms a module <code>React</code>, which can be seen by other\nsource files.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* fileA.re. This typically compiles to module FileA below */</span>\n<span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;\n<span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;\n\n<span class="hljs-comment">/* fileB.re */</span>\n<span class="hljs-comment">/* Maps fileA\'s implementation to a new API */</span>\n<span class="hljs-keyword">let</span> alpha = <span class="hljs-type">FileA</span>.a;\n<span class="hljs-keyword">let</span> beta = <span class="hljs-type">FileA</span>.b;</code></pre>\n      </div>\n<p>This contrived snippet expresses "copying" a file:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* fileA.re. This typically compiles to module FileA below */</span>\n<span class="hljs-keyword">let</span> a = <span class="hljs-number">1</span>;\n<span class="hljs-keyword">let</span> b = <span class="hljs-number">2</span>;\n\n<span class="hljs-comment">/* fileB.re */</span>\n<span class="hljs-comment">/* compiles to exactly fileA.re\'s content with no runtime overhead! */</span>\n<span class="hljs-keyword">include</span> <span class="hljs-type">FileA</span>;</code></pre>\n      </div>\n<h2>Signatures</h2>\n<p>A module\'s type is called a "signature", and can be written explicitly. If a\nmodule is like a <code>.re</code> (implementation) file, then a module\'s signature is like\na <code>.rei</code> (interface) file.</p>\n<h4>Creation</h4>\n<p>To create a signature, use the <code>module type</code> keyword. The signature name must start with a\n<strong>capital letter</strong>. Whatever you could place in a <code>.rei</code> file, you may place\ninside a signature definition\'s <code>{}</code> block.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* Picking up previous section\'s example */</span>\n<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">type</span> <span class="hljs-title">EstablishmentType</span> = </span>{\n  <span class="hljs-keyword">type</span> profession;\n  <span class="hljs-keyword">let</span> getProfession: profession =&gt; string;\n};</code></pre>\n      </div>\n<p>A signature defines the list of requirements that a module must satisfy in order\nfor that module to match the signature. Those requirements are of the form:</p>\n<ul>\n<li>\n<p><code>let x: int;</code> requires a <code>let</code> binding named <code>x</code>, of type <code>int</code>.</p>\n</li>\n<li>\n<p><code>type t = someType;</code> requires a type field <code>t</code> to be equal to <code>someType</code>.</p>\n</li>\n<li>\n<p><code>type t;</code> requires a type field <code>t</code>, but without imposing any requirements on\nthe actual, concrete type of <code>t</code>. We\'d use <code>t</code> in other entries in the\nsignature to describe relationships, e.g. <code>let makePair: t -> (t, t)</code> but we\ncannot, for example, assume that <code>t</code> is an <code>int</code>. This gives us great,\nenforced abstraction abilities.</p>\n</li>\n</ul>\n<p>To illustrate the various kinds of type entries, consider the above signature\n<code>EstablishmentType</code> which requires that a module:</p>\n<ul>\n<li>Declare a type named <code>profession</code>.</li>\n<li>Must include a function that takes in a value of the type <code>profession</code> and\nreturns a string.</li>\n</ul>\n<p><strong>Note</strong>:</p>\n<p>Modules of the type <code>EstablishmentType</code> can contain more fields than the\nsignature declares, just like the module <code>School</code> in the previous section (if we\nchoose to assign it the type <code>EstablishmentType</code>. Otherwise, <code>School</code> exposes\nevery field). This effectively makes the <code>person1</code> field an enforced\nimplementation detail! Outsiders can\'t access it, since it\'s not present in the\nsignature; the signature <strong>constrained</strong> what others can access.</p>\n<p>The type <code>EstablishmentType.profession</code> is <strong>abstract</strong>: it doesn\'t have a\nconcrete type; it\'s saying "I don\'t care what the actual type is, but it\'s used\nas input to <code>getProfession</code>". This is useful to fit many modules under the same\ninterface:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">Company</span>: <span class="hljs-title">EstablishmentType</span> = </span>{\n  <span class="hljs-keyword">type</span> profession = <span class="hljs-type">CEO</span> | <span class="hljs-type">Designer</span> | <span class="hljs-type">Engineer</span> | ...;\n\n  <span class="hljs-keyword">let</span> getProfession person =&gt; ...\n  <span class="hljs-keyword">let</span> person1 = ...;\n  <span class="hljs-keyword">let</span> person2 = ...;\n};</code></pre>\n      </div>\n<p>It\'s also useful to hide the underlying type as an implementation detail others\ncan\'t rely on. If you ask what the type of <code>Company.profession</code> is, instead of\nexposing the variant, it\'ll only tell you "it\'s <code>Company.profession</code>".</p>\n<h4>Every <code>.rei</code> file is a signature</h4>\n<p>Similar to how a <code>react.re</code> file implicitly defines a module <code>React</code>, a file\n<code>react.rei</code> implicitly defines a signature for <code>React</code>. If <code>react.rei</code> isn\'t\nprovided, the signature of <code>react.re</code> defaults to exposing all the fields of the\nmodule. Because they don\'t contain implementation files, <code>.rei</code> files are used\nin the ecosystem to also document the public API of their corresponding modules.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* file react.re (implementation. Compiles to module React) */</span>\n<span class="hljs-keyword">type</span> state = int;\n<span class="hljs-keyword">let</span> render = <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> str<span class="hljs-params"> </span></span></span>=&gt; str;</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* file react.rei (interface. Compiles to signature of module React) */</span>\n<span class="hljs-keyword">type</span> state = int;\n<span class="hljs-keyword">let</span> render: str =&gt; str;</code></pre>\n      </div>\n<h2>Module Functions (functors)</h2>\n<p>Modules can be passed to functions! It would be the equivalent of passing a file\nas a first-class item. However, modules are at a different "layer" of the\nlanguage than other common concepts, so we can\'t pass them to <em>regular</em>\nfunctions. Instead, we pass them to special functions called "functors".</p>\n<p>The syntax for defining and using functors is very much like the syntax\nfor defining and using regular functions. The primary differences are:</p>\n<ul>\n<li>Functors use the <code>module</code> keyword instead of <code>let</code> and the <code>fun</code>\nkeyword designates "functor" rather than "function" in this case.</li>\n<li>Functors take modules as arguments and return a module.</li>\n<li>Functors <em>require</em> annotating arguments.</li>\n<li>Functors must start with a capital letter (just like modules/signatures).</li>\n</ul>\n<p>Here\'s an example <code>MakeSet</code> functor, that takes in a module of the type\n<code>Comparable</code> and returns a new set that can contain such comparable items.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">type</span> <span class="hljs-title">Comparable</span> = </span>{\n  <span class="hljs-keyword">type</span> t;\n  <span class="hljs-keyword">let</span> <span class="hljs-built_in">equal</span>: t =&gt; t =&gt; bool;\n};\n\n<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MakeSet</span> = <span class="hljs-title">fun</span> (<span class="hljs-title">Item</span>: <span class="hljs-title">Comparable</span>) =&gt; </span>{\n  <span class="hljs-comment">/* let\'s use a list as our naive backing data structure */</span>\n  <span class="hljs-keyword">type</span> backingType = list <span class="hljs-type">Item</span>.t;\n  <span class="hljs-keyword">let</span> empty = [];\n  <span class="hljs-keyword">let</span> add (currentSet: backingType) (newItem: <span class="hljs-type">Item</span>.t) :backingType =&gt;\n    <span class="hljs-comment">/* if item exists */</span>\n    <span class="hljs-keyword">if</span> (<span class="hljs-type">List</span>.exists (<span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> x<span class="hljs-params"> </span></span></span>=&gt; <span class="hljs-type">Item</span>.<span class="hljs-built_in">equal</span> x newItem) currentSet) {\n      currentSet <span class="hljs-comment">/* return the same (immutable) set (a list really) */</span>\n    } <span class="hljs-keyword">else</span> {\n      [newItem, ...currentSet]; <span class="hljs-comment">/* prepend to the set and return it */</span>\n    }\n};</code></pre>\n      </div>\n<p>Functors can be applied using function application syntax. In this case, we\'re\ncreating a set, whose items are pairs of integers.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">IntPair</span> = </span>{\n  <span class="hljs-keyword">type</span> t = (int, int);\n  <span class="hljs-keyword">let</span> <span class="hljs-built_in">equal</span> (x1, y1) (x2, y2) =&gt; x1 == x2 &amp;&amp; y1 == y2;\n  <span class="hljs-keyword">let</span> create x y =&gt; (x, y);\n};\n\n<span class="hljs-comment">/* IntPair abides by the Comparable signature required by MakeSet */</span>\n<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">SetOfIntPairs</span> = <span class="hljs-title">MakeSet</span> <span class="hljs-title">IntPair</span>;</span></code></pre>\n      </div>\n<h4>Module functions types</h4>\n<p>Like with module types, functor types also act to constrain and hide what we may\nassume about functors. The syntax for functor types are consistent with those\nfor function types, but with types capitalized to represent the signatures of\nmodules the functor accepts as arguments and return values. In the\nprevious example, we\'re exposing the backing type of a set; by giving <code>MakeSet</code>\na functor signature, we can hide the underlying data structure!</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">type</span> <span class="hljs-title">Comparable</span> = ...\n\n<span class="hljs-title">module</span> <span class="hljs-title">type</span> <span class="hljs-title">MakeSetType</span> = (<span class="hljs-title">Item</span>: <span class="hljs-title">Comparable</span>) =&gt; </span>{\n  <span class="hljs-keyword">type</span> backingType;\n  <span class="hljs-keyword">let</span> empty: backingType;\n  <span class="hljs-keyword">let</span> add: backingType =&gt; <span class="hljs-type">Item</span>.t =&gt; backingType;\n};\n\n<span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">MakeSet</span>: <span class="hljs-title">MakeSetType</span> = <span class="hljs-title">fun</span> (<span class="hljs-title">Item</span>: <span class="hljs-title">Comparable</span>) =&gt; </span>{\n  ...\n};</code></pre>\n      </div>\n<h2>Drawbacks</h2>\n<p>Modules and functors are at a different "layer" of language than the rest (\nfunctions, let bindings, data structures, etc.). For example, you can\'t easily\npass them into a tuple or record. Use them judiciously! Lots of times, just a\nrecord or a function is enough.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-class"><span class="hljs-keyword">module</span> <span class="hljs-title">School</span> = </span>{...};\n\n<span class="hljs-comment">/* this will straight up give you a syntax error! */</span>\n<span class="hljs-keyword">let</span> schools = (<span class="hljs-type">School</span>, <span class="hljs-type">School</span>);</code></pre>\n      </div>'
}}},{node:{relativePath:"guide/language/more-types.md",childMarkdownRemark:{frontmatter:{title:"More on Types",order:7},html:'<h4>Mutually Recursive Types</h4>\n<p>Just like functions, types can be mutually recursive through <code>and</code>:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> student = {taughtBy: teacher}\nand teacher = {students: list student};</code></pre>\n      </div>\n<p><strong>Note</strong> that there\'s no semicolon ending the first line and no <code>type</code> on the second line.</p>\n<h4>Type Arguments</h4>\n<p>Types can be "parameterized" (akin to generics in other languages). It\'s as if a type is a function that takes in arguments and returns a new type. The parameters need to start with <code>\'</code>.</p>\n<p>Types with parameters allow us to kill duplications. Before:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* this is a tuple of 3 items, explained next */</span>\n<span class="hljs-keyword">type</span> intCoordinates = (int, int, int);\n<span class="hljs-keyword">type</span> floatCoordinates = (float, float, float);\n\n<span class="hljs-keyword">let</span> buddy: intCoordinates = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);</code></pre>\n      </div>\n<p>After:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> coordinates \'a = (\'a, \'a, \'a);\n\n<span class="hljs-comment">/* apply the coordinates "type function" and return the type (int, int, int) */</span>\n<span class="hljs-keyword">type</span> intCoordinatesAlias = coordinates int;\n<span class="hljs-keyword">let</span> buddy: intCoordinatesAlias = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);\n\n<span class="hljs-comment">/* or, more commonly, write it inline */</span>\n<span class="hljs-keyword">let</span> buddy: coordinates float = (<span class="hljs-number">10.5</span>, <span class="hljs-number">20.5</span>, <span class="hljs-number">20.5</span>);</code></pre>\n      </div>\n<p>In practice, types are inferred for you. So the more concise version of the above example would be nothing but:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> buddy = (<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">20</span>);</code></pre>\n      </div>\n<p>The type system infers that it\'s a <code>(int, int, int)</code>. Nothing else needed to be written down.</p>\n<p>Type arguments appear everywhere.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* inferred as `list string` */</span>\n<span class="hljs-keyword">let</span> greetings = [<span class="hljs-string">"hello"</span>, <span class="hljs-string">"world"</span>, <span class="hljs-string">"how are you"</span>];</code></pre>\n      </div>\n<p>If types didn\'t accept parameters (aka, if we didn\'t have "type functions"), the standard library will need to define the types <code>listOfString</code>, <code>listOfInt</code>, <code>listOfTuplesOfInt</code>, etc.</p>\n<p>Types can receive more arguments, and be composable.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> result \'a \'b =\n| <span class="hljs-type">Ok</span> \'a\n| <span class="hljs-type">Error</span> \'b;\n\n<span class="hljs-keyword">type</span> myPayload = {data: string};\n\n<span class="hljs-keyword">type</span> myPayloadResults \'errorType = list (result myPayload \'errorType);\n\n<span class="hljs-keyword">let</span> payloadResults: myPayloadResults string = [\n  <span class="hljs-type">Ok</span> {data: <span class="hljs-string">"hi"</span>},\n  <span class="hljs-type">Ok</span> {data: <span class="hljs-string">"bye"</span>},\n  <span class="hljs-type">Error</span> <span class="hljs-string">"Something wrong happened!"</span>\n];</code></pre>\n      </div>\n<h2>Exceptions</h2>\n<p>Exceptions are just a special kind of <a href="#built-in-data-types-variant">variant</a>, "thrown" in <strong>exceptional</strong> cases (don\'t abuse them!). When you have ordinary variants, you often don\'t <strong>need</strong> exceptions, since you can just use variants types such as <code>type result</code> above.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code>try (somethingThatThrows ()) {\n| <span class="hljs-type">Not_found</span> =&gt; print_endline <span class="hljs-string">"Item not found!"</span>\n| <span class="hljs-type">Invalid_argument</span> message =&gt; print_endline message\n};</code></pre>\n      </div>\n<p>You can make your own exceptions like you\'d make a variant (exceptions need to be capitalized too).</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-none"><code><span class="hljs-keyword">exception</span> <span class="hljs-type">InputClosed</span> <span class="hljs-built_in">string</span>;\n...\nraise (<span class="hljs-type">InputClosed</span> <span class="hljs-string">"the stream has closed!"</span>);</code></pre>\n      </div>\n<h2>Objects</h2>\n<p>Although functions are the preferred way of working within Reason, it\'s also possible to use\nobjects.</p>\n<p>An object encapsulates data that it stores within fields, and has methods that can be invoked\nagainst the data it has.</p>\n<h5>Declaring an object type</h5>\n<p>An object can have an object type to define its structure.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> tesla = {\n  .\n  color: string\n};</code></pre>\n      </div>\n<p>The extra dot at the beginning is to indicate that this is a closed object type, which means that\nan object based on this type must have exactly this public structure.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> car \'a = {\n  ..\n  color: string\n} <span class="hljs-keyword">as</span> \'a;</code></pre>\n      </div>\n<p>Two dots, also called an elision, indicate that this is an open object type, and therefore\ncan also contain other values and methods. An open object is also polymorphic and therefore\nrequires a parameter.</p>\n<p>An object type is not required to create an object.</p>\n<h5>Creating an object</h5>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> tesla = {\n  .\n  drive: int =&gt; int\n};\n\n<span class="hljs-keyword">let</span> obj:tesla = {\n  <span class="hljs-keyword">val</span> hasEnvy = {contents: <span class="hljs-literal">false</span>};\n  <span class="hljs-keyword">pub</span> drive speed =&gt; {\n    this#enableEnvy <span class="hljs-literal">true</span>;\n    speed\n  };\n  <span class="hljs-keyword">pri</span> enableEnvy envy =&gt; {\n    hasEnvy.contents = envy\n  };\n};</code></pre>\n      </div>\n<p>This object is of object type tesla and has a public method <code>drive</code>. It also contains a\nprivate method <code>enableEnvy</code> that is only accesible from within the object.</p>\n<p>The following example shows an open object type which uses a type as parameter. The\nobject type parameter is required to implement all the methods of the open object\ntype.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> tesla \'a = {\n  ..\n  drive: int =&gt; int\n} <span class="hljs-keyword">as</span> \'a;\n\n<span class="hljs-keyword">let</span> obj:\n  tesla {. drive: int =&gt; int, doYouWant: unit =&gt; bool}\n  = {\n  <span class="hljs-keyword">val</span> hasEnvy = {contents: <span class="hljs-literal">false</span>};\n  <span class="hljs-keyword">pub</span> drive speed =&gt; {\n    this#enableEnvy <span class="hljs-literal">true</span>;\n    speed\n  };\n  <span class="hljs-keyword">pub</span> doYouWant () =&gt; hasEnvy.contents;\n  <span class="hljs-keyword">pri</span> enableEnvy envy =&gt; {\n    hasEnvy.contents = envy\n  };\n};</code></pre>\n      </div>'}}},{node:{relativePath:"guide/language/more-functions.md",childMarkdownRemark:{frontmatter:{title:"More on Functions",order:6},html:'<h4>Recursive Functions</h4>\n<p>By default, values can\'t see a binding that points to it, but including the\n<code>rec</code> keyword in a <code>let</code> binding makes this possible. This allows functions\nto see and call themselves, giving us the power of recursion.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> neverTerminate = <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> ()<span class="hljs-params"> </span></span></span>=&gt; neverTerminate ();</code></pre>\n      </div>\n<h4>Mutually Recursive Functions</h4>\n<p>Mutually recursive functions start like a single recursive function using the\n<code>rec</code> keyword, and then are chained together with <code>and</code>:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> <span class="hljs-keyword">rec</span> callSecond = <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> ()<span class="hljs-params"> </span></span></span>=&gt; callFirst ()\nand callFirst = <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> ()<span class="hljs-params"> </span></span></span>=&gt; callSecond ();</code></pre>\n      </div>\n<p><strong>Note</strong> that there\'s no semicolon ending the first line and no <code>let</code> on the second line.</p>\n<h4>Currying</h4>\n<p>Reason functions can automatically be <strong>partially</strong> called:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> add = <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> x<span class="hljs-params"> y<span class="hljs-params"> </span></span></span></span>=&gt; x + y;\n<span class="hljs-keyword">let</span> addFive = add <span class="hljs-number">5</span>;\n<span class="hljs-keyword">let</span> eleven = addFive <span class="hljs-number">6</span>;\n<span class="hljs-keyword">let</span> twelve = addFive <span class="hljs-number">7</span>;</code></pre>\n      </div>\n<p>Actually, the above <code>add</code> is nothing but syntactic sugar for this:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> add = <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> x<span class="hljs-params"> </span></span></span>=&gt; <span class="hljs-func"><span class="hljs-keyword">fun</span><span class="hljs-params"> y<span class="hljs-params"> </span></span></span>=&gt; x + y;</code></pre>\n      </div>\n<p>OCaml optimizes this to avoid the unnecessary function allocation (2 functions here, naively speaking) whenever it can! This way, we get</p>\n<ul>\n<li>Nice syntax</li>\n<li>Currying for free (every function takes a single argument, actually!)</li>\n<li>No performance cost</li>\n</ul>'}}},{node:{relativePath:"guide/language/primitives.md",childMarkdownRemark:{frontmatter:{title:"Primitives",order:0},html:'<h2>Primitives / Operations</h2>\n<table>\n<thead>\n<tr>\n<th>Primitive</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Strings</td>\n<td><code>"Hello"</code></td>\n</tr>\n<tr>\n<td>Characters</td>\n<td><code>\'x\'</code></td>\n</tr>\n<tr>\n<td>Integers</td>\n<td><code>23</code></td>\n</tr>\n<tr>\n<td>Floats</td>\n<td><code>23.0</code></td>\n</tr>\n<tr>\n<td>Negative Integers</td>\n<td><code>-23</code></td>\n</tr>\n<tr>\n<td>Integer Addition</td>\n<td><code>23 + 1</code></td>\n</tr>\n<tr>\n<td>Float Addition</td>\n<td><code>23.0 +. 1.0</code></td>\n</tr>\n<tr>\n<td>Integer Division/Multiplication</td>\n<td><code>2 / 23 * 1</code></td>\n</tr>\n<tr>\n<td>Float Division/Multiplication</td>\n<td><code>2.0 /. 23.0 \\*. 1.0</code></td>\n</tr>\n<tr>\n<td>String Concatenation</td>\n<td><code>"Hello " ^ "World"</code></td>\n</tr>\n<tr>\n<td>Immutable Lists</td>\n<td><code>[1, 2, 3]</code></td>\n</tr>\n<tr>\n<td>Immutable Prepend</td>\n<td><code>[item1, item2, ...theRest]</code></td>\n</tr>\n<tr>\n<td>Reference Equality</td>\n<td><code>thisThing === thatThing</code></td>\n</tr>\n<tr>\n<td>Arrays</td>\n<td><code>[|1, 2, 3|]</code></td>\n</tr>\n<tr>\n<td>Records</td>\n<td><code>type player = {score: int}; {score: 100}</code></td>\n</tr>\n</tbody>\n</table>'}}},{node:{relativePath:"guide/language/types.md",childMarkdownRemark:{frontmatter:{title:"Types",order:1},html:'<h4>Type Annotations</h4>\n<p>Types can be inferred or explicitly written down by choice.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> score: int = <span class="hljs-number">10</span>;</code></pre>\n      </div>\n<p>You can also wrap an expression in parentheses and annotate it:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">let</span> myInt = <span class="hljs-number">5</span>;\n<span class="hljs-keyword">let</span> myInt = (<span class="hljs-number">5</span> : int);\n<span class="hljs-keyword">let</span> myInt = (<span class="hljs-number">5</span> : int) + (<span class="hljs-number">4</span> : int);\n<span class="hljs-keyword">let</span> add (x: int) (y: int) :int =&gt; x + y;\n<span class="hljs-keyword">let</span> drawCircle radius::(r: int) :unit =&gt; ...;</code></pre>\n      </div>\n<p>Note: in the last line, <code>radius::(r: int)</code> is a labeled argument.\nMore on this <a href="https://reasonml.github.io/guide/language/functions">here</a>.</p>\n<h4>Type Aliases</h4>\n<p>You can refer to a type by a different name:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> scoreType = int;\n<span class="hljs-keyword">let</span> x: scoreType = <span class="hljs-number">10</span>;</code></pre>\n      </div>'}}},{node:{relativePath:"guide/javascript/index.md",childMarkdownRemark:{frontmatter:{title:"JavaScript",order:4},html:'<p>Reason compiles to JavaScript and native code. The workflows for each are <strong>currently separated</strong>. This page describes the JavaScript workflow. Our native workflow is currently work-in-progress and can be seen <a href="/guide/native">here</a>.\nWhenever you get stuck:</p>\n<ul>\n<li>Check out the <a href="/community/faq">frequently asked questions</a>.</li>\n<li>Peruse some <a href="/community/examples">code examples</a>.</li>\n<li>Ask us questions on <a href="https://discord.gg/reasonml">Discord</a>!</li>\n</ul>'}}},{node:{relativePath:"guide/javascript/converting.md",childMarkdownRemark:{frontmatter:{title:"Converting from JS",order:5},html:'<h2>Preparation</h2>\n<p><strong>Before you proceed</strong>, please make sure that Reason is what your team needs! As much as we vouch for Reason and BuckleScript\'s popularity, please don\'t unnecessarily thrash your colleagues and give them a bad first impression. That\'s hard to undo afterward.</p>\n<p>This guide covers a workflow that\'s helped us convert things over rapidly and efficiently. It\'s not intended to go over language/FFI features (though it puts them in context). Basic Reason/BuckleScript knowledge is assumed.</p>\n<h2>Syntax</h2>\n<p><strong>Goal</strong>: first and foremost, <strong>make the file syntactically valid</strong>. Don\'t care about wrong types, missing modules, bad file organization, too many externals, etc. We\'ll come back to clean these up after setting up the regression test that is "no more syntax errors".</p>\n<p>Since the Reason syntax resembles enough to that of JavaScript, instead of starting a new Reason file, just copy over an existing js file and work on top of it.</p>\n<p><em>Tip</em>: don\'t forget that you can use <code>refmt</code> in your editor/terminal! If you don\'t know e.g. the precedence of some operations, wrap them in as many parentheses as you wish, then <code>refmt</code> your code and see which ones remain. Likewise, no need to lose time on indentations and spacing; <code>refmt</code> takes care of them.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* original JS file you\'ve copied over */</span>\nconst school = require(\'school\');\n\nconst defaultId = <span class="hljs-number">10</span>;\n\nfunction queryResult(usePayload, payload) {\n  <span class="hljs-keyword">if</span> (usePayload) {\n    <span class="hljs-keyword">return</span> payload.student\n  }\n  <span class="hljs-keyword">return</span> school.getStudentById(defaultId);\n}</code></pre>\n      </div>\n<p>Here are some of the things you\'d do at this step:</p>\n<ul>\n<li>\n<p>Convert the function call syntax over.</p>\n</li>\n<li>\n<p>Convert the <code>var</code>/<code>const</code> over to <code>let</code>.</p>\n</li>\n<li>\n<p>Hide the <code>require</code>s.</p>\n</li>\n<li>\n<p>Make other such changes. For idioms that don\'t have a BuckleScript equivalent, use <code>bs.raw</code> (<a href="http://bucklescript.github.io/bucklescript/Manual.html#_embedding_arbitrary_js_code_as_an_expression">documentation</a>).</p>\n</li>\n</ul>\n<p>Again, <strong>worry only about making the file syntactically valid</strong>. Trying to learn all three of syntax, types and other semantics while converting over a file reduces your iteration speed to less than a third.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* syntactically valid, semantically wrong conversion */</span>\n<span class="hljs-comment">/* const school = require(\'school\'); */</span>\n\n<span class="hljs-keyword">let</span> defaultId = <span class="hljs-number">10</span>;\n\n<span class="hljs-keyword">let</span> queryResult usePayload payload =&gt; {\n  <span class="hljs-keyword">if</span> (usePayload) {\n    payload.student\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-comment">/* no need for early return in Reason; if-else is an expression */</span>\n    school.getStudentById defaultId;\n  }\n};</code></pre>\n      </div>\n<h2>Types, Pass 1</h2>\n<p><strong>Goal</strong>: correct the types, but just enough to move onto the next step.</p>\n<p>You might still occasionally get syntax errors, but not as drastic as the previous step\'s.</p>\n<ul>\n<li>\n<p>Change <code>foo.bar</code> to <code>foo##bar</code>. This escape-hatch <a href="http://bucklescript.github.io/bucklescript/Manual.html#_how_to_consume_js_property_and_methods">BuckleScript feature</a> will be your medium-term friend.</p>\n</li>\n<li>\n<p>Convert <code>{foo: bar}</code> to <code>[%bs.obj {foo: bar}]</code> (<a href="http://bucklescript.github.io/bucklescript/Manual.html#_create_js_objects_using_bs_obj">docs</a>). After <code>refmt</code>, this will sugar to <code>{"foo": bar}</code>.</p>\n</li>\n<li>\n<p>To communicate with external JS files, use <code>external</code>. They\'re BuckleScript\'s <a href="http://bucklescript.github.io/bucklescript/Manual.html#_ffi">foreign function interface</a>.</p>\n<ul>\n<li>\n<p>Inline externals. No need to create clean, well-separated files for externals for now. We\'ll come back to these.</p>\n</li>\n<li>\n<p>If it\'s too cumbersome to correctly type an <code>external</code>\'s input/output, use some placeholder polymorphic types, e.g. <code>external getStudentById: \'whatever => \'whateverElse = ...</code>.</p>\n</li>\n<li>\n<p>For data types &#x26; patterns that are hard to properly convert over, you can occasionally create converters like <code>external unsafeCast : myPayloadType => anotherDataType = "%identity";</code>.</p>\n</li>\n</ul>\n</li>\n</ul>\n<p>This is the first pass; the final types likely look different. For now, reap the rewards! Once you\'re finally done fixing all the type errors, your JS file should now be generated. Keep it open side-by-side. Time to come back and fix all the hacks!</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* syntactically valid, still semantically wrong, but better */</span>\nexternal getStudentById: \'whatever =&gt; \'whateverElse = <span class="hljs-string">"getStudentById"</span> [@@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"school"</span>];\n\n<span class="hljs-keyword">let</span> defaultId = <span class="hljs-number">10</span>;\n\n<span class="hljs-keyword">let</span> queryResult usePayload payload =&gt; {\n  <span class="hljs-keyword">if</span> (usePayload) {\n    payload##student <span class="hljs-comment">/* this will be inferred as `Js.t \'a` */</span>\n  } <span class="hljs-keyword">else</span> {\n    getStudentById defaultId;\n  }\n};</code></pre>\n      </div>\n<h2>Runtime Semantics</h2>\n<p><strong>Goal</strong>: fix the errors in the generated JS output.</p>\n<p>Compare it with your old JS file. The output is likely incorrect; you probably mis-converted some idioms and mistyped some externals.</p>\n<ul>\n<li>\n<p>Type the shape of JS objects (the things that required <code>##</code>).</p>\n</li>\n<li>\n<p>Convert whichever parts to records/variants/idiomatic OCaml types.</p>\n</li>\n</ul>\n<p>All this time, check the output for any change.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-keyword">type</span> student; <span class="hljs-comment">/* abstract type, described later */</span>\nexternal getStudentById: \'whatever =&gt; student = <span class="hljs-string">"getStudentById"</span> [@@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"school"</span>];\n\n<span class="hljs-keyword">type</span> payloadType = <span class="hljs-type">Js</span>.t {. student: student};\n\n<span class="hljs-keyword">let</span> defaultId = <span class="hljs-number">10</span>;\n\n<span class="hljs-keyword">let</span> queryResult usePayload (payload: payloadType) =&gt; {\n  <span class="hljs-keyword">if</span> (<span class="hljs-type">Js</span>.to_bool usePayload) {\n    payload##student\n  } <span class="hljs-keyword">else</span> {\n    getStudentById defaultId;\n  }\n};</code></pre>\n      </div>\n<h2>Clean Up (Types, Pass 2)</h2>\n<p><strong>Goal</strong>: make your types legit (aka, sound).</p>\n<p>Go back fix whatever you\'ve left during the first pass.</p>\n<ul>\n<li>\n<p>Make sure you don\'t have any <code>\'whatever</code> types left in <code>external</code>s.</p>\n</li>\n<li>\n<p>You can keep the <code>external</code>s inlined, or pull them out into a file.</p>\n</li>\n</ul>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* in the current file */</span>\n<span class="hljs-keyword">type</span> payloadType = <span class="hljs-type">Js</span>.t {. student: <span class="hljs-type">School</span>.student}; <span class="hljs-comment">/* <span class="hljs-doctag">TODO:</span> put this somewhere else! */</span>\n\n<span class="hljs-keyword">let</span> defaultId = <span class="hljs-number">10</span>;\n\n<span class="hljs-keyword">let</span> queryResult usePayload (payload: payloadType) =&gt; {\n  <span class="hljs-keyword">if</span> (<span class="hljs-type">Js</span>.to_bool usePayload) {\n    payload##student\n  } <span class="hljs-keyword">else</span> {\n    <span class="hljs-type">School</span>.getStudentById defaultId;\n  }\n};</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-reason"><code><span class="hljs-comment">/* in a dedicated School.re file */</span>\n<span class="hljs-keyword">type</span> student;\nexternal getStudentById: int =&gt; student = <span class="hljs-string">"getStudentById"</span> [@@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"School"</span>];\nexternal getAllStudents: unit =&gt; array student = <span class="hljs-string">"getAllStudents"</span> [@@bs.<span class="hljs-keyword">module</span> <span class="hljs-string">"School"</span>];</code></pre>\n      </div>\n<p>Type <code>student</code> doesn\'t have an actual content; that\'s called an <a href="#modules-signatures">abstract type</a>. It\'s a convenient way of specifying the relationship between external calls without knowing what the shape of the data is under the hood.</p>\n<p>And then you\'re done!</p>\n<h2>Tips</h2>\n<p><strong>Don\'t</strong> try to fully convert a JS file into a pristine Reason file in a single shot. Such method might actually slow you down! It\'s fine to have externals and <code>bs.obj</code> left, and temporarily not take advantage of nice OCaml features (variants, labelled arguments, etc.). Once you\'ve converted a few other related files, you can come back and now refactor <strong>faster</strong> by banking on the type system.</p>\n<p>Whatever nice utilities you find (e.g. convert a <code>Js.null_undefined Js.boolean</code> to a <code>bool</code>), put them in a <code>tempUtils.re</code> file or something. They\'re easy examples for your colleagues and removes some conversion churns.</p>\n<p>We <strong>highly recommend</strong> you to check the JS output into version control. It makes your build system integration quasi-nonexistent, and makes sure that when you\'re not there, your teammates can make small changes, audit the output diff, and catch any mistakes. It\'s also a great selling point that the checked in JS output is friendly to emergency hot patches (a big selling point for managers!). Even if you\'re upgrading BuckleScript version, you\'d catch any output difference. It\'s like <a href="https://facebook.github.io/jest/docs/snapshot-testing.html">Jest snapshots</a>, for free!</p>\n<p>As always, ping us on <a href="https://discord.gg/reasonml">Discord</a> for more help!</p>'}}},{node:{relativePath:"guide/javascript/libraries.md",childMarkdownRemark:{frontmatter:{title:"Libraries",order:2},html:'<p>Libraries that have already been wrapped with bucklescript bindings are customarily prefixed with <code>bs-</code>, e.g. <code>bs-director</code>. <a href="https://www.npmjs.com/search?q=keywords:bucklescript">Here\'s a search</a> for all of the bucklescript related libraries on npm.</p>\n<p>TODO give an example of working with e.g. momentjs.</p>'}}},{node:{relativePath:"guide/javascript/quickstart.md",childMarkdownRemark:{frontmatter:{title:"Quickstart",order:0},html:'<div class="gatsby-highlight">\n      <pre class="hljs lang-sh"><code>npm install -g bs-platform\nbsb -init my-first-app -theme basic-reason</code></pre>\n      </div>\n<p>And then run it as usual:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-sh"><code><span class="hljs-built_in">cd</span> my-first-app\nnpm run build</code></pre>\n      </div>\n<p>Alternatively, <strong>to start a <a href="https://reasonml.github.io/reason-react/gettingStarted.html">ReasonReact</a> app</strong>, try <code>bsb -init my-react-app -theme react</code>.\nMore info on bsb &#x26; bsconfig <a href="http://bucklescript.github.io/bucklescript/Manual.html#_bucklescript_build_system_code_bsb_code">here</a>.\n<strong>BuckleScript has first-class support for Reason</strong>, which is why you don\'t see any extra "reason" installation.</p>'}}},{node:{relativePath:"guide/javascript/interop.md",childMarkdownRemark:{frontmatter:{title:"Interop",order:1},html:'<h2>Just dumping JavaScript in the middle of your Reason code</h2>\n<p>If you\'re just hacking things together, this can be very nice, but you also have all of the unsafety of JavaScript code 😄.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code><span class="hljs-type">Js</span>.log <span class="hljs-string">"this is reason"</span>;\n[%%bs.raw {|\nconsole.log(<span class="hljs-symbol">\'here</span> is some javascript <span class="hljs-keyword">for</span> you\');\n|}];</code></pre>\n      </div>\n<blockquote>\n<p><code>{|</code> and <code>|}</code> are the delimiters of a multi-line string in OCaml. You can also put a tag in there e.g. <code>{something|</code> and then it will look for a matching <code>|something}</code> to close.</p>\n</blockquote>\n<p>And here\'s the resulting javascript:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-javascript"><code><span class="hljs-comment">// Generated by BUCKLESCRIPT VERSION 1.7.4, PLEASE EDIT WITH CARE</span>\n\'use strict\';\nconsole.log(<span class="hljs-string">"this is reason"</span>);\nconsole.log(\'here <span class="hljs-keyword">is</span> some javascript <span class="hljs-keyword">for</span> you\');</code></pre>\n      </div>\n<h2>Dumping in some JavaScript, and making it accessible from Reason</h2>\n<p>What if you want a value that can be used from your Reason code?</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code><span class="hljs-type">Js</span>.log <span class="hljs-string">"this is reason"</span>;\n<span class="hljs-keyword">let</span> x = [%bs.raw {| <span class="hljs-symbol">\'here</span> is a <span class="hljs-built_in">string</span> from javascript\' |}];\n<span class="hljs-type">Js</span>.log (x ^ <span class="hljs-string">" back in reason land"</span>); /* ^ is the operator <span class="hljs-keyword">for</span> <span class="hljs-built_in">string</span> concat */</code></pre>\n      </div>\n<p>Now you might be wondering "what magic is this?? How did ocaml know that <code>x</code> was a string? <strong>It doesn\'t</strong>. The type of <code>x</code> in this code is a magic type that will unify with anything! This is quite dangerous and can have cascading effects in OCaml\'s type inference algorithm.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code><span class="hljs-keyword">let</span> y = [%bs.raw {| <span class="hljs-symbol">\'something\'</span> |}];\n<span class="hljs-type">Js</span>.log (<span class="hljs-string">"a string"</span> ^ y, <span class="hljs-number">10</span> + y);\n/* danger!! ocaml won\'t stop you from using y <span class="hljs-keyword">as</span> <span class="hljs-number">2</span> totally different types */</code></pre>\n      </div>\n<p>To fix this, you should <strong>always</strong> provide a concrete type for the result of <code>bs.raw</code>.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code><span class="hljs-keyword">let</span> x: <span class="hljs-built_in">string</span> = [%bs.raw {| <span class="hljs-symbol">\'well</span>-typed\' |}];\n<span class="hljs-type">Js</span>.log (x ^ <span class="hljs-string">" back in reason land"</span>);\n/* ocaml will error out <span class="hljs-keyword">if</span> you <span class="hljs-keyword">try</span> <span class="hljs-keyword">to</span> use x <span class="hljs-keyword">as</span> anything other than a <span class="hljs-built_in">string</span> */</code></pre>\n      </div>\n<p>And here\'s the output!</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-javascript"><code>// Generated by BUCKLESCRIPT VERSION <span class="hljs-number">1.7</span>.<span class="hljs-number">4</span>, PLEASE EDIT WITH CARE\n<span class="hljs-string">\'use strict\'</span>;\nconsole.log(<span class="hljs-string">"this is reason"</span>);\nvar x = ( <span class="hljs-string">\'here is a string from javascript\'</span> );\nconsole.log(x + <span class="hljs-string">" back in reason land"</span>);\nvar y = ( <span class="hljs-string">\'something\'</span> );\nconsole.log(/* tuple */[\n      <span class="hljs-string">"a string"</span> + y,\n      <span class="hljs-number">10</span> + y | <span class="hljs-number">0</span>\n    ]);\nvar x<span class="hljs-variable">$1</span> = ( <span class="hljs-string">\'well-typed\'</span> );\nconsole.log(x<span class="hljs-variable">$1</span> + <span class="hljs-string">" back in reason land"</span>);</code></pre>\n      </div>\n<blockquote>\n<p>The difference between the 2 <code>%%</code> from the previous section and the 1 <code>%</code> here is important! <code>[%%something ...]</code> is an OCaml "extension point" that represents a <em>top-level</em> statement (it can\'t show up inside a function or value, for example). <code>[%something ...]</code> is an extension point that stands in for an <em>expression</em>, and can be put just about anywhere -- but make sure that the JavaScript you put inside is actually an expression! E.g. don\'t put a semicolon after it, or you\'ll get a syntax error when you try to run the resulting JavaScript.</p>\n</blockquote>\n<h2>Dumping in a function &#x26; passing values</h2>\n<p>We\'ll need a little knowledge about Bucklescript\'s runtime representation of various values for this to work.</p>\n<ul>\n<li><code>strings</code> are strings, <code>ints</code> and <code>floats</code> are just numbers</li>\n<li>an <a href="http://facebook.github.io/reason/#built-in-data-types-array">Array</a> is a mutable fixed-length list in OCaml, and is represented as a plain javascript array.</li>\n<li>a <a href="http://facebook.github.io/reason/#built-in-data-types-linked-list">List</a> is an immutable functional-style linked list, and is definitely the more idiomatic one to use in most cases. However, it\'s representation is more complicated (try <code>Js.log [1,2,3,4]</code> to check it out). Because of this, I generally convert to &#x26; from <code>Array</code>s when I\'m talking to javascript, via <code>Array.of_list</code> and <code>Array.to_list</code>.</li>\n<li>If you want to go deeper, there\'s an exhaustive list <a href="https://github.com/bucklescript/bucklescript/wiki/Runtime-representation">on the BuckleScript wiki</a></li>\n</ul>\n<p>Knowing that, we can write a function in JavaScript that just accepts an array and returns a number, without much trouble at all.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code><span class="hljs-keyword">let</span> jsCalculate: <span class="hljs-built_in">array</span> <span class="hljs-built_in">int</span> =&gt; <span class="hljs-built_in">int</span> =&gt; <span class="hljs-built_in">int</span> = [%bs.raw {|\n <span class="hljs-keyword">function</span> (numbers, scaleFactor) {\n   var result = <span class="hljs-number">0</span>;\n   numbers.forEach(number =&gt; {\n     result += number;\n   });\n   return result * scaleFactor;\n }\n|}];\n<span class="hljs-keyword">let</span> calculate numbers scaleFactor =&gt;\n  jsCalculate (<span class="hljs-type">Array</span>.of_list numbers) scaleFactor;\n<span class="hljs-type">Js</span>.log (calculate [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <span class="hljs-number">10</span>); /* -&gt; <span class="hljs-number">60</span> */</code></pre>\n      </div>\n<p>Of course, this function that I wrote in JavaScript could be ported over to Reason without much hassle.</p>\n<p><strong>Remember</strong> that this is an escape hatch that\'s very useful for learning so you can jump in quickly and make something, but it\'s a good exercise to go back through and convert things back into nice type safe reason code.</p>\n<p>I\'ve run into more than a few bugs because of raw JavaScript that I added to save time 😅.</p>\n<h2>Settling down and getting disciplined about things</h2>\n<p>So far we\'ve been using <code>bs.raw</code>, which is a very fast n loose way to do it, and <strong>not</strong> suitable for production.</p>\n<p>But what if we actually need to call a function that\'s in JavaScript? It\'s needed for interacting with the DOM, or using node modules. In BuckleScript, you use an <code>external</code> declaration (<a href="http://bucklescript.github.io/bucklescript/Manual.html#_binding_to_simple_js_functions_values">docs</a>).</p>\n<p>Getting a value and getting a function are both pretty easy:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code><span class="hljs-keyword">external</span> pi: <span class="hljs-built_in">float</span> = <span class="hljs-string">"Math.PI"</span> [@@bs.<span class="hljs-keyword">val</span>];\n<span class="hljs-keyword">let</span> tau = pi *. <span class="hljs-number">2.0</span>;\n<span class="hljs-keyword">external</span> alert: <span class="hljs-built_in">string</span> =&gt; void = <span class="hljs-string">"alert"</span> [@@bs.<span class="hljs-keyword">val</span>];\nalert <span class="hljs-string">"hello"</span>;</code></pre>\n      </div>\n<p>But what about when we want something more complicated? Here\'s how we could call <code>getContext</code> on a Canvas DOM node:</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code><span class="hljs-keyword">type</span> canvas;\n<span class="hljs-keyword">type</span> context;\n/* we\'re leaving these types abstract, because we won\'t\n * be using them directly anywhere */\n<span class="hljs-keyword">external</span> getContext: canvas =&gt; <span class="hljs-built_in">string</span> =&gt; context = <span class="hljs-string">""</span> [@@bs.send];\n<span class="hljs-keyword">let</span> myCanvas: canvas = [%bs.raw {| document.getElementById(<span class="hljs-string">"mycanvas"</span>) |}];\n<span class="hljs-keyword">let</span> ctx = getContext myCanvas <span class="hljs-string">"2d"</span>;</code></pre>\n      </div>\n<p>So let\'s unpack what\'s going on. We created some abstract types for the Canvas DOM node and the associated RenderingContext object.</p>\n<p>Then we made a <code>getContext</code> function, but instead of <code>@@bs.val</code> we used <code>@@bs.send</code>, and we used an empty string for the text of the external. <code>@@bs.send</code> means "we\'re calling a method on the first argument", which in this case is the canvas. BuckleScript will translate this into <code>theFirstArgument.getContext(theSecondArgument, ...)</code>.</p>\n<p>And the empty string means "the js-name is the same as the name we\'re giving the external here in BuckleScript-land", in this case <code>getContext</code>. If we wanted to name it something else (like <code>getRenderingContext</code>), when we\'d have to supply the string <code>"getContext"</code> so that BuckleScript calls the right function.</p>\n<p>Let\'s add one more function just so it\'s interesting.</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code><span class="hljs-keyword">external</span> fillRect: context =&gt; <span class="hljs-built_in">float</span> =&gt; <span class="hljs-built_in">float</span> =&gt; <span class="hljs-built_in">float</span> =&gt; <span class="hljs-built_in">float</span> =&gt; <span class="hljs-built_in">unit</span> = <span class="hljs-string">""</span> [@@bs.send];</code></pre>\n      </div>\n<p>And now we can draw something!</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-ocaml"><code>fillRect ctx <span class="hljs-number">0.0</span> <span class="hljs-number">0.0</span> <span class="hljs-number">100.0</span> <span class="hljs-number">100.0</span>;</code></pre>\n      </div>\n<p>It\'s not much, but adding other canvas methods is similar, and then you can start doing some <a href="https://twitter.com/jaredforsyth/status/871062358076030976">really fun things</a>.</p>\n<p>So what does the compiled JavaScript look like?</p>\n<div class="gatsby-highlight">\n      <pre class="hljs lang-javascript"><code>\'use strict\';\n<span class="hljs-keyword">var</span> tau = <span class="hljs-type">Math</span>.<span class="hljs-type">PI</span> * <span class="hljs-number">2.0</span>;\nalert(<span class="hljs-string">"hello"</span>);\n<span class="hljs-keyword">var</span> myCanvas = ( document.getElementById(<span class="hljs-string">"mycanvas"</span>) );\n<span class="hljs-keyword">var</span> ctx = myCanvas.getContext(<span class="hljs-string">"2d"</span>);\nctx.fillRect(<span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">100.0</span>, <span class="hljs-number">100.0</span>);</code></pre>\n      </div>\n<p>Wow! Notice how BuckleScript just inlined our <code>pi</code> variable for us? And the output looks almost exactly like it was written by hand.</p>'
}}},{node:{relativePath:"guide/javascript/syntax-cheetsheet.md",childMarkdownRemark:{frontmatter:{title:"Syntax cheetsheet",order:1},html:'<p>Reason resembles a typed subset of modern JavaScript (the good parts).</p>\n<p>Reason\'s syntax is easy to learn, and if you know modern\nJavaScript you can usually read and make sense of Reason code without\nactually learning Reason.\nThe OCaml language that Reason uses provides many new concepts that\ndeliver a much more expressive, yet often more constrained experience. Reason\nhelps you learn those new concepts more quickly and reap the benefits of the\nOCaml compiler sooner.</p>\n<p>The end result is that Reason:</p>\n<ul>\n<li>Allows writing code that a wide range of developers can <strong>easily read</strong>.</li>\n<li>Can be <strong>mastered quickly</strong>.</li>\n<li>Delivers the true <strong>"if it compiles, it works"</strong> experience pioneered by the <code>ML</code> language.</li>\n<li>Compiles to <strong>bare metal</strong> native binaries, <em>or</em> to JavaScript.</li>\n</ul>\n<h3>Basic Language Primitives</h3>\n<table>\n<thead>\n<tr>\n<th>JavaScript</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><pre>\n3\n</pre></td>\n<td><pre>\n3\n</pre></td>\n</tr>\n<tr>\n<td><pre>\n3.1415 \n</pre></td>\n<td><pre>\n 3.1415 \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n"Hello world!" \n</pre></td>\n<td><pre>\n"Hello world!" \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n\'Hello world!\' \n</pre></td>\n<td>Strings must use "</td>\n</tr>\n<tr>\n<td>Characters are strings</td>\n<td><pre>\n\'a\'  \n</pre></td>\n</tr>\n<tr>\n<td><pre>\ntrue\n</pre></td>\n<td><pre>\ntrue \n</pre></td>\n</tr>\n<tr>\n<td><code>[1,2,3]</code></td>\n<td><code>[1,2,3]</code></td>\n</tr>\n<tr>\n<td><pre>\nnull\n</pre></td>\n<td><pre>\n()\n</pre></td>\n</tr>\n<tr>\n<td><pre>\nconst x = y;\n</pre></td>\n<td><pre>\nlet x = y;\n</pre></td>\n</tr>\n<tr>\n<td><pre>\nlet x = y;\n</pre></td>\n<td><pre>\nreference cells\n</pre></td>\n</tr>\n<tr>\n<td><pre>\nvar x = y;\n</pre></td>\n<td>No equivalent (thankfully)</td>\n</tr>\n<tr>\n<td><code>[x, ...lst] (linear time)</code></td>\n<td><code>[x, ...lst] (constant time)</code></td>\n</tr>\n<tr>\n<td><code>[...lst, x] (linear time)</code></td>\n<td><pre>\nNot supported\n</pre></td>\n</tr>\n<tr>\n<td><pre>\n{...obj, x: y}\n</pre></td>\n<td><pre>\n{...obj, x: y}\n</pre></td>\n</tr>\n</tbody>\n</table>\n<h3>Basic Operations on Primitives</h3>\n<table>\n<thead>\n<tr>\n<th>JavaScript</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><pre>\n1 + 2\n</pre></td>\n<td><pre>\n1 + 2\n</pre></td>\n</tr>\n<tr>\n<td><pre>\n1.0 + 2.0 \n</pre></td>\n<td><pre>\n1.0 +. 2.0 \n</pre></td>\n</tr>\n<tr>\n<td><pre>\n"hello " + "world" \n</pre></td>\n<td><pre>\n"hello " ^ "world" \n</pre></td>\n</tr>\n</tbody>\n</table>\n<h3>Objects and Records</h3>\n<table>\n<thead>\n<tr>\n<th>JavaScript</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>"Objects"</td>\n<td>"Records"</td>\n</tr>\n<tr>\n<td>no static types</td>\n<td><pre>\ntype point = {x: int, mutable y: int};\n</pre></td>\n</tr>\n<tr>\n<td><pre>\n{x: 30, y: 20}\n</pre></td>\n<td><pre>\n{x: 30, y: 20}\n</pre></td>\n</tr>\n<tr>\n<td><pre>\npoint.x\n</pre></td>\n<td><pre>\npoint.x\n</pre></td>\n</tr>\n<tr>\n<td><pre>\npoint.y = 30;\n</pre></td>\n<td><pre>\npoint.y = 30;\n</pre></td>\n</tr>\n<tr>\n<td><pre>\n{...point, x: 30}\n</pre></td>\n<td><pre>\n{...point, x: 30}\n</pre></td>\n</tr>\n</tbody>\n</table>\n<h3>Blocks</h3>\n<p>In Reason, "sequence expressions" are created with <code>{}</code> and evaluate to their\nlast statement. In JavaScript, this can be simulated via a temporary variable\nwhich must be created in an invalid state, then later mutated.</p>\n<table>\n  <thead><tr> <th scope="col"><p >JavaScript</p></th> <th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet res = undefined;\n{\n  const x = 23;\n  const y = 34;\n  res = x + y;\n};</pre>\n    </td>\n    <td>\n      <pre>\nlet res = {\n  let x = 23;\n  let y = 34;\n  x + y\n};</pre>\n    </td>\n  </tr>\n</table>\n<h3>Lambdas</h3>\n<p>JavaScript has two different kinds of functions, whereas Reason only has one.</p>\n<table>\n<thead>\n<tr>\n<th>JavaScript</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><pre>\narg => retVal  \n</pre></td>\n<td><pre>\nfun arg => retVal\n</pre></td>\n</tr>\n<tr>\n<td><pre>\nfunction named(arg) {...}</td>\n<td></td>\n</tr>\n<tr>\n<td><pre>\nlet f = function named(arg) {...}</td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>The primary difference between modern (ES6) JavaScript and Reason lambdas is that\nReason lambdas begin with the word <code>fun</code>. This is simply to assist in visual\nunderstanding of the meaning of a function when it has a very large destructured\nargument.</p>\n<table>\n<thead>\n<tr>\n<th>JavaScript</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><pre>\nconst incr = x => x + 1;\n</pre></td>\n<td><pre>\nlet incr = fun x => x + 1;\n</pre></td>\n</tr>\n<tr>\n<td><pre>\nconst five = incr(4);\n</pre></td>\n<td><pre>\nlet five = incr 4;\n</pre></td>\n</tr>\n<tr>\n<td><pre>\nconst add = (x, y) => x+y;\n</pre></td>\n<td><pre>\nlet add = fun x y => x+y;\n</pre></td>\n</tr>\n<tr>\n<td><pre>\nconst x = add(3, 4);\n</pre></td>\n<td><pre>\nlet x = add 3 4;\n</pre></td>\n</tr>\n<tr>\n<td><pre>\nconst y = add(3, add(0, 1));\n</pre></td>\n<td><pre>\nlet y = add 3 (add 0 1);\n</pre></td>\n</tr>\n</tbody>\n</table>\n<p>Like JavaScript, Reason allows any expression on the right hand side of the\nlambda <code>=></code>.</p>\n<table>\n  <thead><tr> <th scope="col"><p >JavaScript</p></th> <th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nconst add = (x, y) =>\n  x + x + y + y;\n      </pre>\n    </td>\n    <td>\n      <pre>\nlet add = fun (x, y) =>\n  x + x + y + y;\n      </pre>\n    </td>\n  </tr>\n</table>\n<p>However, JavaScript allows lambdas to return <code>{}</code> blocks <em>instead</em> of expressions, by way of a <code>return</code>\nstatement wrapped in <code>{}</code> braces. With Reason, <code>{}</code> blocks are <em>already</em> expressions, so Reason doesn\'t\nrequire two modes for lambda - all lambdas in Reason have expressions on the right hand side of the <code>=></code>,\nand some of those expressions coincidentally resemble "function bodies" in <code>{}</code> braces.</p>\n<table>\n  <thead><tr> <th scope="col"><p >JavaScript</p></th> <th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nconst myFun = (x, y) => {\n  const doubleX = x + x;\n  const doubleY = y + y;\n  return doubleX + doubleY\n};</pre>\n    </td>\n    <td>\n      <pre>\nlet myFun = fun (x, y) => {\n  let doubleX = x + x;\n  let doubleY = y + y;\n  doubleX + doubleY\n};</pre>\n    </td>\n  </tr>\n</table>\n<p>When using Reason every function accepts a single argument. In this example,\nthat single argument happens to be a destructured tuple. This appears very\nsimilar to the JavaScript arguments. However, the difference is apparent\nwhen supplying those arguments as first class. In JavaScript, arguments\nare an array, and supplying <em>all</em> of the arguments requires <code>.apply</code>.\nIn Reason, you may simply supply the tuple.</p>\n<table>\n  <thead><tr> <th scope="col"><p >JavaScript</p></th> <th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet add = (x, y) =>\n  x + x + y + y;\nlet result = add (1, 2);\nlet myArgs = [1, 2];\nlet result = add.apply(null, myArgs);</pre>\n    </td>\n    <td>\n      <pre>\nlet add = fun (x, y) =>\n  x + x + y + y;\nlet result = add (1, 2);\nlet myArgs = (1, 2);\nlet result = add myArgs;</pre>\n    </td>\n  </tr>\n</table>\n<h3>Function Application</h3>\n<p>In Reason, parentheses are typically optional in places where it is obvious\nthey aren\'t needed. This means that when invoking functions, parentheses\naren\'t always required around the argument. Reason will let you add the\nparentheses if you really want them, but it\'s good to know why some samples\nyou read have omitted them. See how in this example, arguments that are clearly\nsingle words, or that have balanced "bookends" (such as <code>{ }</code>) do not need\nthe parentheses.</p>\n<table>\n  <thead><tr> <th scope="col"><p >JavaScript</p></th> <th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>\nlet result = aFunc (oneArg);</pre>\n    </td>\n    <td>\n      <pre>\nlet result = aFunc (oneArg);\nlet result = aFunc oneArg;</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet result = aFunc ({x:0});\n      </pre>\n    </td>\n    <td>\n      <pre>let result = aFunc ({x:0});\nlet result = aFunc {x:0};</pre>\n    </td>\n  </tr>\n</table>\n<h3>Currying</h3>\n<p>Both JavaScript and Reason support currying, but with Reason, when using\nthe native compiler (or even a JavaScript backend), currying is optimized.\n(Specifically, you are not penalized for currying in Reason, whenever you\nhappen to supply all the arguments). The main syntactic difference when defining\ncurried functions is that Reason lambdas always begin with the <code>fun</code> keyword.</p>\n<table>\n  <thead><tr> <th scope="col"><p >JavaScript</p></th> <th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td><pre>let add = a => b => a + b;</pre></td>\n    <td><pre>let add = fun a => fun b => a + b;</pre></td>\n  </tr>\n</table>\n<p>When invoking curried functions, the syntax is the same, but with Reason,\nsupplying the parenthesis is optional.</p>\n<table>\n  <thead><tr> <th scope="col"><p >JavaScript</p></th> <th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>let result = add(10)(20);</pre>\n    </td>\n    <td>\n      <pre>let result = add(10)(20);</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre></pre>\n    </td>\n    <td>\n      <pre>let result = add 10 20;</pre>\n    </td>\n  </tr>\n</table>\n<p>Because Reason lambdas include the <code>fun</code> keyword, curried functions don\'t\nappear as clean as they do in JavaScript. To remedy this, Reason includes a\nsyntactic sugar to help with curried function definitions. The two forms\nare <em>exactly</em> equivalent and nothing changes about how you would invoke these\nfunctions.</p>\n<table>\n  <thead><tr> <th scope="col"><p >JavaScript</p></th> <th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>let add = a => b => a + b;</pre>\n    </td>\n    <td>\n      <pre>let add = fun a => fun b => a + b;</pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>// No syntactic sugar needed</pre>\n    </td>\n    <td>\n      <pre>let add = fun a b => a + b;</pre>\n    </td>\n  </tr>\n</table>\n<h3>Record Fields</h3>\n<p>In Reason, you must ensure your record literal has an unambiguous type if you\nwant to create records or access record fields. In the simplest case, the record\ntype is already in scope and you can unambiguously create values just by using\nthe standard <code>{ key: value }</code> syntax.</p>\n<table>\n  <thead>\n    <tr>\n      <th scope="col"><p>JavaScript</p></th>\n      <th scope="col"><p>Reason</p></th>\n    </tr>\n  </thead>\n  <tr>\n    <td>\n      <pre>function make(\n  id, name) {\n  return {\n    id: id,\n    name: name\n  };\n}</pre>\n    </td>\n    <td>\n      <pre>module Person = {\n  type t = {\n    id: int, name: string\n  };\n  let make id name => { id: id, name: name };\n  /&ast;\n  Alternatively, using field name punning,\n  let make id name => { id, name };\n  &ast;/\n};</pre>\n    </td>\n  </tr>\n</table>\n<p>When the record type is declared in a different module, you have to give Reason\na little guidance on which exact type you mean, because different record types\nin different modules can share field names.</p>\n<p>In order of safety, it\'s preferred to either (1) prefix at least one record\nfield with the module name to uniquely identify the record type (safest), (2)\nprefix the record literal with a temporary module open to bring the record type\ninto scope (slightly less safe--brings all names from the opened module into\nscope for the rest of the expression), or (3) open the entire module to bring\nthe record type into scope (least safe--brings all names from the opened module\ninto scope for the rest of the block).</p>\n<table>\n  <thead>\n    <tr>\n      <th scope="col"><p>JavaScript</p></th>\n      <th scope="col"><p>Reason</p></th>\n    </tr>\n  </thead>\n  <tr>\n    <td>\n      <pre>const bob =\n  { id: 1, name: "Bob" };</pre>\n    </td>\n    <td>\n      <pre>let bob = {\n  Person.id: 1, name: "Bob"\n};</pre>\n    </td>\n  </tr>\n  <tr>\n    <td><pre></pre></td>\n    <td>\n      <pre>let bob = Person.{\n  id: 1, name: "Bob"\n};</pre>\n    </td>\n  </tr>\n  <tr>\n    <td><pre></pre></td>\n    <td>\n      <pre>open Person;\nlet bob = {\n  id: 1, name: "Bob"\n};</pre>\n    </td>\n  </tr>\n</table>\n<h3>Expressions</h3>\n<p>If it wasn\'t already clear, in Reason, almost everything is an expression. For\nexample, in Reason, the <code>switch</code> statement <em>evaluates</em> to a value, which makes\nprogramming less error prone. Notice how in the JavaScript version, there is\nsome time when the program is in an invalid state.  The switch statement in\nReason also provides many more super powers, discussed in <a href="/guide/language/destructuring">Pattern\nMatching</a>.</p>\n<table>\n  <thead><tr> <th scope="col"><p >JavaScript</p></th> <th scope="col"><p>Reason</p></th></tr></thead>\n  <tr>\n    <td>\n      <pre>login ? "hi" : "bye" </pre>\n    </td>\n    <td>\n      <pre>login ? "hi" : "bye" </pre>\n    </td>\n  </tr>\n  <tr>\n    <td>\n      <pre>\nlet res = undefined;\nswitch (thing) {\n  case first:\n     res = "first";\n     break;\n  case second:\n     res = "second";\n     break;\n};\n      </pre>\n    </td>\n    <td>\n      <pre>\nlet res = switch thing {\n  | first => "first"\n  | second => "second"\n};\n      </pre>\n    </td>\n  </tr>\n</table>'}}}]}},pathContext:{section:"guide",sectionTitle:"Guide",relatedFiles:"/^guide\\/.*\\.md$/"}}}});
//# sourceMappingURL=path---guide-search-dee9b7940759ebcb32ab.js.map