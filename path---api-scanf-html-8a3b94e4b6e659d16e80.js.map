{"version":3,"sources":["webpack:///path---api-scanf-html-8a3b94e4b6e659d16e80.js","webpack:///./.cache/json/api-scanf-html.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/api-scanf-html.json","module","exports","data","file","relativePath","childRawHtml","content","pathContext"],"mappings":"AAAAA,cAAc,MAERC,wEACA,SAAUC,EAAQC,GCHxBD,EAAAC,SACAC,MACAC,MACAC,aAAA,iBACAC,cACAC,QAAA;IAIAC,aACAH,aAAA","file":"path---api-scanf-html-8a3b94e4b6e659d16e80.js","sourcesContent":["webpackJsonp([203],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/api-scanf-html.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"data\": {\n\t\t\t\"file\": {\n\t\t\t\t\"relativePath\": \"api/Scanf.html\",\n\t\t\t\t\"childRawHtml\": {\n\t\t\t\t\t\"content\": \"<div class=\\\"ocamldoc\\\">\\n<div class=\\\"navbar\\\"><a class=\\\"pre\\\" href=\\\"Random.html\\\" title=\\\"Random\\\">Previous</a>\\n&#xA0;<a class=\\\"up\\\" href=\\\"index.html\\\" title=\\\"Index\\\">Up</a>\\n&#xA0;<a class=\\\"post\\\" href=\\\"Set.html\\\" title=\\\"Set\\\">Next</a>\\n</div>\\n<h1>Module <a href=\\\"type_Scanf.html\\\">Scanf</a></h1>\\n\\n<pre><span class=\\\"keyword\\\">module</span> Scanf: sig .. end</pre><div class=\\\"info module top\\\">\\nFormatted input functions.<br>\\n</div>\\n<hr width=\\\"100%\\\">\\n<br>\\n<h6 id=\\\"6_Introduction\\\">Introduction</h6><br>\\n<br>\\n<h6 id=\\\"6_Introduction\\\">Introduction</h6><br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Functionalinputwithformatstrings\\\">Functional input with format strings</div><br>\\n<br>\\n<h6 id=\\\"6_Introduction\\\">Introduction</h6><br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Functionalinputwithformatstrings\\\">Functional input with format strings</div><br>\\n<br>\\nThe module <code class=\\\"code\\\">Scanf</code> provides formatted input functions or <em>scanners</em>.\\n<p>\\n\\n    The formatted input functions can read from any kind of input, including\\n    strings, files, or anything that can return characters. The more general\\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>. The more general\\n    formatted input function reads from any scanning buffer and is named\\n    <code class=\\\"code\\\">bscanf</code>.\\n</p><p>\\n\\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\\n<li>the first argument is a source of characters for the input,</li>\\n<li>the second argument is a format string that specifies the values to\\n      read,</li>\\n<li>the third argument is a <em>receiver function</em> that is applied to the\\n      values read.</li>\\n</ul>\\n\\n    Hence, a typical call to the formatted input function <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a> is\\n    <code class=\\\"code\\\">bscanf ic fmt f</code>, where:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">fmt</code> is a format string (the same format strings as those used to print\\n    material with module <a href=\\\"Printf.html\\\"><code class=\\\"code\\\">Printf</code></a> or <a href=\\\"Format.html\\\"><code class=\\\"code\\\">Format</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">f</code> is a function that has as many arguments as the number of values to\\n    read in the input.</li>\\n</ul>\\n<br>\\n<br>\\n<h6 id=\\\"6_Introduction\\\">Introduction</h6><br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Functionalinputwithformatstrings\\\">Functional input with format strings</div><br>\\n<br>\\nThe module <code class=\\\"code\\\">Scanf</code> provides formatted input functions or <em>scanners</em>.\\n<p>\\n\\n    The formatted input functions can read from any kind of input, including\\n    strings, files, or anything that can return characters. The more general\\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>. The more general\\n    formatted input function reads from any scanning buffer and is named\\n    <code class=\\\"code\\\">bscanf</code>.\\n</p><p>\\n\\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\\n<li>the first argument is a source of characters for the input,</li>\\n<li>the second argument is a format string that specifies the values to\\n      read,</li>\\n<li>the third argument is a <em>receiver function</em> that is applied to the\\n      values read.</li>\\n</ul>\\n\\n    Hence, a typical call to the formatted input function <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a> is\\n    <code class=\\\"code\\\">bscanf ic fmt f</code>, where:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">fmt</code> is a format string (the same format strings as those used to print\\n    material with module <a href=\\\"Printf.html\\\"><code class=\\\"code\\\">Printf</code></a> or <a href=\\\"Format.html\\\"><code class=\\\"code\\\">Format</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">f</code> is a function that has as many arguments as the number of values to\\n    read in the input.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Asimpleexample\\\">A simple example</div><br>\\n<br>\\n<h6 id=\\\"6_Introduction\\\">Introduction</h6><br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Functionalinputwithformatstrings\\\">Functional input with format strings</div><br>\\n<br>\\nThe module <code class=\\\"code\\\">Scanf</code> provides formatted input functions or <em>scanners</em>.\\n<p>\\n\\n    The formatted input functions can read from any kind of input, including\\n    strings, files, or anything that can return characters. The more general\\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>. The more general\\n    formatted input function reads from any scanning buffer and is named\\n    <code class=\\\"code\\\">bscanf</code>.\\n</p><p>\\n\\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\\n<li>the first argument is a source of characters for the input,</li>\\n<li>the second argument is a format string that specifies the values to\\n      read,</li>\\n<li>the third argument is a <em>receiver function</em> that is applied to the\\n      values read.</li>\\n</ul>\\n\\n    Hence, a typical call to the formatted input function <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a> is\\n    <code class=\\\"code\\\">bscanf ic fmt f</code>, where:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">fmt</code> is a format string (the same format strings as those used to print\\n    material with module <a href=\\\"Printf.html\\\"><code class=\\\"code\\\">Printf</code></a> or <a href=\\\"Format.html\\\"><code class=\\\"code\\\">Format</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">f</code> is a function that has as many arguments as the number of values to\\n    read in the input.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Asimpleexample\\\">A simple example</div><br>\\n<br>\\nAs suggested above, the expression <code class=\\\"code\\\">bscanf ic &quot;%d&quot; f</code> reads a decimal\\n    integer <code class=\\\"code\\\">n</code> from the source of characters <code class=\\\"code\\\">ic</code> and returns <code class=\\\"code\\\">f n</code>.\\n<p>\\n\\n    For instance,\\n</p><p>\\n</p><ul>\\n<li>if we use <code class=\\\"code\\\">stdin</code> as the source of characters (<a href=\\\"Scanf.Scanning.html#VALstdin\\\"><code class=\\\"code\\\">Scanf.Scanning.stdin</code></a> is\\n    the predefined formatted input channel that reads from standard input),</li>\\n</ul>\\n<ul>\\n<li>if we define the receiver <code class=\\\"code\\\">f</code> as <code class=\\\"code\\\">let f x = x + 1</code>,</li>\\n</ul>\\n\\n    then <code class=\\\"code\\\">bscanf Scanning.stdin &quot;%d&quot; f</code> reads an integer <code class=\\\"code\\\">n</code> from the\\n    standard input and returns <code class=\\\"code\\\">f n</code> (that is <code class=\\\"code\\\">n + 1</code>). Thus, if we\\n    evaluate <code class=\\\"code\\\">bscanf stdin &quot;%d&quot; f</code>, and then enter <code class=\\\"code\\\">41</code> at the\\n    keyboard, we get <code class=\\\"code\\\">42</code> as the final result.<br>\\n<br>\\n<h6 id=\\\"6_Introduction\\\">Introduction</h6><br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Functionalinputwithformatstrings\\\">Functional input with format strings</div><br>\\n<br>\\nThe module <code class=\\\"code\\\">Scanf</code> provides formatted input functions or <em>scanners</em>.\\n<p>\\n\\n    The formatted input functions can read from any kind of input, including\\n    strings, files, or anything that can return characters. The more general\\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>. The more general\\n    formatted input function reads from any scanning buffer and is named\\n    <code class=\\\"code\\\">bscanf</code>.\\n</p><p>\\n\\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\\n<li>the first argument is a source of characters for the input,</li>\\n<li>the second argument is a format string that specifies the values to\\n      read,</li>\\n<li>the third argument is a <em>receiver function</em> that is applied to the\\n      values read.</li>\\n</ul>\\n\\n    Hence, a typical call to the formatted input function <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a> is\\n    <code class=\\\"code\\\">bscanf ic fmt f</code>, where:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">fmt</code> is a format string (the same format strings as those used to print\\n    material with module <a href=\\\"Printf.html\\\"><code class=\\\"code\\\">Printf</code></a> or <a href=\\\"Format.html\\\"><code class=\\\"code\\\">Format</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">f</code> is a function that has as many arguments as the number of values to\\n    read in the input.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Asimpleexample\\\">A simple example</div><br>\\n<br>\\nAs suggested above, the expression <code class=\\\"code\\\">bscanf ic &quot;%d&quot; f</code> reads a decimal\\n    integer <code class=\\\"code\\\">n</code> from the source of characters <code class=\\\"code\\\">ic</code> and returns <code class=\\\"code\\\">f n</code>.\\n<p>\\n\\n    For instance,\\n</p><p>\\n</p><ul>\\n<li>if we use <code class=\\\"code\\\">stdin</code> as the source of characters (<a href=\\\"Scanf.Scanning.html#VALstdin\\\"><code class=\\\"code\\\">Scanf.Scanning.stdin</code></a> is\\n    the predefined formatted input channel that reads from standard input),</li>\\n</ul>\\n<ul>\\n<li>if we define the receiver <code class=\\\"code\\\">f</code> as <code class=\\\"code\\\">let f x = x + 1</code>,</li>\\n</ul>\\n\\n    then <code class=\\\"code\\\">bscanf Scanning.stdin &quot;%d&quot; f</code> reads an integer <code class=\\\"code\\\">n</code> from the\\n    standard input and returns <code class=\\\"code\\\">f n</code> (that is <code class=\\\"code\\\">n + 1</code>). Thus, if we\\n    evaluate <code class=\\\"code\\\">bscanf stdin &quot;%d&quot; f</code>, and then enter <code class=\\\"code\\\">41</code> at the\\n    keyboard, we get <code class=\\\"code\\\">42</code> as the final result.<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Formattedinputasafunctionalfeature\\\">Formatted input as a functional feature</div><br>\\n<br>\\n<h6 id=\\\"6_Introduction\\\">Introduction</h6><br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Functionalinputwithformatstrings\\\">Functional input with format strings</div><br>\\n<br>\\nThe module <code class=\\\"code\\\">Scanf</code> provides formatted input functions or <em>scanners</em>.\\n<p>\\n\\n    The formatted input functions can read from any kind of input, including\\n    strings, files, or anything that can return characters. The more general\\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>. The more general\\n    formatted input function reads from any scanning buffer and is named\\n    <code class=\\\"code\\\">bscanf</code>.\\n</p><p>\\n\\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\\n<li>the first argument is a source of characters for the input,</li>\\n<li>the second argument is a format string that specifies the values to\\n      read,</li>\\n<li>the third argument is a <em>receiver function</em> that is applied to the\\n      values read.</li>\\n</ul>\\n\\n    Hence, a typical call to the formatted input function <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a> is\\n    <code class=\\\"code\\\">bscanf ic fmt f</code>, where:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">fmt</code> is a format string (the same format strings as those used to print\\n    material with module <a href=\\\"Printf.html\\\"><code class=\\\"code\\\">Printf</code></a> or <a href=\\\"Format.html\\\"><code class=\\\"code\\\">Format</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">f</code> is a function that has as many arguments as the number of values to\\n    read in the input.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Asimpleexample\\\">A simple example</div><br>\\n<br>\\nAs suggested above, the expression <code class=\\\"code\\\">bscanf ic &quot;%d&quot; f</code> reads a decimal\\n    integer <code class=\\\"code\\\">n</code> from the source of characters <code class=\\\"code\\\">ic</code> and returns <code class=\\\"code\\\">f n</code>.\\n<p>\\n\\n    For instance,\\n</p><p>\\n</p><ul>\\n<li>if we use <code class=\\\"code\\\">stdin</code> as the source of characters (<a href=\\\"Scanf.Scanning.html#VALstdin\\\"><code class=\\\"code\\\">Scanf.Scanning.stdin</code></a> is\\n    the predefined formatted input channel that reads from standard input),</li>\\n</ul>\\n<ul>\\n<li>if we define the receiver <code class=\\\"code\\\">f</code> as <code class=\\\"code\\\">let f x = x + 1</code>,</li>\\n</ul>\\n\\n    then <code class=\\\"code\\\">bscanf Scanning.stdin &quot;%d&quot; f</code> reads an integer <code class=\\\"code\\\">n</code> from the\\n    standard input and returns <code class=\\\"code\\\">f n</code> (that is <code class=\\\"code\\\">n + 1</code>). Thus, if we\\n    evaluate <code class=\\\"code\\\">bscanf stdin &quot;%d&quot; f</code>, and then enter <code class=\\\"code\\\">41</code> at the\\n    keyboard, we get <code class=\\\"code\\\">42</code> as the final result.<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Formattedinputasafunctionalfeature\\\">Formatted input as a functional feature</div><br>\\n<br>\\nThe OCaml scanning facility is reminiscent of the corresponding C feature.\\n    However, it is also largely different, simpler, and yet more powerful:\\n    the formatted input functions are higher-order functionals and the\\n    parameter passing mechanism is just the regular function application not\\n    the variable assignment based mechanism which is typical for formatted\\n    input in imperative languages; the OCaml format strings also feature\\n    useful additions to easily define complex tokens; as expected within a\\n    functional programming language, the formatted input functions also\\n    support polymorphism, in particular arbitrary interaction with\\n    polymorphic user-defined scanners. Furthermore, the OCaml formatted input\\n    facility is fully type-checked at compile time.<br>\\n<br>\\n<h6 id=\\\"6_Introduction\\\">Introduction</h6><br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Functionalinputwithformatstrings\\\">Functional input with format strings</div><br>\\n<br>\\nThe module <code class=\\\"code\\\">Scanf</code> provides formatted input functions or <em>scanners</em>.\\n<p>\\n\\n    The formatted input functions can read from any kind of input, including\\n    strings, files, or anything that can return characters. The more general\\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>. The more general\\n    formatted input function reads from any scanning buffer and is named\\n    <code class=\\\"code\\\">bscanf</code>.\\n</p><p>\\n\\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\\n<li>the first argument is a source of characters for the input,</li>\\n<li>the second argument is a format string that specifies the values to\\n      read,</li>\\n<li>the third argument is a <em>receiver function</em> that is applied to the\\n      values read.</li>\\n</ul>\\n\\n    Hence, a typical call to the formatted input function <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a> is\\n    <code class=\\\"code\\\">bscanf ic fmt f</code>, where:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">fmt</code> is a format string (the same format strings as those used to print\\n    material with module <a href=\\\"Printf.html\\\"><code class=\\\"code\\\">Printf</code></a> or <a href=\\\"Format.html\\\"><code class=\\\"code\\\">Format</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">f</code> is a function that has as many arguments as the number of values to\\n    read in the input.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Asimpleexample\\\">A simple example</div><br>\\n<br>\\nAs suggested above, the expression <code class=\\\"code\\\">bscanf ic &quot;%d&quot; f</code> reads a decimal\\n    integer <code class=\\\"code\\\">n</code> from the source of characters <code class=\\\"code\\\">ic</code> and returns <code class=\\\"code\\\">f n</code>.\\n<p>\\n\\n    For instance,\\n</p><p>\\n</p><ul>\\n<li>if we use <code class=\\\"code\\\">stdin</code> as the source of characters (<a href=\\\"Scanf.Scanning.html#VALstdin\\\"><code class=\\\"code\\\">Scanf.Scanning.stdin</code></a> is\\n    the predefined formatted input channel that reads from standard input),</li>\\n</ul>\\n<ul>\\n<li>if we define the receiver <code class=\\\"code\\\">f</code> as <code class=\\\"code\\\">let f x = x + 1</code>,</li>\\n</ul>\\n\\n    then <code class=\\\"code\\\">bscanf Scanning.stdin &quot;%d&quot; f</code> reads an integer <code class=\\\"code\\\">n</code> from the\\n    standard input and returns <code class=\\\"code\\\">f n</code> (that is <code class=\\\"code\\\">n + 1</code>). Thus, if we\\n    evaluate <code class=\\\"code\\\">bscanf stdin &quot;%d&quot; f</code>, and then enter <code class=\\\"code\\\">41</code> at the\\n    keyboard, we get <code class=\\\"code\\\">42</code> as the final result.<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Formattedinputasafunctionalfeature\\\">Formatted input as a functional feature</div><br>\\n<br>\\nThe OCaml scanning facility is reminiscent of the corresponding C feature.\\n    However, it is also largely different, simpler, and yet more powerful:\\n    the formatted input functions are higher-order functionals and the\\n    parameter passing mechanism is just the regular function application not\\n    the variable assignment based mechanism which is typical for formatted\\n    input in imperative languages; the OCaml format strings also feature\\n    useful additions to easily define complex tokens; as expected within a\\n    functional programming language, the formatted input functions also\\n    support polymorphism, in particular arbitrary interaction with\\n    polymorphic user-defined scanners. Furthermore, the OCaml formatted input\\n    facility is fully type-checked at compile time.<br>\\n<br>\\n<h6 id=\\\"6_Formattedinputchannel\\\">Formatted input channel</h6><br>\\n\\n<pre><span class=\\\"keyword\\\">module</span> Scanning: sig .. end</pre><br>\\n<h6 id=\\\"6_Typeofformattedinputfunctions\\\">Type of formatted input functions</h6><br>\\n\\n<pre><span class=\\\"keyword\\\">type</span> scanner &apos;a &apos;b &apos;c &apos;d = Pervasives.format6 &apos;a Scanning.in_channel &apos;b &apos;c (&apos;a =&gt; &apos;d) &apos;d =&gt; &apos;c;\\n</pre>\\n<div class=\\\"info \\\">\\nThe type of formatted input scanners: <code class=\\\"code\\\">(&apos;a, &apos;b, &apos;c, &apos;d) scanner</code>\\n    is the type of a formatted input function that reads from some\\n    formatted input channel according to some format string; more\\n    precisely, if <code class=\\\"code\\\">scan</code> is some formatted input function, then <code class=\\\"code\\\">scan\\n    ic fmt f</code> applies <code class=\\\"code\\\">f</code> to the arguments specified by the format\\n    string <code class=\\\"code\\\">fmt</code>, when <code class=\\\"code\\\">scan</code> has read those arguments from the\\n    formatted input channel <code class=\\\"code\\\">ic</code>.\\n<p>\\n\\n    For instance, the <code class=\\\"code\\\">scanf</code> function below has type <code class=\\\"code\\\">(&apos;a, &apos;b, &apos;c, &apos;d)\\n    scanner</code>, since it is a formatted input function that reads from\\n    <code class=\\\"code\\\">Scanning.stdin</code>: <code class=\\\"code\\\">scanf fmt f</code> applies <code class=\\\"code\\\">f</code> to the arguments specified by\\n    <code class=\\\"code\\\">fmt</code>, reading those arguments from <code class=\\\"code\\\">Pervasives.stdin</code> as expected.\\n</p><p>\\n\\n    If the format <code class=\\\"code\\\">fmt</code> has some <code class=\\\"code\\\">%r</code> indications, the corresponding input\\n    functions must be provided before the receiver <code class=\\\"code\\\">f</code> argument. For\\n    instance, if <code class=\\\"code\\\">read_elem</code> is an input function for values of type <code class=\\\"code\\\">t</code>,\\n    then <code class=\\\"code\\\">bscanf ic &quot;%r;&quot; read_elem f</code> reads a value <code class=\\\"code\\\">v</code> of type <code class=\\\"code\\\">t</code> followed\\n    by a <code class=\\\"code\\\">&apos;;&apos;</code> character, and returns <code class=\\\"code\\\">f v</code>.<br>\\n<b>Since</b> 3.10.0<br>\\n</p></div>\\n\\n\\n<pre><span class=\\\"keyword\\\">exception</span> Scan_failure string;\\n</pre>\\n<div class=\\\"info \\\">\\nThe exception that formatted input functions raise when the input cannot\\n    be read according to the given format.<br>\\n</div>\\n<br>\\n<h6 id=\\\"6_Thegeneralformattedinputfunction\\\">The general formatted input function</h6><br>\\n\\n<pre><span class=\\\"keyword\\\">let</span> bscanf: Scanning.in_channel =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">bscanf ic fmt r1 ... rN f</code> reads arguments for the function <code class=\\\"code\\\">f</code>, from the\\n    formatted input channel <code class=\\\"code\\\">ic</code>, according to the format string <code class=\\\"code\\\">fmt</code>, and\\n    applies <code class=\\\"code\\\">f</code> to these values.\\n    The result of this call to <code class=\\\"code\\\">f</code> is returned as the result of the entire\\n    <code class=\\\"code\\\">bscanf</code> call.\\n    For instance, if <code class=\\\"code\\\">f</code> is the function <code class=\\\"code\\\">fun s i -&gt; i + 1</code>, then\\n    <code class=\\\"code\\\">Scanf.sscanf &quot;x=  1&quot; &quot;%s = %i&quot; f</code> returns <code class=\\\"code\\\">2</code>.\\n<p>\\n\\n    Arguments <code class=\\\"code\\\">r1</code> to <code class=\\\"code\\\">rN</code> are user-defined input functions that read the\\n    argument corresponding to the <code class=\\\"code\\\">%r</code> conversions specified in the format\\n    string.<br>\\n</p></div>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\nAs mentioned above, a plain character in the format string is just\\n    matched with the next character of the input; however, two characters are\\n    special exceptions to this rule: the space character (<code class=\\\"code\\\">&apos; &apos;</code> or ASCII code\\n    32) and the line feed character (<code class=\\\"code\\\">&apos;\\\\n&apos;</code> or ASCII code 10).\\n    A space does not match a single space character, but any amount of\\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\\n    string matches <em>any number</em> of tab, space, line feed and carriage\\n    return characters. Similarly, a line feed character in the format string\\n    matches either a single line feed or a carriage return followed by a line\\n    feed.\\n<p>\\n\\n    Matching <em>any</em> amount of whitespace, a space in the format string\\n    also matches no amount of whitespace at all; hence, the call <code class=\\\"code\\\">bscanf ib\\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class=\\\"code\\\">1</code> when reading an\\n    input with various whitespace in it, such as <code class=\\\"code\\\">Price = 1 $</code>,\\n    <code class=\\\"code\\\">Price  =  1    $</code>, or even <code class=\\\"code\\\">Price=1$</code>.<br>\\n<br>\\n</p><h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\nAs mentioned above, a plain character in the format string is just\\n    matched with the next character of the input; however, two characters are\\n    special exceptions to this rule: the space character (<code class=\\\"code\\\">&apos; &apos;</code> or ASCII code\\n    32) and the line feed character (<code class=\\\"code\\\">&apos;\\\\n&apos;</code> or ASCII code 10).\\n    A space does not match a single space character, but any amount of\\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\\n    string matches <em>any number</em> of tab, space, line feed and carriage\\n    return characters. Similarly, a line feed character in the format string\\n    matches either a single line feed or a carriage return followed by a line\\n    feed.\\n<p>\\n\\n    Matching <em>any</em> amount of whitespace, a space in the format string\\n    also matches no amount of whitespace at all; hence, the call <code class=\\\"code\\\">bscanf ib\\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class=\\\"code\\\">1</code> when reading an\\n    input with various whitespace in it, such as <code class=\\\"code\\\">Price = 1 $</code>,\\n    <code class=\\\"code\\\">Price  =  1    $</code>, or even <code class=\\\"code\\\">Price=1$</code>.<br>\\n<br>\\n</p><div class=\\\"h7\\\" id=\\\"conversion\\\">Conversion specifications in format strings</div><br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\nAs mentioned above, a plain character in the format string is just\\n    matched with the next character of the input; however, two characters are\\n    special exceptions to this rule: the space character (<code class=\\\"code\\\">&apos; &apos;</code> or ASCII code\\n    32) and the line feed character (<code class=\\\"code\\\">&apos;\\\\n&apos;</code> or ASCII code 10).\\n    A space does not match a single space character, but any amount of\\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\\n    string matches <em>any number</em> of tab, space, line feed and carriage\\n    return characters. Similarly, a line feed character in the format string\\n    matches either a single line feed or a carriage return followed by a line\\n    feed.\\n<p>\\n\\n    Matching <em>any</em> amount of whitespace, a space in the format string\\n    also matches no amount of whitespace at all; hence, the call <code class=\\\"code\\\">bscanf ib\\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class=\\\"code\\\">1</code> when reading an\\n    input with various whitespace in it, such as <code class=\\\"code\\\">Price = 1 $</code>,\\n    <code class=\\\"code\\\">Price  =  1    $</code>, or even <code class=\\\"code\\\">Price=1$</code>.<br>\\n<br>\\n</p><div class=\\\"h7\\\" id=\\\"conversion\\\">Conversion specifications in format strings</div><br>\\n<br>\\nConversion specifications consist in the <code class=\\\"code\\\">%</code> character, followed by\\n    an optional flag, an optional field width, and followed by one or\\n    two conversion characters. The conversion characters and their\\n    meanings are:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">d</code>: reads an optionally signed decimal integer.</li>\\n<li><code class=\\\"code\\\">i</code>: reads an optionally signed integer\\n      (usual input conventions for decimal (<code class=\\\"code\\\">0-9</code>+), hexadecimal\\n       (<code class=\\\"code\\\">0x[0-9a-f]+</code> and <code class=\\\"code\\\">0X[0-9A-F]+</code>), octal (<code class=\\\"code\\\">0o[0-7]+</code>), and binary\\n       (<code class=\\\"code\\\">0b[0-1]+</code>) notations are understood).</li>\\n<li><code class=\\\"code\\\">u</code>: reads an unsigned decimal integer.</li>\\n<li><code class=\\\"code\\\">x</code> or <code class=\\\"code\\\">X</code>: reads an unsigned hexadecimal integer (<code class=\\\"code\\\">[0-9a-fA-F]+</code>).</li>\\n<li><code class=\\\"code\\\">o</code>: reads an unsigned octal integer (<code class=\\\"code\\\">[0-7]+</code>).</li>\\n<li><code class=\\\"code\\\">s</code>: reads a string argument that spreads as much as possible, until the\\n      following bounding condition holds: <ul>\\n<li>a whitespace has been found (see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>a scanning indication (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>) has been\\n         encountered,</li>\\n<li>the end-of-input has been reached.</li>\\n</ul>\\n\\n      Hence, this conversion always succeeds: it returns an empty\\n      string if the bounding condition holds when the scan begins.</li>\\n<li><code class=\\\"code\\\">S</code>: reads a delimited string argument (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">c</code>: reads a single character. To test the current input character\\n      without reading it, specify a null field width, i.e. use\\n      specification <code class=\\\"code\\\">%0c</code>. Raise <code class=\\\"code\\\">Invalid_argument</code>, if the field width\\n      specification is greater than 1.</li>\\n<li><code class=\\\"code\\\">C</code>: reads a single delimited character (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">f</code>, <code class=\\\"code\\\">e</code>, <code class=\\\"code\\\">E</code>, <code class=\\\"code\\\">g</code>, <code class=\\\"code\\\">G</code>: reads an optionally signed\\n      floating-point number in decimal notation, in the style <code class=\\\"code\\\">dddd.ddd\\n      e/E+-dd</code>.</li>\\n<li><code class=\\\"code\\\">F</code>: reads a floating point number according to the lexical\\n      conventions of OCaml (hence the decimal point is mandatory if the\\n      exponent part is not mentioned).</li>\\n<li><code class=\\\"code\\\">B</code>: reads a boolean argument (<code class=\\\"code\\\">true</code> or <code class=\\\"code\\\">false</code>).</li>\\n<li><code class=\\\"code\\\">b</code>: reads a boolean argument (for backward compatibility; do not use\\n      in new programs).</li>\\n<li><code class=\\\"code\\\">ld</code>, <code class=\\\"code\\\">li</code>, <code class=\\\"code\\\">lu</code>, <code class=\\\"code\\\">lx</code>, <code class=\\\"code\\\">lX</code>, <code class=\\\"code\\\">lo</code>: reads an <code class=\\\"code\\\">int32</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">nd</code>, <code class=\\\"code\\\">ni</code>, <code class=\\\"code\\\">nu</code>, <code class=\\\"code\\\">nx</code>, <code class=\\\"code\\\">nX</code>, <code class=\\\"code\\\">no</code>: reads a <code class=\\\"code\\\">nativeint</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">Ld</code>, <code class=\\\"code\\\">Li</code>, <code class=\\\"code\\\">Lu</code>, <code class=\\\"code\\\">Lx</code>, <code class=\\\"code\\\">LX</code>, <code class=\\\"code\\\">Lo</code>: reads an <code class=\\\"code\\\">int64</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">[ range ]</code>: reads characters that matches one of the characters\\n      mentioned in the range of characters <code class=\\\"code\\\">range</code> (or not mentioned in\\n      it, if the range starts with <code class=\\\"code\\\">^</code>). Reads a <code class=\\\"code\\\">string</code> that can be\\n      empty, if the next input character does not match the range. The set of\\n      characters from <code class=\\\"code\\\">c1</code> to <code class=\\\"code\\\">c2</code> (inclusively) is denoted by <code class=\\\"code\\\">c1-c2</code>.\\n      Hence, <code class=\\\"code\\\">%[0-9]</code> returns a string representing a decimal number\\n      or an empty string if no decimal digit is found; similarly,\\n      <code class=\\\"code\\\">%[0-9a-f]</code> returns a string of hexadecimal digits.\\n      If a closing bracket appears in a range, it must occur as the\\n      first character of the range (or just after the <code class=\\\"code\\\">^</code> in case of\\n      range negation); hence <code class=\\\"code\\\">[]]</code> matches a <code class=\\\"code\\\">]</code> character and\\n      <code class=\\\"code\\\">[^]]</code> matches any character that is not <code class=\\\"code\\\">]</code>.\\n      Use <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code> to include a <code class=\\\"code\\\">%</code> or a <code class=\\\"code\\\">@</code> in a range.</li>\\n<li><code class=\\\"code\\\">r</code>: user-defined reader. Takes the next <code class=\\\"code\\\">ri</code> formatted input\\n      function and applies it to the scanning buffer <code class=\\\"code\\\">ib</code> to read the\\n      next argument. The input function <code class=\\\"code\\\">ri</code> must therefore have type\\n      <code class=\\\"code\\\">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class=\\\"code\\\">&apos;a</code>.</li>\\n<li><code class=\\\"code\\\">{ fmt %}</code>: reads a format string argument. The format string\\n      read must have the same type as the format string specification\\n      <code class=\\\"code\\\">fmt</code>. For instance, <code class=\\\"code\\\">&quot;%{ %i %}&quot;</code> reads any format string that\\n      can read a value of type <code class=\\\"code\\\">int</code>; hence, if <code class=\\\"code\\\">s</code> is the string\\n      <code class=\\\"code\\\">&quot;fmt:\\\\&quot;number is %u\\\\&quot;&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\\n      succeeds and returns the format string <code class=\\\"code\\\">&quot;number is %u&quot;</code>.</li>\\n<li><code class=\\\"code\\\">( fmt %)</code>: scanning sub-format substitution.\\n      Reads a format string <code class=\\\"code\\\">rf</code> in the input, then goes on scanning with\\n      <code class=\\\"code\\\">rf</code> instead of scanning with <code class=\\\"code\\\">fmt</code>.\\n      The format string <code class=\\\"code\\\">rf</code> must have the same type as the format string\\n      specification <code class=\\\"code\\\">fmt</code> that it replaces.\\n      For instance, <code class=\\\"code\\\">&quot;%( %i %)&quot;</code> reads any format string that can read a value\\n      of type <code class=\\\"code\\\">int</code>.\\n      The conversion returns the format string read <code class=\\\"code\\\">rf</code>, and then a value\\n      read using <code class=\\\"code\\\">rf</code>.\\n      Hence, if <code class=\\\"code\\\">s</code> is the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then\\n      <code class=\\\"code\\\">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\\n      <code class=\\\"code\\\">(&quot;%4d&quot;, 1234)</code>.\\n      This behaviour is not mere format substitution, since the conversion\\n      returns the format string read as additional argument. If you need\\n      pure format substitution, use special flag <code class=\\\"code\\\">_</code> to discard the\\n      extraneous argument: conversion <code class=\\\"code\\\">%_( fmt %)</code> reads a format string\\n      <code class=\\\"code\\\">rf</code> and then behaves the same as format string <code class=\\\"code\\\">rf</code>.  Hence, if <code class=\\\"code\\\">s</code> is\\n      the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\\n      simply equivalent to <code class=\\\"code\\\">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\\n<li><code class=\\\"code\\\">l</code>: returns the number of lines read so far.</li>\\n<li><code class=\\\"code\\\">n</code>: returns the number of characters read so far.</li>\\n<li><code class=\\\"code\\\">N</code> or <code class=\\\"code\\\">L</code>: returns the number of tokens read so far.</li>\\n<li><code class=\\\"code\\\">!</code>: matches the end of input condition.</li>\\n<li><code class=\\\"code\\\">%</code>: matches one <code class=\\\"code\\\">%</code> character in the input.</li>\\n<li><code class=\\\"code\\\">@</code>: matches one <code class=\\\"code\\\">@</code> character in the input.</li>\\n<li><code class=\\\"code\\\">,</code>: does nothing.</li>\\n</ul>\\n\\n    Following the <code class=\\\"code\\\">%</code> character that introduces a conversion, there may be\\n    the special flag <code class=\\\"code\\\">_</code>: the conversion that follows occurs as usual,\\n    but the resulting value is discarded.\\n    For instance, if <code class=\\\"code\\\">f</code> is the function <code class=\\\"code\\\">fun i -&gt; i + 1</code>, and <code class=\\\"code\\\">s</code> is the\\n    string <code class=\\\"code\\\">&quot;x = 1&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class=\\\"code\\\">2</code>.\\n<p>\\n\\n    The field width is composed of an optional integer literal\\n    indicating the maximal width of the token to read.\\n    For instance, <code class=\\\"code\\\">%6d</code> reads an integer, having at most 6 decimal digits;\\n    <code class=\\\"code\\\">%4f</code> reads a float with at most 4 characters; and <code class=\\\"code\\\">%8[\\\\000-\\\\255]</code>\\n    returns the next 8 characters (or all the characters still available,\\n    if fewer than 8 characters are available in the input).\\n</p><p>\\n\\n    Notes:\\n</p><p>\\n</p><ul>\\n<li>as mentioned above, a <code class=\\\"code\\\">%s</code> conversion always succeeds, even if there is\\n      nothing to read in the input: in this case, it simply returns <code class=\\\"code\\\">&quot;&quot;</code>.</li>\\n</ul>\\n<ul>\\n<li>in addition to the relevant digits, <code class=\\\"code\\\">&apos;_&apos;</code> characters may appear\\n    inside numbers (this is reminiscent to the usual OCaml lexical\\n    conventions). If stricter scanning is desired, use the range\\n    conversion facility instead of the number conversions.</li>\\n</ul>\\n<ul>\\n<li>the <code class=\\\"code\\\">scanf</code> facility is not intended for heavy duty lexical\\n    analysis and parsing. If it appears not expressive enough for your\\n    needs, several alternative exists: regular expressions (module\\n    <code class=\\\"code\\\">Str</code>), stream parsers, <code class=\\\"code\\\">ocamllex</code>-generated lexers,\\n    <code class=\\\"code\\\">ocamlyacc</code>-generated parsers.</li>\\n</ul>\\n<br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\nAs mentioned above, a plain character in the format string is just\\n    matched with the next character of the input; however, two characters are\\n    special exceptions to this rule: the space character (<code class=\\\"code\\\">&apos; &apos;</code> or ASCII code\\n    32) and the line feed character (<code class=\\\"code\\\">&apos;\\\\n&apos;</code> or ASCII code 10).\\n    A space does not match a single space character, but any amount of\\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\\n    string matches <em>any number</em> of tab, space, line feed and carriage\\n    return characters. Similarly, a line feed character in the format string\\n    matches either a single line feed or a carriage return followed by a line\\n    feed.\\n<p>\\n\\n    Matching <em>any</em> amount of whitespace, a space in the format string\\n    also matches no amount of whitespace at all; hence, the call <code class=\\\"code\\\">bscanf ib\\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class=\\\"code\\\">1</code> when reading an\\n    input with various whitespace in it, such as <code class=\\\"code\\\">Price = 1 $</code>,\\n    <code class=\\\"code\\\">Price  =  1    $</code>, or even <code class=\\\"code\\\">Price=1$</code>.<br>\\n<br>\\n</p><div class=\\\"h7\\\" id=\\\"conversion\\\">Conversion specifications in format strings</div><br>\\n<br>\\nConversion specifications consist in the <code class=\\\"code\\\">%</code> character, followed by\\n    an optional flag, an optional field width, and followed by one or\\n    two conversion characters. The conversion characters and their\\n    meanings are:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">d</code>: reads an optionally signed decimal integer.</li>\\n<li><code class=\\\"code\\\">i</code>: reads an optionally signed integer\\n      (usual input conventions for decimal (<code class=\\\"code\\\">0-9</code>+), hexadecimal\\n       (<code class=\\\"code\\\">0x[0-9a-f]+</code> and <code class=\\\"code\\\">0X[0-9A-F]+</code>), octal (<code class=\\\"code\\\">0o[0-7]+</code>), and binary\\n       (<code class=\\\"code\\\">0b[0-1]+</code>) notations are understood).</li>\\n<li><code class=\\\"code\\\">u</code>: reads an unsigned decimal integer.</li>\\n<li><code class=\\\"code\\\">x</code> or <code class=\\\"code\\\">X</code>: reads an unsigned hexadecimal integer (<code class=\\\"code\\\">[0-9a-fA-F]+</code>).</li>\\n<li><code class=\\\"code\\\">o</code>: reads an unsigned octal integer (<code class=\\\"code\\\">[0-7]+</code>).</li>\\n<li><code class=\\\"code\\\">s</code>: reads a string argument that spreads as much as possible, until the\\n      following bounding condition holds: <ul>\\n<li>a whitespace has been found (see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>a scanning indication (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>) has been\\n         encountered,</li>\\n<li>the end-of-input has been reached.</li>\\n</ul>\\n\\n      Hence, this conversion always succeeds: it returns an empty\\n      string if the bounding condition holds when the scan begins.</li>\\n<li><code class=\\\"code\\\">S</code>: reads a delimited string argument (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">c</code>: reads a single character. To test the current input character\\n      without reading it, specify a null field width, i.e. use\\n      specification <code class=\\\"code\\\">%0c</code>. Raise <code class=\\\"code\\\">Invalid_argument</code>, if the field width\\n      specification is greater than 1.</li>\\n<li><code class=\\\"code\\\">C</code>: reads a single delimited character (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">f</code>, <code class=\\\"code\\\">e</code>, <code class=\\\"code\\\">E</code>, <code class=\\\"code\\\">g</code>, <code class=\\\"code\\\">G</code>: reads an optionally signed\\n      floating-point number in decimal notation, in the style <code class=\\\"code\\\">dddd.ddd\\n      e/E+-dd</code>.</li>\\n<li><code class=\\\"code\\\">F</code>: reads a floating point number according to the lexical\\n      conventions of OCaml (hence the decimal point is mandatory if the\\n      exponent part is not mentioned).</li>\\n<li><code class=\\\"code\\\">B</code>: reads a boolean argument (<code class=\\\"code\\\">true</code> or <code class=\\\"code\\\">false</code>).</li>\\n<li><code class=\\\"code\\\">b</code>: reads a boolean argument (for backward compatibility; do not use\\n      in new programs).</li>\\n<li><code class=\\\"code\\\">ld</code>, <code class=\\\"code\\\">li</code>, <code class=\\\"code\\\">lu</code>, <code class=\\\"code\\\">lx</code>, <code class=\\\"code\\\">lX</code>, <code class=\\\"code\\\">lo</code>: reads an <code class=\\\"code\\\">int32</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">nd</code>, <code class=\\\"code\\\">ni</code>, <code class=\\\"code\\\">nu</code>, <code class=\\\"code\\\">nx</code>, <code class=\\\"code\\\">nX</code>, <code class=\\\"code\\\">no</code>: reads a <code class=\\\"code\\\">nativeint</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">Ld</code>, <code class=\\\"code\\\">Li</code>, <code class=\\\"code\\\">Lu</code>, <code class=\\\"code\\\">Lx</code>, <code class=\\\"code\\\">LX</code>, <code class=\\\"code\\\">Lo</code>: reads an <code class=\\\"code\\\">int64</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">[ range ]</code>: reads characters that matches one of the characters\\n      mentioned in the range of characters <code class=\\\"code\\\">range</code> (or not mentioned in\\n      it, if the range starts with <code class=\\\"code\\\">^</code>). Reads a <code class=\\\"code\\\">string</code> that can be\\n      empty, if the next input character does not match the range. The set of\\n      characters from <code class=\\\"code\\\">c1</code> to <code class=\\\"code\\\">c2</code> (inclusively) is denoted by <code class=\\\"code\\\">c1-c2</code>.\\n      Hence, <code class=\\\"code\\\">%[0-9]</code> returns a string representing a decimal number\\n      or an empty string if no decimal digit is found; similarly,\\n      <code class=\\\"code\\\">%[0-9a-f]</code> returns a string of hexadecimal digits.\\n      If a closing bracket appears in a range, it must occur as the\\n      first character of the range (or just after the <code class=\\\"code\\\">^</code> in case of\\n      range negation); hence <code class=\\\"code\\\">[]]</code> matches a <code class=\\\"code\\\">]</code> character and\\n      <code class=\\\"code\\\">[^]]</code> matches any character that is not <code class=\\\"code\\\">]</code>.\\n      Use <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code> to include a <code class=\\\"code\\\">%</code> or a <code class=\\\"code\\\">@</code> in a range.</li>\\n<li><code class=\\\"code\\\">r</code>: user-defined reader. Takes the next <code class=\\\"code\\\">ri</code> formatted input\\n      function and applies it to the scanning buffer <code class=\\\"code\\\">ib</code> to read the\\n      next argument. The input function <code class=\\\"code\\\">ri</code> must therefore have type\\n      <code class=\\\"code\\\">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class=\\\"code\\\">&apos;a</code>.</li>\\n<li><code class=\\\"code\\\">{ fmt %}</code>: reads a format string argument. The format string\\n      read must have the same type as the format string specification\\n      <code class=\\\"code\\\">fmt</code>. For instance, <code class=\\\"code\\\">&quot;%{ %i %}&quot;</code> reads any format string that\\n      can read a value of type <code class=\\\"code\\\">int</code>; hence, if <code class=\\\"code\\\">s</code> is the string\\n      <code class=\\\"code\\\">&quot;fmt:\\\\&quot;number is %u\\\\&quot;&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\\n      succeeds and returns the format string <code class=\\\"code\\\">&quot;number is %u&quot;</code>.</li>\\n<li><code class=\\\"code\\\">( fmt %)</code>: scanning sub-format substitution.\\n      Reads a format string <code class=\\\"code\\\">rf</code> in the input, then goes on scanning with\\n      <code class=\\\"code\\\">rf</code> instead of scanning with <code class=\\\"code\\\">fmt</code>.\\n      The format string <code class=\\\"code\\\">rf</code> must have the same type as the format string\\n      specification <code class=\\\"code\\\">fmt</code> that it replaces.\\n      For instance, <code class=\\\"code\\\">&quot;%( %i %)&quot;</code> reads any format string that can read a value\\n      of type <code class=\\\"code\\\">int</code>.\\n      The conversion returns the format string read <code class=\\\"code\\\">rf</code>, and then a value\\n      read using <code class=\\\"code\\\">rf</code>.\\n      Hence, if <code class=\\\"code\\\">s</code> is the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then\\n      <code class=\\\"code\\\">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\\n      <code class=\\\"code\\\">(&quot;%4d&quot;, 1234)</code>.\\n      This behaviour is not mere format substitution, since the conversion\\n      returns the format string read as additional argument. If you need\\n      pure format substitution, use special flag <code class=\\\"code\\\">_</code> to discard the\\n      extraneous argument: conversion <code class=\\\"code\\\">%_( fmt %)</code> reads a format string\\n      <code class=\\\"code\\\">rf</code> and then behaves the same as format string <code class=\\\"code\\\">rf</code>.  Hence, if <code class=\\\"code\\\">s</code> is\\n      the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\\n      simply equivalent to <code class=\\\"code\\\">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\\n<li><code class=\\\"code\\\">l</code>: returns the number of lines read so far.</li>\\n<li><code class=\\\"code\\\">n</code>: returns the number of characters read so far.</li>\\n<li><code class=\\\"code\\\">N</code> or <code class=\\\"code\\\">L</code>: returns the number of tokens read so far.</li>\\n<li><code class=\\\"code\\\">!</code>: matches the end of input condition.</li>\\n<li><code class=\\\"code\\\">%</code>: matches one <code class=\\\"code\\\">%</code> character in the input.</li>\\n<li><code class=\\\"code\\\">@</code>: matches one <code class=\\\"code\\\">@</code> character in the input.</li>\\n<li><code class=\\\"code\\\">,</code>: does nothing.</li>\\n</ul>\\n\\n    Following the <code class=\\\"code\\\">%</code> character that introduces a conversion, there may be\\n    the special flag <code class=\\\"code\\\">_</code>: the conversion that follows occurs as usual,\\n    but the resulting value is discarded.\\n    For instance, if <code class=\\\"code\\\">f</code> is the function <code class=\\\"code\\\">fun i -&gt; i + 1</code>, and <code class=\\\"code\\\">s</code> is the\\n    string <code class=\\\"code\\\">&quot;x = 1&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class=\\\"code\\\">2</code>.\\n<p>\\n\\n    The field width is composed of an optional integer literal\\n    indicating the maximal width of the token to read.\\n    For instance, <code class=\\\"code\\\">%6d</code> reads an integer, having at most 6 decimal digits;\\n    <code class=\\\"code\\\">%4f</code> reads a float with at most 4 characters; and <code class=\\\"code\\\">%8[\\\\000-\\\\255]</code>\\n    returns the next 8 characters (or all the characters still available,\\n    if fewer than 8 characters are available in the input).\\n</p><p>\\n\\n    Notes:\\n</p><p>\\n</p><ul>\\n<li>as mentioned above, a <code class=\\\"code\\\">%s</code> conversion always succeeds, even if there is\\n      nothing to read in the input: in this case, it simply returns <code class=\\\"code\\\">&quot;&quot;</code>.</li>\\n</ul>\\n<ul>\\n<li>in addition to the relevant digits, <code class=\\\"code\\\">&apos;_&apos;</code> characters may appear\\n    inside numbers (this is reminiscent to the usual OCaml lexical\\n    conventions). If stricter scanning is desired, use the range\\n    conversion facility instead of the number conversions.</li>\\n</ul>\\n<ul>\\n<li>the <code class=\\\"code\\\">scanf</code> facility is not intended for heavy duty lexical\\n    analysis and parsing. If it appears not expressive enough for your\\n    needs, several alternative exists: regular expressions (module\\n    <code class=\\\"code\\\">Str</code>), stream parsers, <code class=\\\"code\\\">ocamllex</code>-generated lexers,\\n    <code class=\\\"code\\\">ocamlyacc</code>-generated parsers.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"indication\\\">Scanning indications in format strings</div><br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\nAs mentioned above, a plain character in the format string is just\\n    matched with the next character of the input; however, two characters are\\n    special exceptions to this rule: the space character (<code class=\\\"code\\\">&apos; &apos;</code> or ASCII code\\n    32) and the line feed character (<code class=\\\"code\\\">&apos;\\\\n&apos;</code> or ASCII code 10).\\n    A space does not match a single space character, but any amount of\\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\\n    string matches <em>any number</em> of tab, space, line feed and carriage\\n    return characters. Similarly, a line feed character in the format string\\n    matches either a single line feed or a carriage return followed by a line\\n    feed.\\n<p>\\n\\n    Matching <em>any</em> amount of whitespace, a space in the format string\\n    also matches no amount of whitespace at all; hence, the call <code class=\\\"code\\\">bscanf ib\\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class=\\\"code\\\">1</code> when reading an\\n    input with various whitespace in it, such as <code class=\\\"code\\\">Price = 1 $</code>,\\n    <code class=\\\"code\\\">Price  =  1    $</code>, or even <code class=\\\"code\\\">Price=1$</code>.<br>\\n<br>\\n</p><div class=\\\"h7\\\" id=\\\"conversion\\\">Conversion specifications in format strings</div><br>\\n<br>\\nConversion specifications consist in the <code class=\\\"code\\\">%</code> character, followed by\\n    an optional flag, an optional field width, and followed by one or\\n    two conversion characters. The conversion characters and their\\n    meanings are:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">d</code>: reads an optionally signed decimal integer.</li>\\n<li><code class=\\\"code\\\">i</code>: reads an optionally signed integer\\n      (usual input conventions for decimal (<code class=\\\"code\\\">0-9</code>+), hexadecimal\\n       (<code class=\\\"code\\\">0x[0-9a-f]+</code> and <code class=\\\"code\\\">0X[0-9A-F]+</code>), octal (<code class=\\\"code\\\">0o[0-7]+</code>), and binary\\n       (<code class=\\\"code\\\">0b[0-1]+</code>) notations are understood).</li>\\n<li><code class=\\\"code\\\">u</code>: reads an unsigned decimal integer.</li>\\n<li><code class=\\\"code\\\">x</code> or <code class=\\\"code\\\">X</code>: reads an unsigned hexadecimal integer (<code class=\\\"code\\\">[0-9a-fA-F]+</code>).</li>\\n<li><code class=\\\"code\\\">o</code>: reads an unsigned octal integer (<code class=\\\"code\\\">[0-7]+</code>).</li>\\n<li><code class=\\\"code\\\">s</code>: reads a string argument that spreads as much as possible, until the\\n      following bounding condition holds: <ul>\\n<li>a whitespace has been found (see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>a scanning indication (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>) has been\\n         encountered,</li>\\n<li>the end-of-input has been reached.</li>\\n</ul>\\n\\n      Hence, this conversion always succeeds: it returns an empty\\n      string if the bounding condition holds when the scan begins.</li>\\n<li><code class=\\\"code\\\">S</code>: reads a delimited string argument (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">c</code>: reads a single character. To test the current input character\\n      without reading it, specify a null field width, i.e. use\\n      specification <code class=\\\"code\\\">%0c</code>. Raise <code class=\\\"code\\\">Invalid_argument</code>, if the field width\\n      specification is greater than 1.</li>\\n<li><code class=\\\"code\\\">C</code>: reads a single delimited character (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">f</code>, <code class=\\\"code\\\">e</code>, <code class=\\\"code\\\">E</code>, <code class=\\\"code\\\">g</code>, <code class=\\\"code\\\">G</code>: reads an optionally signed\\n      floating-point number in decimal notation, in the style <code class=\\\"code\\\">dddd.ddd\\n      e/E+-dd</code>.</li>\\n<li><code class=\\\"code\\\">F</code>: reads a floating point number according to the lexical\\n      conventions of OCaml (hence the decimal point is mandatory if the\\n      exponent part is not mentioned).</li>\\n<li><code class=\\\"code\\\">B</code>: reads a boolean argument (<code class=\\\"code\\\">true</code> or <code class=\\\"code\\\">false</code>).</li>\\n<li><code class=\\\"code\\\">b</code>: reads a boolean argument (for backward compatibility; do not use\\n      in new programs).</li>\\n<li><code class=\\\"code\\\">ld</code>, <code class=\\\"code\\\">li</code>, <code class=\\\"code\\\">lu</code>, <code class=\\\"code\\\">lx</code>, <code class=\\\"code\\\">lX</code>, <code class=\\\"code\\\">lo</code>: reads an <code class=\\\"code\\\">int32</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">nd</code>, <code class=\\\"code\\\">ni</code>, <code class=\\\"code\\\">nu</code>, <code class=\\\"code\\\">nx</code>, <code class=\\\"code\\\">nX</code>, <code class=\\\"code\\\">no</code>: reads a <code class=\\\"code\\\">nativeint</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">Ld</code>, <code class=\\\"code\\\">Li</code>, <code class=\\\"code\\\">Lu</code>, <code class=\\\"code\\\">Lx</code>, <code class=\\\"code\\\">LX</code>, <code class=\\\"code\\\">Lo</code>: reads an <code class=\\\"code\\\">int64</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">[ range ]</code>: reads characters that matches one of the characters\\n      mentioned in the range of characters <code class=\\\"code\\\">range</code> (or not mentioned in\\n      it, if the range starts with <code class=\\\"code\\\">^</code>). Reads a <code class=\\\"code\\\">string</code> that can be\\n      empty, if the next input character does not match the range. The set of\\n      characters from <code class=\\\"code\\\">c1</code> to <code class=\\\"code\\\">c2</code> (inclusively) is denoted by <code class=\\\"code\\\">c1-c2</code>.\\n      Hence, <code class=\\\"code\\\">%[0-9]</code> returns a string representing a decimal number\\n      or an empty string if no decimal digit is found; similarly,\\n      <code class=\\\"code\\\">%[0-9a-f]</code> returns a string of hexadecimal digits.\\n      If a closing bracket appears in a range, it must occur as the\\n      first character of the range (or just after the <code class=\\\"code\\\">^</code> in case of\\n      range negation); hence <code class=\\\"code\\\">[]]</code> matches a <code class=\\\"code\\\">]</code> character and\\n      <code class=\\\"code\\\">[^]]</code> matches any character that is not <code class=\\\"code\\\">]</code>.\\n      Use <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code> to include a <code class=\\\"code\\\">%</code> or a <code class=\\\"code\\\">@</code> in a range.</li>\\n<li><code class=\\\"code\\\">r</code>: user-defined reader. Takes the next <code class=\\\"code\\\">ri</code> formatted input\\n      function and applies it to the scanning buffer <code class=\\\"code\\\">ib</code> to read the\\n      next argument. The input function <code class=\\\"code\\\">ri</code> must therefore have type\\n      <code class=\\\"code\\\">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class=\\\"code\\\">&apos;a</code>.</li>\\n<li><code class=\\\"code\\\">{ fmt %}</code>: reads a format string argument. The format string\\n      read must have the same type as the format string specification\\n      <code class=\\\"code\\\">fmt</code>. For instance, <code class=\\\"code\\\">&quot;%{ %i %}&quot;</code> reads any format string that\\n      can read a value of type <code class=\\\"code\\\">int</code>; hence, if <code class=\\\"code\\\">s</code> is the string\\n      <code class=\\\"code\\\">&quot;fmt:\\\\&quot;number is %u\\\\&quot;&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\\n      succeeds and returns the format string <code class=\\\"code\\\">&quot;number is %u&quot;</code>.</li>\\n<li><code class=\\\"code\\\">( fmt %)</code>: scanning sub-format substitution.\\n      Reads a format string <code class=\\\"code\\\">rf</code> in the input, then goes on scanning with\\n      <code class=\\\"code\\\">rf</code> instead of scanning with <code class=\\\"code\\\">fmt</code>.\\n      The format string <code class=\\\"code\\\">rf</code> must have the same type as the format string\\n      specification <code class=\\\"code\\\">fmt</code> that it replaces.\\n      For instance, <code class=\\\"code\\\">&quot;%( %i %)&quot;</code> reads any format string that can read a value\\n      of type <code class=\\\"code\\\">int</code>.\\n      The conversion returns the format string read <code class=\\\"code\\\">rf</code>, and then a value\\n      read using <code class=\\\"code\\\">rf</code>.\\n      Hence, if <code class=\\\"code\\\">s</code> is the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then\\n      <code class=\\\"code\\\">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\\n      <code class=\\\"code\\\">(&quot;%4d&quot;, 1234)</code>.\\n      This behaviour is not mere format substitution, since the conversion\\n      returns the format string read as additional argument. If you need\\n      pure format substitution, use special flag <code class=\\\"code\\\">_</code> to discard the\\n      extraneous argument: conversion <code class=\\\"code\\\">%_( fmt %)</code> reads a format string\\n      <code class=\\\"code\\\">rf</code> and then behaves the same as format string <code class=\\\"code\\\">rf</code>.  Hence, if <code class=\\\"code\\\">s</code> is\\n      the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\\n      simply equivalent to <code class=\\\"code\\\">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\\n<li><code class=\\\"code\\\">l</code>: returns the number of lines read so far.</li>\\n<li><code class=\\\"code\\\">n</code>: returns the number of characters read so far.</li>\\n<li><code class=\\\"code\\\">N</code> or <code class=\\\"code\\\">L</code>: returns the number of tokens read so far.</li>\\n<li><code class=\\\"code\\\">!</code>: matches the end of input condition.</li>\\n<li><code class=\\\"code\\\">%</code>: matches one <code class=\\\"code\\\">%</code> character in the input.</li>\\n<li><code class=\\\"code\\\">@</code>: matches one <code class=\\\"code\\\">@</code> character in the input.</li>\\n<li><code class=\\\"code\\\">,</code>: does nothing.</li>\\n</ul>\\n\\n    Following the <code class=\\\"code\\\">%</code> character that introduces a conversion, there may be\\n    the special flag <code class=\\\"code\\\">_</code>: the conversion that follows occurs as usual,\\n    but the resulting value is discarded.\\n    For instance, if <code class=\\\"code\\\">f</code> is the function <code class=\\\"code\\\">fun i -&gt; i + 1</code>, and <code class=\\\"code\\\">s</code> is the\\n    string <code class=\\\"code\\\">&quot;x = 1&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class=\\\"code\\\">2</code>.\\n<p>\\n\\n    The field width is composed of an optional integer literal\\n    indicating the maximal width of the token to read.\\n    For instance, <code class=\\\"code\\\">%6d</code> reads an integer, having at most 6 decimal digits;\\n    <code class=\\\"code\\\">%4f</code> reads a float with at most 4 characters; and <code class=\\\"code\\\">%8[\\\\000-\\\\255]</code>\\n    returns the next 8 characters (or all the characters still available,\\n    if fewer than 8 characters are available in the input).\\n</p><p>\\n\\n    Notes:\\n</p><p>\\n</p><ul>\\n<li>as mentioned above, a <code class=\\\"code\\\">%s</code> conversion always succeeds, even if there is\\n      nothing to read in the input: in this case, it simply returns <code class=\\\"code\\\">&quot;&quot;</code>.</li>\\n</ul>\\n<ul>\\n<li>in addition to the relevant digits, <code class=\\\"code\\\">&apos;_&apos;</code> characters may appear\\n    inside numbers (this is reminiscent to the usual OCaml lexical\\n    conventions). If stricter scanning is desired, use the range\\n    conversion facility instead of the number conversions.</li>\\n</ul>\\n<ul>\\n<li>the <code class=\\\"code\\\">scanf</code> facility is not intended for heavy duty lexical\\n    analysis and parsing. If it appears not expressive enough for your\\n    needs, several alternative exists: regular expressions (module\\n    <code class=\\\"code\\\">Str</code>), stream parsers, <code class=\\\"code\\\">ocamllex</code>-generated lexers,\\n    <code class=\\\"code\\\">ocamlyacc</code>-generated parsers.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"indication\\\">Scanning indications in format strings</div><br>\\n<br>\\nScanning indications appear just after the string conversions <code class=\\\"code\\\">%s</code>\\n    and <code class=\\\"code\\\">%[ range ]</code> to delimit the end of the token. A scanning\\n    indication is introduced by a <code class=\\\"code\\\">@</code> character, followed by some\\n    plain character <code class=\\\"code\\\">c</code>. It means that the string token should end\\n    just before the next matching <code class=\\\"code\\\">c</code> (which is skipped). If no <code class=\\\"code\\\">c</code>\\n    character is encountered, the string token spreads as much as\\n    possible. For instance, <code class=\\\"code\\\">&quot;%s@\\\\t&quot;</code> reads a string up to the next\\n    tab character or to the end of input. If a <code class=\\\"code\\\">@</code> character appears\\n    anywhere else in the format string, it is treated as a plain character.\\n<p>\\n\\n    Note:\\n</p><p>\\n</p><ul>\\n<li>As usual in format strings, <code class=\\\"code\\\">%</code> and <code class=\\\"code\\\">@</code> characters must be escaped\\n    using <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code>; this rule still holds within range specifications\\n    and scanning indications.\\n    For instance, <code class=\\\"code\\\">&quot;%s@%%&quot;</code> reads a string up to the next <code class=\\\"code\\\">%</code> character.</li>\\n<li>The scanning indications introduce slight differences in the syntax of\\n    <code class=\\\"code\\\">Scanf</code> format strings, compared to those used for the <code class=\\\"code\\\">Printf</code>\\n    module. However, the scanning indications are similar to those used in\\n    the <code class=\\\"code\\\">Format</code> module; hence, when producing formatted text to be scanned\\n    by <code class=\\\"code\\\">!Scanf.bscanf</code>, it is wise to use printing functions from the\\n    <code class=\\\"code\\\">Format</code> module (or, if you need to use functions from <code class=\\\"code\\\">Printf</code>, banish\\n    or carefully double check the format strings that contain <code class=\\\"code\\\">&apos;@&apos;</code>\\n    characters).</li>\\n</ul>\\n<br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\nAs mentioned above, a plain character in the format string is just\\n    matched with the next character of the input; however, two characters are\\n    special exceptions to this rule: the space character (<code class=\\\"code\\\">&apos; &apos;</code> or ASCII code\\n    32) and the line feed character (<code class=\\\"code\\\">&apos;\\\\n&apos;</code> or ASCII code 10).\\n    A space does not match a single space character, but any amount of\\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\\n    string matches <em>any number</em> of tab, space, line feed and carriage\\n    return characters. Similarly, a line feed character in the format string\\n    matches either a single line feed or a carriage return followed by a line\\n    feed.\\n<p>\\n\\n    Matching <em>any</em> amount of whitespace, a space in the format string\\n    also matches no amount of whitespace at all; hence, the call <code class=\\\"code\\\">bscanf ib\\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class=\\\"code\\\">1</code> when reading an\\n    input with various whitespace in it, such as <code class=\\\"code\\\">Price = 1 $</code>,\\n    <code class=\\\"code\\\">Price  =  1    $</code>, or even <code class=\\\"code\\\">Price=1$</code>.<br>\\n<br>\\n</p><div class=\\\"h7\\\" id=\\\"conversion\\\">Conversion specifications in format strings</div><br>\\n<br>\\nConversion specifications consist in the <code class=\\\"code\\\">%</code> character, followed by\\n    an optional flag, an optional field width, and followed by one or\\n    two conversion characters. The conversion characters and their\\n    meanings are:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">d</code>: reads an optionally signed decimal integer.</li>\\n<li><code class=\\\"code\\\">i</code>: reads an optionally signed integer\\n      (usual input conventions for decimal (<code class=\\\"code\\\">0-9</code>+), hexadecimal\\n       (<code class=\\\"code\\\">0x[0-9a-f]+</code> and <code class=\\\"code\\\">0X[0-9A-F]+</code>), octal (<code class=\\\"code\\\">0o[0-7]+</code>), and binary\\n       (<code class=\\\"code\\\">0b[0-1]+</code>) notations are understood).</li>\\n<li><code class=\\\"code\\\">u</code>: reads an unsigned decimal integer.</li>\\n<li><code class=\\\"code\\\">x</code> or <code class=\\\"code\\\">X</code>: reads an unsigned hexadecimal integer (<code class=\\\"code\\\">[0-9a-fA-F]+</code>).</li>\\n<li><code class=\\\"code\\\">o</code>: reads an unsigned octal integer (<code class=\\\"code\\\">[0-7]+</code>).</li>\\n<li><code class=\\\"code\\\">s</code>: reads a string argument that spreads as much as possible, until the\\n      following bounding condition holds: <ul>\\n<li>a whitespace has been found (see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>a scanning indication (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>) has been\\n         encountered,</li>\\n<li>the end-of-input has been reached.</li>\\n</ul>\\n\\n      Hence, this conversion always succeeds: it returns an empty\\n      string if the bounding condition holds when the scan begins.</li>\\n<li><code class=\\\"code\\\">S</code>: reads a delimited string argument (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">c</code>: reads a single character. To test the current input character\\n      without reading it, specify a null field width, i.e. use\\n      specification <code class=\\\"code\\\">%0c</code>. Raise <code class=\\\"code\\\">Invalid_argument</code>, if the field width\\n      specification is greater than 1.</li>\\n<li><code class=\\\"code\\\">C</code>: reads a single delimited character (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">f</code>, <code class=\\\"code\\\">e</code>, <code class=\\\"code\\\">E</code>, <code class=\\\"code\\\">g</code>, <code class=\\\"code\\\">G</code>: reads an optionally signed\\n      floating-point number in decimal notation, in the style <code class=\\\"code\\\">dddd.ddd\\n      e/E+-dd</code>.</li>\\n<li><code class=\\\"code\\\">F</code>: reads a floating point number according to the lexical\\n      conventions of OCaml (hence the decimal point is mandatory if the\\n      exponent part is not mentioned).</li>\\n<li><code class=\\\"code\\\">B</code>: reads a boolean argument (<code class=\\\"code\\\">true</code> or <code class=\\\"code\\\">false</code>).</li>\\n<li><code class=\\\"code\\\">b</code>: reads a boolean argument (for backward compatibility; do not use\\n      in new programs).</li>\\n<li><code class=\\\"code\\\">ld</code>, <code class=\\\"code\\\">li</code>, <code class=\\\"code\\\">lu</code>, <code class=\\\"code\\\">lx</code>, <code class=\\\"code\\\">lX</code>, <code class=\\\"code\\\">lo</code>: reads an <code class=\\\"code\\\">int32</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">nd</code>, <code class=\\\"code\\\">ni</code>, <code class=\\\"code\\\">nu</code>, <code class=\\\"code\\\">nx</code>, <code class=\\\"code\\\">nX</code>, <code class=\\\"code\\\">no</code>: reads a <code class=\\\"code\\\">nativeint</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">Ld</code>, <code class=\\\"code\\\">Li</code>, <code class=\\\"code\\\">Lu</code>, <code class=\\\"code\\\">Lx</code>, <code class=\\\"code\\\">LX</code>, <code class=\\\"code\\\">Lo</code>: reads an <code class=\\\"code\\\">int64</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">[ range ]</code>: reads characters that matches one of the characters\\n      mentioned in the range of characters <code class=\\\"code\\\">range</code> (or not mentioned in\\n      it, if the range starts with <code class=\\\"code\\\">^</code>). Reads a <code class=\\\"code\\\">string</code> that can be\\n      empty, if the next input character does not match the range. The set of\\n      characters from <code class=\\\"code\\\">c1</code> to <code class=\\\"code\\\">c2</code> (inclusively) is denoted by <code class=\\\"code\\\">c1-c2</code>.\\n      Hence, <code class=\\\"code\\\">%[0-9]</code> returns a string representing a decimal number\\n      or an empty string if no decimal digit is found; similarly,\\n      <code class=\\\"code\\\">%[0-9a-f]</code> returns a string of hexadecimal digits.\\n      If a closing bracket appears in a range, it must occur as the\\n      first character of the range (or just after the <code class=\\\"code\\\">^</code> in case of\\n      range negation); hence <code class=\\\"code\\\">[]]</code> matches a <code class=\\\"code\\\">]</code> character and\\n      <code class=\\\"code\\\">[^]]</code> matches any character that is not <code class=\\\"code\\\">]</code>.\\n      Use <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code> to include a <code class=\\\"code\\\">%</code> or a <code class=\\\"code\\\">@</code> in a range.</li>\\n<li><code class=\\\"code\\\">r</code>: user-defined reader. Takes the next <code class=\\\"code\\\">ri</code> formatted input\\n      function and applies it to the scanning buffer <code class=\\\"code\\\">ib</code> to read the\\n      next argument. The input function <code class=\\\"code\\\">ri</code> must therefore have type\\n      <code class=\\\"code\\\">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class=\\\"code\\\">&apos;a</code>.</li>\\n<li><code class=\\\"code\\\">{ fmt %}</code>: reads a format string argument. The format string\\n      read must have the same type as the format string specification\\n      <code class=\\\"code\\\">fmt</code>. For instance, <code class=\\\"code\\\">&quot;%{ %i %}&quot;</code> reads any format string that\\n      can read a value of type <code class=\\\"code\\\">int</code>; hence, if <code class=\\\"code\\\">s</code> is the string\\n      <code class=\\\"code\\\">&quot;fmt:\\\\&quot;number is %u\\\\&quot;&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\\n      succeeds and returns the format string <code class=\\\"code\\\">&quot;number is %u&quot;</code>.</li>\\n<li><code class=\\\"code\\\">( fmt %)</code>: scanning sub-format substitution.\\n      Reads a format string <code class=\\\"code\\\">rf</code> in the input, then goes on scanning with\\n      <code class=\\\"code\\\">rf</code> instead of scanning with <code class=\\\"code\\\">fmt</code>.\\n      The format string <code class=\\\"code\\\">rf</code> must have the same type as the format string\\n      specification <code class=\\\"code\\\">fmt</code> that it replaces.\\n      For instance, <code class=\\\"code\\\">&quot;%( %i %)&quot;</code> reads any format string that can read a value\\n      of type <code class=\\\"code\\\">int</code>.\\n      The conversion returns the format string read <code class=\\\"code\\\">rf</code>, and then a value\\n      read using <code class=\\\"code\\\">rf</code>.\\n      Hence, if <code class=\\\"code\\\">s</code> is the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then\\n      <code class=\\\"code\\\">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\\n      <code class=\\\"code\\\">(&quot;%4d&quot;, 1234)</code>.\\n      This behaviour is not mere format substitution, since the conversion\\n      returns the format string read as additional argument. If you need\\n      pure format substitution, use special flag <code class=\\\"code\\\">_</code> to discard the\\n      extraneous argument: conversion <code class=\\\"code\\\">%_( fmt %)</code> reads a format string\\n      <code class=\\\"code\\\">rf</code> and then behaves the same as format string <code class=\\\"code\\\">rf</code>.  Hence, if <code class=\\\"code\\\">s</code> is\\n      the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\\n      simply equivalent to <code class=\\\"code\\\">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\\n<li><code class=\\\"code\\\">l</code>: returns the number of lines read so far.</li>\\n<li><code class=\\\"code\\\">n</code>: returns the number of characters read so far.</li>\\n<li><code class=\\\"code\\\">N</code> or <code class=\\\"code\\\">L</code>: returns the number of tokens read so far.</li>\\n<li><code class=\\\"code\\\">!</code>: matches the end of input condition.</li>\\n<li><code class=\\\"code\\\">%</code>: matches one <code class=\\\"code\\\">%</code> character in the input.</li>\\n<li><code class=\\\"code\\\">@</code>: matches one <code class=\\\"code\\\">@</code> character in the input.</li>\\n<li><code class=\\\"code\\\">,</code>: does nothing.</li>\\n</ul>\\n\\n    Following the <code class=\\\"code\\\">%</code> character that introduces a conversion, there may be\\n    the special flag <code class=\\\"code\\\">_</code>: the conversion that follows occurs as usual,\\n    but the resulting value is discarded.\\n    For instance, if <code class=\\\"code\\\">f</code> is the function <code class=\\\"code\\\">fun i -&gt; i + 1</code>, and <code class=\\\"code\\\">s</code> is the\\n    string <code class=\\\"code\\\">&quot;x = 1&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class=\\\"code\\\">2</code>.\\n<p>\\n\\n    The field width is composed of an optional integer literal\\n    indicating the maximal width of the token to read.\\n    For instance, <code class=\\\"code\\\">%6d</code> reads an integer, having at most 6 decimal digits;\\n    <code class=\\\"code\\\">%4f</code> reads a float with at most 4 characters; and <code class=\\\"code\\\">%8[\\\\000-\\\\255]</code>\\n    returns the next 8 characters (or all the characters still available,\\n    if fewer than 8 characters are available in the input).\\n</p><p>\\n\\n    Notes:\\n</p><p>\\n</p><ul>\\n<li>as mentioned above, a <code class=\\\"code\\\">%s</code> conversion always succeeds, even if there is\\n      nothing to read in the input: in this case, it simply returns <code class=\\\"code\\\">&quot;&quot;</code>.</li>\\n</ul>\\n<ul>\\n<li>in addition to the relevant digits, <code class=\\\"code\\\">&apos;_&apos;</code> characters may appear\\n    inside numbers (this is reminiscent to the usual OCaml lexical\\n    conventions). If stricter scanning is desired, use the range\\n    conversion facility instead of the number conversions.</li>\\n</ul>\\n<ul>\\n<li>the <code class=\\\"code\\\">scanf</code> facility is not intended for heavy duty lexical\\n    analysis and parsing. If it appears not expressive enough for your\\n    needs, several alternative exists: regular expressions (module\\n    <code class=\\\"code\\\">Str</code>), stream parsers, <code class=\\\"code\\\">ocamllex</code>-generated lexers,\\n    <code class=\\\"code\\\">ocamlyacc</code>-generated parsers.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"indication\\\">Scanning indications in format strings</div><br>\\n<br>\\nScanning indications appear just after the string conversions <code class=\\\"code\\\">%s</code>\\n    and <code class=\\\"code\\\">%[ range ]</code> to delimit the end of the token. A scanning\\n    indication is introduced by a <code class=\\\"code\\\">@</code> character, followed by some\\n    plain character <code class=\\\"code\\\">c</code>. It means that the string token should end\\n    just before the next matching <code class=\\\"code\\\">c</code> (which is skipped). If no <code class=\\\"code\\\">c</code>\\n    character is encountered, the string token spreads as much as\\n    possible. For instance, <code class=\\\"code\\\">&quot;%s@\\\\t&quot;</code> reads a string up to the next\\n    tab character or to the end of input. If a <code class=\\\"code\\\">@</code> character appears\\n    anywhere else in the format string, it is treated as a plain character.\\n<p>\\n\\n    Note:\\n</p><p>\\n</p><ul>\\n<li>As usual in format strings, <code class=\\\"code\\\">%</code> and <code class=\\\"code\\\">@</code> characters must be escaped\\n    using <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code>; this rule still holds within range specifications\\n    and scanning indications.\\n    For instance, <code class=\\\"code\\\">&quot;%s@%%&quot;</code> reads a string up to the next <code class=\\\"code\\\">%</code> character.</li>\\n<li>The scanning indications introduce slight differences in the syntax of\\n    <code class=\\\"code\\\">Scanf</code> format strings, compared to those used for the <code class=\\\"code\\\">Printf</code>\\n    module. However, the scanning indications are similar to those used in\\n    the <code class=\\\"code\\\">Format</code> module; hence, when producing formatted text to be scanned\\n    by <code class=\\\"code\\\">!Scanf.bscanf</code>, it is wise to use printing functions from the\\n    <code class=\\\"code\\\">Format</code> module (or, if you need to use functions from <code class=\\\"code\\\">Printf</code>, banish\\n    or carefully double check the format strings that contain <code class=\\\"code\\\">&apos;@&apos;</code>\\n    characters).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Exceptionsduringscanning\\\">Exceptions during scanning</div><br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\nAs mentioned above, a plain character in the format string is just\\n    matched with the next character of the input; however, two characters are\\n    special exceptions to this rule: the space character (<code class=\\\"code\\\">&apos; &apos;</code> or ASCII code\\n    32) and the line feed character (<code class=\\\"code\\\">&apos;\\\\n&apos;</code> or ASCII code 10).\\n    A space does not match a single space character, but any amount of\\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\\n    string matches <em>any number</em> of tab, space, line feed and carriage\\n    return characters. Similarly, a line feed character in the format string\\n    matches either a single line feed or a carriage return followed by a line\\n    feed.\\n<p>\\n\\n    Matching <em>any</em> amount of whitespace, a space in the format string\\n    also matches no amount of whitespace at all; hence, the call <code class=\\\"code\\\">bscanf ib\\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class=\\\"code\\\">1</code> when reading an\\n    input with various whitespace in it, such as <code class=\\\"code\\\">Price = 1 $</code>,\\n    <code class=\\\"code\\\">Price  =  1    $</code>, or even <code class=\\\"code\\\">Price=1$</code>.<br>\\n<br>\\n</p><div class=\\\"h7\\\" id=\\\"conversion\\\">Conversion specifications in format strings</div><br>\\n<br>\\nConversion specifications consist in the <code class=\\\"code\\\">%</code> character, followed by\\n    an optional flag, an optional field width, and followed by one or\\n    two conversion characters. The conversion characters and their\\n    meanings are:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">d</code>: reads an optionally signed decimal integer.</li>\\n<li><code class=\\\"code\\\">i</code>: reads an optionally signed integer\\n      (usual input conventions for decimal (<code class=\\\"code\\\">0-9</code>+), hexadecimal\\n       (<code class=\\\"code\\\">0x[0-9a-f]+</code> and <code class=\\\"code\\\">0X[0-9A-F]+</code>), octal (<code class=\\\"code\\\">0o[0-7]+</code>), and binary\\n       (<code class=\\\"code\\\">0b[0-1]+</code>) notations are understood).</li>\\n<li><code class=\\\"code\\\">u</code>: reads an unsigned decimal integer.</li>\\n<li><code class=\\\"code\\\">x</code> or <code class=\\\"code\\\">X</code>: reads an unsigned hexadecimal integer (<code class=\\\"code\\\">[0-9a-fA-F]+</code>).</li>\\n<li><code class=\\\"code\\\">o</code>: reads an unsigned octal integer (<code class=\\\"code\\\">[0-7]+</code>).</li>\\n<li><code class=\\\"code\\\">s</code>: reads a string argument that spreads as much as possible, until the\\n      following bounding condition holds: <ul>\\n<li>a whitespace has been found (see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>a scanning indication (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>) has been\\n         encountered,</li>\\n<li>the end-of-input has been reached.</li>\\n</ul>\\n\\n      Hence, this conversion always succeeds: it returns an empty\\n      string if the bounding condition holds when the scan begins.</li>\\n<li><code class=\\\"code\\\">S</code>: reads a delimited string argument (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">c</code>: reads a single character. To test the current input character\\n      without reading it, specify a null field width, i.e. use\\n      specification <code class=\\\"code\\\">%0c</code>. Raise <code class=\\\"code\\\">Invalid_argument</code>, if the field width\\n      specification is greater than 1.</li>\\n<li><code class=\\\"code\\\">C</code>: reads a single delimited character (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">f</code>, <code class=\\\"code\\\">e</code>, <code class=\\\"code\\\">E</code>, <code class=\\\"code\\\">g</code>, <code class=\\\"code\\\">G</code>: reads an optionally signed\\n      floating-point number in decimal notation, in the style <code class=\\\"code\\\">dddd.ddd\\n      e/E+-dd</code>.</li>\\n<li><code class=\\\"code\\\">F</code>: reads a floating point number according to the lexical\\n      conventions of OCaml (hence the decimal point is mandatory if the\\n      exponent part is not mentioned).</li>\\n<li><code class=\\\"code\\\">B</code>: reads a boolean argument (<code class=\\\"code\\\">true</code> or <code class=\\\"code\\\">false</code>).</li>\\n<li><code class=\\\"code\\\">b</code>: reads a boolean argument (for backward compatibility; do not use\\n      in new programs).</li>\\n<li><code class=\\\"code\\\">ld</code>, <code class=\\\"code\\\">li</code>, <code class=\\\"code\\\">lu</code>, <code class=\\\"code\\\">lx</code>, <code class=\\\"code\\\">lX</code>, <code class=\\\"code\\\">lo</code>: reads an <code class=\\\"code\\\">int32</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">nd</code>, <code class=\\\"code\\\">ni</code>, <code class=\\\"code\\\">nu</code>, <code class=\\\"code\\\">nx</code>, <code class=\\\"code\\\">nX</code>, <code class=\\\"code\\\">no</code>: reads a <code class=\\\"code\\\">nativeint</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">Ld</code>, <code class=\\\"code\\\">Li</code>, <code class=\\\"code\\\">Lu</code>, <code class=\\\"code\\\">Lx</code>, <code class=\\\"code\\\">LX</code>, <code class=\\\"code\\\">Lo</code>: reads an <code class=\\\"code\\\">int64</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">[ range ]</code>: reads characters that matches one of the characters\\n      mentioned in the range of characters <code class=\\\"code\\\">range</code> (or not mentioned in\\n      it, if the range starts with <code class=\\\"code\\\">^</code>). Reads a <code class=\\\"code\\\">string</code> that can be\\n      empty, if the next input character does not match the range. The set of\\n      characters from <code class=\\\"code\\\">c1</code> to <code class=\\\"code\\\">c2</code> (inclusively) is denoted by <code class=\\\"code\\\">c1-c2</code>.\\n      Hence, <code class=\\\"code\\\">%[0-9]</code> returns a string representing a decimal number\\n      or an empty string if no decimal digit is found; similarly,\\n      <code class=\\\"code\\\">%[0-9a-f]</code> returns a string of hexadecimal digits.\\n      If a closing bracket appears in a range, it must occur as the\\n      first character of the range (or just after the <code class=\\\"code\\\">^</code> in case of\\n      range negation); hence <code class=\\\"code\\\">[]]</code> matches a <code class=\\\"code\\\">]</code> character and\\n      <code class=\\\"code\\\">[^]]</code> matches any character that is not <code class=\\\"code\\\">]</code>.\\n      Use <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code> to include a <code class=\\\"code\\\">%</code> or a <code class=\\\"code\\\">@</code> in a range.</li>\\n<li><code class=\\\"code\\\">r</code>: user-defined reader. Takes the next <code class=\\\"code\\\">ri</code> formatted input\\n      function and applies it to the scanning buffer <code class=\\\"code\\\">ib</code> to read the\\n      next argument. The input function <code class=\\\"code\\\">ri</code> must therefore have type\\n      <code class=\\\"code\\\">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class=\\\"code\\\">&apos;a</code>.</li>\\n<li><code class=\\\"code\\\">{ fmt %}</code>: reads a format string argument. The format string\\n      read must have the same type as the format string specification\\n      <code class=\\\"code\\\">fmt</code>. For instance, <code class=\\\"code\\\">&quot;%{ %i %}&quot;</code> reads any format string that\\n      can read a value of type <code class=\\\"code\\\">int</code>; hence, if <code class=\\\"code\\\">s</code> is the string\\n      <code class=\\\"code\\\">&quot;fmt:\\\\&quot;number is %u\\\\&quot;&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\\n      succeeds and returns the format string <code class=\\\"code\\\">&quot;number is %u&quot;</code>.</li>\\n<li><code class=\\\"code\\\">( fmt %)</code>: scanning sub-format substitution.\\n      Reads a format string <code class=\\\"code\\\">rf</code> in the input, then goes on scanning with\\n      <code class=\\\"code\\\">rf</code> instead of scanning with <code class=\\\"code\\\">fmt</code>.\\n      The format string <code class=\\\"code\\\">rf</code> must have the same type as the format string\\n      specification <code class=\\\"code\\\">fmt</code> that it replaces.\\n      For instance, <code class=\\\"code\\\">&quot;%( %i %)&quot;</code> reads any format string that can read a value\\n      of type <code class=\\\"code\\\">int</code>.\\n      The conversion returns the format string read <code class=\\\"code\\\">rf</code>, and then a value\\n      read using <code class=\\\"code\\\">rf</code>.\\n      Hence, if <code class=\\\"code\\\">s</code> is the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then\\n      <code class=\\\"code\\\">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\\n      <code class=\\\"code\\\">(&quot;%4d&quot;, 1234)</code>.\\n      This behaviour is not mere format substitution, since the conversion\\n      returns the format string read as additional argument. If you need\\n      pure format substitution, use special flag <code class=\\\"code\\\">_</code> to discard the\\n      extraneous argument: conversion <code class=\\\"code\\\">%_( fmt %)</code> reads a format string\\n      <code class=\\\"code\\\">rf</code> and then behaves the same as format string <code class=\\\"code\\\">rf</code>.  Hence, if <code class=\\\"code\\\">s</code> is\\n      the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\\n      simply equivalent to <code class=\\\"code\\\">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\\n<li><code class=\\\"code\\\">l</code>: returns the number of lines read so far.</li>\\n<li><code class=\\\"code\\\">n</code>: returns the number of characters read so far.</li>\\n<li><code class=\\\"code\\\">N</code> or <code class=\\\"code\\\">L</code>: returns the number of tokens read so far.</li>\\n<li><code class=\\\"code\\\">!</code>: matches the end of input condition.</li>\\n<li><code class=\\\"code\\\">%</code>: matches one <code class=\\\"code\\\">%</code> character in the input.</li>\\n<li><code class=\\\"code\\\">@</code>: matches one <code class=\\\"code\\\">@</code> character in the input.</li>\\n<li><code class=\\\"code\\\">,</code>: does nothing.</li>\\n</ul>\\n\\n    Following the <code class=\\\"code\\\">%</code> character that introduces a conversion, there may be\\n    the special flag <code class=\\\"code\\\">_</code>: the conversion that follows occurs as usual,\\n    but the resulting value is discarded.\\n    For instance, if <code class=\\\"code\\\">f</code> is the function <code class=\\\"code\\\">fun i -&gt; i + 1</code>, and <code class=\\\"code\\\">s</code> is the\\n    string <code class=\\\"code\\\">&quot;x = 1&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class=\\\"code\\\">2</code>.\\n<p>\\n\\n    The field width is composed of an optional integer literal\\n    indicating the maximal width of the token to read.\\n    For instance, <code class=\\\"code\\\">%6d</code> reads an integer, having at most 6 decimal digits;\\n    <code class=\\\"code\\\">%4f</code> reads a float with at most 4 characters; and <code class=\\\"code\\\">%8[\\\\000-\\\\255]</code>\\n    returns the next 8 characters (or all the characters still available,\\n    if fewer than 8 characters are available in the input).\\n</p><p>\\n\\n    Notes:\\n</p><p>\\n</p><ul>\\n<li>as mentioned above, a <code class=\\\"code\\\">%s</code> conversion always succeeds, even if there is\\n      nothing to read in the input: in this case, it simply returns <code class=\\\"code\\\">&quot;&quot;</code>.</li>\\n</ul>\\n<ul>\\n<li>in addition to the relevant digits, <code class=\\\"code\\\">&apos;_&apos;</code> characters may appear\\n    inside numbers (this is reminiscent to the usual OCaml lexical\\n    conventions). If stricter scanning is desired, use the range\\n    conversion facility instead of the number conversions.</li>\\n</ul>\\n<ul>\\n<li>the <code class=\\\"code\\\">scanf</code> facility is not intended for heavy duty lexical\\n    analysis and parsing. If it appears not expressive enough for your\\n    needs, several alternative exists: regular expressions (module\\n    <code class=\\\"code\\\">Str</code>), stream parsers, <code class=\\\"code\\\">ocamllex</code>-generated lexers,\\n    <code class=\\\"code\\\">ocamlyacc</code>-generated parsers.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"indication\\\">Scanning indications in format strings</div><br>\\n<br>\\nScanning indications appear just after the string conversions <code class=\\\"code\\\">%s</code>\\n    and <code class=\\\"code\\\">%[ range ]</code> to delimit the end of the token. A scanning\\n    indication is introduced by a <code class=\\\"code\\\">@</code> character, followed by some\\n    plain character <code class=\\\"code\\\">c</code>. It means that the string token should end\\n    just before the next matching <code class=\\\"code\\\">c</code> (which is skipped). If no <code class=\\\"code\\\">c</code>\\n    character is encountered, the string token spreads as much as\\n    possible. For instance, <code class=\\\"code\\\">&quot;%s@\\\\t&quot;</code> reads a string up to the next\\n    tab character or to the end of input. If a <code class=\\\"code\\\">@</code> character appears\\n    anywhere else in the format string, it is treated as a plain character.\\n<p>\\n\\n    Note:\\n</p><p>\\n</p><ul>\\n<li>As usual in format strings, <code class=\\\"code\\\">%</code> and <code class=\\\"code\\\">@</code> characters must be escaped\\n    using <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code>; this rule still holds within range specifications\\n    and scanning indications.\\n    For instance, <code class=\\\"code\\\">&quot;%s@%%&quot;</code> reads a string up to the next <code class=\\\"code\\\">%</code> character.</li>\\n<li>The scanning indications introduce slight differences in the syntax of\\n    <code class=\\\"code\\\">Scanf</code> format strings, compared to those used for the <code class=\\\"code\\\">Printf</code>\\n    module. However, the scanning indications are similar to those used in\\n    the <code class=\\\"code\\\">Format</code> module; hence, when producing formatted text to be scanned\\n    by <code class=\\\"code\\\">!Scanf.bscanf</code>, it is wise to use printing functions from the\\n    <code class=\\\"code\\\">Format</code> module (or, if you need to use functions from <code class=\\\"code\\\">Printf</code>, banish\\n    or carefully double check the format strings that contain <code class=\\\"code\\\">&apos;@&apos;</code>\\n    characters).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Exceptionsduringscanning\\\">Exceptions during scanning</div><br>\\n<br>\\nScanners may raise the following exceptions when the input cannot be read\\n    according to the format string:\\n<p>\\n</p><ul>\\n<li>Raise <code class=\\\"code\\\">Scanf.Scan_failure</code> if the input does not match the format.</li>\\n</ul>\\n<ul>\\n<li>Raise <code class=\\\"code\\\">Failure</code> if a conversion to a number is not possible.</li>\\n</ul>\\n<ul>\\n<li>Raise <code class=\\\"code\\\">End_of_file</code> if the end of input is encountered while some more\\n      characters are needed to read the current conversion specification.</li>\\n</ul>\\n<ul>\\n<li>Raise <code class=\\\"code\\\">Invalid_argument</code> if the format string is invalid.</li>\\n</ul>\\n\\n    Note:\\n<p>\\n</p><ul>\\n<li>as a consequence, scanning a <code class=\\\"code\\\">%s</code> conversion never raises exception\\n    <code class=\\\"code\\\">End_of_file</code>: if the end of input is reached the conversion succeeds and\\n    simply returns the characters read so far, or <code class=\\\"code\\\">&quot;&quot;</code> if none were ever read.</li>\\n</ul>\\n<br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\nAs mentioned above, a plain character in the format string is just\\n    matched with the next character of the input; however, two characters are\\n    special exceptions to this rule: the space character (<code class=\\\"code\\\">&apos; &apos;</code> or ASCII code\\n    32) and the line feed character (<code class=\\\"code\\\">&apos;\\\\n&apos;</code> or ASCII code 10).\\n    A space does not match a single space character, but any amount of\\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\\n    string matches <em>any number</em> of tab, space, line feed and carriage\\n    return characters. Similarly, a line feed character in the format string\\n    matches either a single line feed or a carriage return followed by a line\\n    feed.\\n<p>\\n\\n    Matching <em>any</em> amount of whitespace, a space in the format string\\n    also matches no amount of whitespace at all; hence, the call <code class=\\\"code\\\">bscanf ib\\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class=\\\"code\\\">1</code> when reading an\\n    input with various whitespace in it, such as <code class=\\\"code\\\">Price = 1 $</code>,\\n    <code class=\\\"code\\\">Price  =  1    $</code>, or even <code class=\\\"code\\\">Price=1$</code>.<br>\\n<br>\\n</p><div class=\\\"h7\\\" id=\\\"conversion\\\">Conversion specifications in format strings</div><br>\\n<br>\\nConversion specifications consist in the <code class=\\\"code\\\">%</code> character, followed by\\n    an optional flag, an optional field width, and followed by one or\\n    two conversion characters. The conversion characters and their\\n    meanings are:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">d</code>: reads an optionally signed decimal integer.</li>\\n<li><code class=\\\"code\\\">i</code>: reads an optionally signed integer\\n      (usual input conventions for decimal (<code class=\\\"code\\\">0-9</code>+), hexadecimal\\n       (<code class=\\\"code\\\">0x[0-9a-f]+</code> and <code class=\\\"code\\\">0X[0-9A-F]+</code>), octal (<code class=\\\"code\\\">0o[0-7]+</code>), and binary\\n       (<code class=\\\"code\\\">0b[0-1]+</code>) notations are understood).</li>\\n<li><code class=\\\"code\\\">u</code>: reads an unsigned decimal integer.</li>\\n<li><code class=\\\"code\\\">x</code> or <code class=\\\"code\\\">X</code>: reads an unsigned hexadecimal integer (<code class=\\\"code\\\">[0-9a-fA-F]+</code>).</li>\\n<li><code class=\\\"code\\\">o</code>: reads an unsigned octal integer (<code class=\\\"code\\\">[0-7]+</code>).</li>\\n<li><code class=\\\"code\\\">s</code>: reads a string argument that spreads as much as possible, until the\\n      following bounding condition holds: <ul>\\n<li>a whitespace has been found (see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>a scanning indication (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>) has been\\n         encountered,</li>\\n<li>the end-of-input has been reached.</li>\\n</ul>\\n\\n      Hence, this conversion always succeeds: it returns an empty\\n      string if the bounding condition holds when the scan begins.</li>\\n<li><code class=\\\"code\\\">S</code>: reads a delimited string argument (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">c</code>: reads a single character. To test the current input character\\n      without reading it, specify a null field width, i.e. use\\n      specification <code class=\\\"code\\\">%0c</code>. Raise <code class=\\\"code\\\">Invalid_argument</code>, if the field width\\n      specification is greater than 1.</li>\\n<li><code class=\\\"code\\\">C</code>: reads a single delimited character (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">f</code>, <code class=\\\"code\\\">e</code>, <code class=\\\"code\\\">E</code>, <code class=\\\"code\\\">g</code>, <code class=\\\"code\\\">G</code>: reads an optionally signed\\n      floating-point number in decimal notation, in the style <code class=\\\"code\\\">dddd.ddd\\n      e/E+-dd</code>.</li>\\n<li><code class=\\\"code\\\">F</code>: reads a floating point number according to the lexical\\n      conventions of OCaml (hence the decimal point is mandatory if the\\n      exponent part is not mentioned).</li>\\n<li><code class=\\\"code\\\">B</code>: reads a boolean argument (<code class=\\\"code\\\">true</code> or <code class=\\\"code\\\">false</code>).</li>\\n<li><code class=\\\"code\\\">b</code>: reads a boolean argument (for backward compatibility; do not use\\n      in new programs).</li>\\n<li><code class=\\\"code\\\">ld</code>, <code class=\\\"code\\\">li</code>, <code class=\\\"code\\\">lu</code>, <code class=\\\"code\\\">lx</code>, <code class=\\\"code\\\">lX</code>, <code class=\\\"code\\\">lo</code>: reads an <code class=\\\"code\\\">int32</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">nd</code>, <code class=\\\"code\\\">ni</code>, <code class=\\\"code\\\">nu</code>, <code class=\\\"code\\\">nx</code>, <code class=\\\"code\\\">nX</code>, <code class=\\\"code\\\">no</code>: reads a <code class=\\\"code\\\">nativeint</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">Ld</code>, <code class=\\\"code\\\">Li</code>, <code class=\\\"code\\\">Lu</code>, <code class=\\\"code\\\">Lx</code>, <code class=\\\"code\\\">LX</code>, <code class=\\\"code\\\">Lo</code>: reads an <code class=\\\"code\\\">int64</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">[ range ]</code>: reads characters that matches one of the characters\\n      mentioned in the range of characters <code class=\\\"code\\\">range</code> (or not mentioned in\\n      it, if the range starts with <code class=\\\"code\\\">^</code>). Reads a <code class=\\\"code\\\">string</code> that can be\\n      empty, if the next input character does not match the range. The set of\\n      characters from <code class=\\\"code\\\">c1</code> to <code class=\\\"code\\\">c2</code> (inclusively) is denoted by <code class=\\\"code\\\">c1-c2</code>.\\n      Hence, <code class=\\\"code\\\">%[0-9]</code> returns a string representing a decimal number\\n      or an empty string if no decimal digit is found; similarly,\\n      <code class=\\\"code\\\">%[0-9a-f]</code> returns a string of hexadecimal digits.\\n      If a closing bracket appears in a range, it must occur as the\\n      first character of the range (or just after the <code class=\\\"code\\\">^</code> in case of\\n      range negation); hence <code class=\\\"code\\\">[]]</code> matches a <code class=\\\"code\\\">]</code> character and\\n      <code class=\\\"code\\\">[^]]</code> matches any character that is not <code class=\\\"code\\\">]</code>.\\n      Use <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code> to include a <code class=\\\"code\\\">%</code> or a <code class=\\\"code\\\">@</code> in a range.</li>\\n<li><code class=\\\"code\\\">r</code>: user-defined reader. Takes the next <code class=\\\"code\\\">ri</code> formatted input\\n      function and applies it to the scanning buffer <code class=\\\"code\\\">ib</code> to read the\\n      next argument. The input function <code class=\\\"code\\\">ri</code> must therefore have type\\n      <code class=\\\"code\\\">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class=\\\"code\\\">&apos;a</code>.</li>\\n<li><code class=\\\"code\\\">{ fmt %}</code>: reads a format string argument. The format string\\n      read must have the same type as the format string specification\\n      <code class=\\\"code\\\">fmt</code>. For instance, <code class=\\\"code\\\">&quot;%{ %i %}&quot;</code> reads any format string that\\n      can read a value of type <code class=\\\"code\\\">int</code>; hence, if <code class=\\\"code\\\">s</code> is the string\\n      <code class=\\\"code\\\">&quot;fmt:\\\\&quot;number is %u\\\\&quot;&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\\n      succeeds and returns the format string <code class=\\\"code\\\">&quot;number is %u&quot;</code>.</li>\\n<li><code class=\\\"code\\\">( fmt %)</code>: scanning sub-format substitution.\\n      Reads a format string <code class=\\\"code\\\">rf</code> in the input, then goes on scanning with\\n      <code class=\\\"code\\\">rf</code> instead of scanning with <code class=\\\"code\\\">fmt</code>.\\n      The format string <code class=\\\"code\\\">rf</code> must have the same type as the format string\\n      specification <code class=\\\"code\\\">fmt</code> that it replaces.\\n      For instance, <code class=\\\"code\\\">&quot;%( %i %)&quot;</code> reads any format string that can read a value\\n      of type <code class=\\\"code\\\">int</code>.\\n      The conversion returns the format string read <code class=\\\"code\\\">rf</code>, and then a value\\n      read using <code class=\\\"code\\\">rf</code>.\\n      Hence, if <code class=\\\"code\\\">s</code> is the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then\\n      <code class=\\\"code\\\">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\\n      <code class=\\\"code\\\">(&quot;%4d&quot;, 1234)</code>.\\n      This behaviour is not mere format substitution, since the conversion\\n      returns the format string read as additional argument. If you need\\n      pure format substitution, use special flag <code class=\\\"code\\\">_</code> to discard the\\n      extraneous argument: conversion <code class=\\\"code\\\">%_( fmt %)</code> reads a format string\\n      <code class=\\\"code\\\">rf</code> and then behaves the same as format string <code class=\\\"code\\\">rf</code>.  Hence, if <code class=\\\"code\\\">s</code> is\\n      the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\\n      simply equivalent to <code class=\\\"code\\\">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\\n<li><code class=\\\"code\\\">l</code>: returns the number of lines read so far.</li>\\n<li><code class=\\\"code\\\">n</code>: returns the number of characters read so far.</li>\\n<li><code class=\\\"code\\\">N</code> or <code class=\\\"code\\\">L</code>: returns the number of tokens read so far.</li>\\n<li><code class=\\\"code\\\">!</code>: matches the end of input condition.</li>\\n<li><code class=\\\"code\\\">%</code>: matches one <code class=\\\"code\\\">%</code> character in the input.</li>\\n<li><code class=\\\"code\\\">@</code>: matches one <code class=\\\"code\\\">@</code> character in the input.</li>\\n<li><code class=\\\"code\\\">,</code>: does nothing.</li>\\n</ul>\\n\\n    Following the <code class=\\\"code\\\">%</code> character that introduces a conversion, there may be\\n    the special flag <code class=\\\"code\\\">_</code>: the conversion that follows occurs as usual,\\n    but the resulting value is discarded.\\n    For instance, if <code class=\\\"code\\\">f</code> is the function <code class=\\\"code\\\">fun i -&gt; i + 1</code>, and <code class=\\\"code\\\">s</code> is the\\n    string <code class=\\\"code\\\">&quot;x = 1&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class=\\\"code\\\">2</code>.\\n<p>\\n\\n    The field width is composed of an optional integer literal\\n    indicating the maximal width of the token to read.\\n    For instance, <code class=\\\"code\\\">%6d</code> reads an integer, having at most 6 decimal digits;\\n    <code class=\\\"code\\\">%4f</code> reads a float with at most 4 characters; and <code class=\\\"code\\\">%8[\\\\000-\\\\255]</code>\\n    returns the next 8 characters (or all the characters still available,\\n    if fewer than 8 characters are available in the input).\\n</p><p>\\n\\n    Notes:\\n</p><p>\\n</p><ul>\\n<li>as mentioned above, a <code class=\\\"code\\\">%s</code> conversion always succeeds, even if there is\\n      nothing to read in the input: in this case, it simply returns <code class=\\\"code\\\">&quot;&quot;</code>.</li>\\n</ul>\\n<ul>\\n<li>in addition to the relevant digits, <code class=\\\"code\\\">&apos;_&apos;</code> characters may appear\\n    inside numbers (this is reminiscent to the usual OCaml lexical\\n    conventions). If stricter scanning is desired, use the range\\n    conversion facility instead of the number conversions.</li>\\n</ul>\\n<ul>\\n<li>the <code class=\\\"code\\\">scanf</code> facility is not intended for heavy duty lexical\\n    analysis and parsing. If it appears not expressive enough for your\\n    needs, several alternative exists: regular expressions (module\\n    <code class=\\\"code\\\">Str</code>), stream parsers, <code class=\\\"code\\\">ocamllex</code>-generated lexers,\\n    <code class=\\\"code\\\">ocamlyacc</code>-generated parsers.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"indication\\\">Scanning indications in format strings</div><br>\\n<br>\\nScanning indications appear just after the string conversions <code class=\\\"code\\\">%s</code>\\n    and <code class=\\\"code\\\">%[ range ]</code> to delimit the end of the token. A scanning\\n    indication is introduced by a <code class=\\\"code\\\">@</code> character, followed by some\\n    plain character <code class=\\\"code\\\">c</code>. It means that the string token should end\\n    just before the next matching <code class=\\\"code\\\">c</code> (which is skipped). If no <code class=\\\"code\\\">c</code>\\n    character is encountered, the string token spreads as much as\\n    possible. For instance, <code class=\\\"code\\\">&quot;%s@\\\\t&quot;</code> reads a string up to the next\\n    tab character or to the end of input. If a <code class=\\\"code\\\">@</code> character appears\\n    anywhere else in the format string, it is treated as a plain character.\\n<p>\\n\\n    Note:\\n</p><p>\\n</p><ul>\\n<li>As usual in format strings, <code class=\\\"code\\\">%</code> and <code class=\\\"code\\\">@</code> characters must be escaped\\n    using <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code>; this rule still holds within range specifications\\n    and scanning indications.\\n    For instance, <code class=\\\"code\\\">&quot;%s@%%&quot;</code> reads a string up to the next <code class=\\\"code\\\">%</code> character.</li>\\n<li>The scanning indications introduce slight differences in the syntax of\\n    <code class=\\\"code\\\">Scanf</code> format strings, compared to those used for the <code class=\\\"code\\\">Printf</code>\\n    module. However, the scanning indications are similar to those used in\\n    the <code class=\\\"code\\\">Format</code> module; hence, when producing formatted text to be scanned\\n    by <code class=\\\"code\\\">!Scanf.bscanf</code>, it is wise to use printing functions from the\\n    <code class=\\\"code\\\">Format</code> module (or, if you need to use functions from <code class=\\\"code\\\">Printf</code>, banish\\n    or carefully double check the format strings that contain <code class=\\\"code\\\">&apos;@&apos;</code>\\n    characters).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Exceptionsduringscanning\\\">Exceptions during scanning</div><br>\\n<br>\\nScanners may raise the following exceptions when the input cannot be read\\n    according to the format string:\\n<p>\\n</p><ul>\\n<li>Raise <code class=\\\"code\\\">Scanf.Scan_failure</code> if the input does not match the format.</li>\\n</ul>\\n<ul>\\n<li>Raise <code class=\\\"code\\\">Failure</code> if a conversion to a number is not possible.</li>\\n</ul>\\n<ul>\\n<li>Raise <code class=\\\"code\\\">End_of_file</code> if the end of input is encountered while some more\\n      characters are needed to read the current conversion specification.</li>\\n</ul>\\n<ul>\\n<li>Raise <code class=\\\"code\\\">Invalid_argument</code> if the format string is invalid.</li>\\n</ul>\\n\\n    Note:\\n<p>\\n</p><ul>\\n<li>as a consequence, scanning a <code class=\\\"code\\\">%s</code> conversion never raises exception\\n    <code class=\\\"code\\\">End_of_file</code>: if the end of input is reached the conversion succeeds and\\n    simply returns the characters read so far, or <code class=\\\"code\\\">&quot;&quot;</code> if none were ever read.</li>\\n</ul>\\n<br>\\n<br>\\n<h6 id=\\\"6_Specialisedformattedinputfunctions\\\">Specialised formatted input functions</h6><br>\\n\\n<pre><span class=\\\"keyword\\\">let</span> fscanf: Pervasives.in_channel =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\\n</pre><div class=\\\"info \\\">\\nSame as <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a>, but reads from the given regular input channel.\\n<p>\\n\\n    Warning: since all formatted input functions operate from a <em>formatted\\n    input channel</em>, be aware that each <code class=\\\"code\\\">fscanf</code> invocation will operate with a\\n    formatted input channel reading from the given channel. This extra level\\n    of bufferization can lead to a strange scanning behaviour if you use low\\n    level primitives on the channel (reading characters, seeking the reading\\n    position, and so on).\\n</p><p>\\n\\n    As a consequence, never mix direct low level reading and high level\\n    scanning from the same regular input channel.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> sscanf: string =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\\n</pre><div class=\\\"info \\\">\\nSame as <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a>, but reads from the given string.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> scanf: scanner &apos;a &apos;b &apos;c &apos;d;\\n</pre><div class=\\\"info \\\">\\nSame as <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a>, but reads from the predefined formatted input\\n    channel <a href=\\\"Scanf.Scanning.html#VALstdin\\\"><code class=\\\"code\\\">Scanf.Scanning.stdin</code></a> that is connected to <code class=\\\"code\\\">Pervasives.stdin</code>.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> kscanf: Scanning.in_channel =&gt; (Scanning.in_channel =&gt; exn =&gt; &apos;d) =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\\n</pre><div class=\\\"info \\\">\\nSame as <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a>, but takes an additional function argument\\n    <code class=\\\"code\\\">ef</code> that is called in case of error: if the scanning process or\\n    some conversion fails, the scanning function aborts and calls the\\n    error handling function <code class=\\\"code\\\">ef</code> with the formatted input channel and the\\n    exception that aborted the scanning process as arguments.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> ksscanf: string =&gt; (Scanning.in_channel =&gt; exn =&gt; &apos;d) =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\\n</pre><div class=\\\"info \\\">\\nSame as <a href=\\\"Scanf.html#VALkscanf\\\"><code class=\\\"code\\\">Scanf.kscanf</code></a> but reads from the given string.<br>\\n<b>Since</b> 4.02.0<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> kfscanf: Pervasives.in_channel =&gt; (Scanning.in_channel =&gt; exn =&gt; &apos;d) =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\\n</pre><div class=\\\"info \\\">\\nSame as <a href=\\\"Scanf.html#VALkscanf\\\"><code class=\\\"code\\\">Scanf.kscanf</code></a>, but reads from the given regular input channel.<br>\\n<b>Since</b> 4.02.0<br>\\n</div>\\n<br>\\n<h6 id=\\\"6_Readingformatstringsfrominput\\\">Reading format strings from input</h6><br>\\n\\n<pre><span class=\\\"keyword\\\">let</span> bscanf_format:\\n  Scanning.in_channel =&gt;\\n  Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt;\\n  (Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt; &apos;g) =&gt;\\n  &apos;g;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">bscanf_format ic fmt f</code> reads a format string token from the formatted\\n    input channel <code class=\\\"code\\\">ic</code>, according to the given format string <code class=\\\"code\\\">fmt</code>, and\\n    applies <code class=\\\"code\\\">f</code> to the resulting format string value.\\n    Raise <code class=\\\"code\\\">Scan_failure</code> if the format string value read does not have the\\n    same type as <code class=\\\"code\\\">fmt</code>.<br>\\n<b>Since</b> 3.09.0<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> sscanf_format:\\n  string =&gt;\\n  Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt;\\n  (Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt; &apos;g) =&gt;\\n  &apos;g;\\n</pre><div class=\\\"info \\\">\\nSame as <a href=\\\"Scanf.html#VALbscanf_format\\\"><code class=\\\"code\\\">Scanf.bscanf_format</code></a>, but reads from the given string.<br>\\n<b>Since</b> 3.09.0<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> format_from_string:\\n  string =&gt; Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt; Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">format_from_string s fmt</code> converts a string argument to a format string,\\n    according to the given format string <code class=\\\"code\\\">fmt</code>.\\n    Raise <code class=\\\"code\\\">Scan_failure</code> if <code class=\\\"code\\\">s</code>, considered as a format string, does not\\n    have the same type as <code class=\\\"code\\\">fmt</code>.<br>\\n<b>Since</b> 3.10.0<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> unescaped: string =&gt; string;\\n</pre><div class=\\\"info \\\">\\nReturn a copy of the argument with escape sequences, following the\\n    lexical conventions of OCaml, replaced by their corresponding\\n    special characters. If there is no escape sequence in the\\n    argument, still return a copy, contrary to String.escaped.<br>\\n<b>Since</b> 4.00.0<br>\\n</div>\\n</div>\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"pathContext\": {\n\t\t\t\"relativePath\": \"api/Scanf.html\"\n\t\t}\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---api-scanf-html-8a3b94e4b6e659d16e80.js","module.exports = {\n\t\"data\": {\n\t\t\"file\": {\n\t\t\t\"relativePath\": \"api/Scanf.html\",\n\t\t\t\"childRawHtml\": {\n\t\t\t\t\"content\": \"<div class=\\\"ocamldoc\\\">\\n<div class=\\\"navbar\\\"><a class=\\\"pre\\\" href=\\\"Random.html\\\" title=\\\"Random\\\">Previous</a>\\n&#xA0;<a class=\\\"up\\\" href=\\\"index.html\\\" title=\\\"Index\\\">Up</a>\\n&#xA0;<a class=\\\"post\\\" href=\\\"Set.html\\\" title=\\\"Set\\\">Next</a>\\n</div>\\n<h1>Module <a href=\\\"type_Scanf.html\\\">Scanf</a></h1>\\n\\n<pre><span class=\\\"keyword\\\">module</span> Scanf: sig .. end</pre><div class=\\\"info module top\\\">\\nFormatted input functions.<br>\\n</div>\\n<hr width=\\\"100%\\\">\\n<br>\\n<h6 id=\\\"6_Introduction\\\">Introduction</h6><br>\\n<br>\\n<h6 id=\\\"6_Introduction\\\">Introduction</h6><br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Functionalinputwithformatstrings\\\">Functional input with format strings</div><br>\\n<br>\\n<h6 id=\\\"6_Introduction\\\">Introduction</h6><br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Functionalinputwithformatstrings\\\">Functional input with format strings</div><br>\\n<br>\\nThe module <code class=\\\"code\\\">Scanf</code> provides formatted input functions or <em>scanners</em>.\\n<p>\\n\\n    The formatted input functions can read from any kind of input, including\\n    strings, files, or anything that can return characters. The more general\\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>. The more general\\n    formatted input function reads from any scanning buffer and is named\\n    <code class=\\\"code\\\">bscanf</code>.\\n</p><p>\\n\\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\\n<li>the first argument is a source of characters for the input,</li>\\n<li>the second argument is a format string that specifies the values to\\n      read,</li>\\n<li>the third argument is a <em>receiver function</em> that is applied to the\\n      values read.</li>\\n</ul>\\n\\n    Hence, a typical call to the formatted input function <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a> is\\n    <code class=\\\"code\\\">bscanf ic fmt f</code>, where:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">fmt</code> is a format string (the same format strings as those used to print\\n    material with module <a href=\\\"Printf.html\\\"><code class=\\\"code\\\">Printf</code></a> or <a href=\\\"Format.html\\\"><code class=\\\"code\\\">Format</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">f</code> is a function that has as many arguments as the number of values to\\n    read in the input.</li>\\n</ul>\\n<br>\\n<br>\\n<h6 id=\\\"6_Introduction\\\">Introduction</h6><br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Functionalinputwithformatstrings\\\">Functional input with format strings</div><br>\\n<br>\\nThe module <code class=\\\"code\\\">Scanf</code> provides formatted input functions or <em>scanners</em>.\\n<p>\\n\\n    The formatted input functions can read from any kind of input, including\\n    strings, files, or anything that can return characters. The more general\\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>. The more general\\n    formatted input function reads from any scanning buffer and is named\\n    <code class=\\\"code\\\">bscanf</code>.\\n</p><p>\\n\\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\\n<li>the first argument is a source of characters for the input,</li>\\n<li>the second argument is a format string that specifies the values to\\n      read,</li>\\n<li>the third argument is a <em>receiver function</em> that is applied to the\\n      values read.</li>\\n</ul>\\n\\n    Hence, a typical call to the formatted input function <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a> is\\n    <code class=\\\"code\\\">bscanf ic fmt f</code>, where:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">fmt</code> is a format string (the same format strings as those used to print\\n    material with module <a href=\\\"Printf.html\\\"><code class=\\\"code\\\">Printf</code></a> or <a href=\\\"Format.html\\\"><code class=\\\"code\\\">Format</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">f</code> is a function that has as many arguments as the number of values to\\n    read in the input.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Asimpleexample\\\">A simple example</div><br>\\n<br>\\n<h6 id=\\\"6_Introduction\\\">Introduction</h6><br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Functionalinputwithformatstrings\\\">Functional input with format strings</div><br>\\n<br>\\nThe module <code class=\\\"code\\\">Scanf</code> provides formatted input functions or <em>scanners</em>.\\n<p>\\n\\n    The formatted input functions can read from any kind of input, including\\n    strings, files, or anything that can return characters. The more general\\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>. The more general\\n    formatted input function reads from any scanning buffer and is named\\n    <code class=\\\"code\\\">bscanf</code>.\\n</p><p>\\n\\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\\n<li>the first argument is a source of characters for the input,</li>\\n<li>the second argument is a format string that specifies the values to\\n      read,</li>\\n<li>the third argument is a <em>receiver function</em> that is applied to the\\n      values read.</li>\\n</ul>\\n\\n    Hence, a typical call to the formatted input function <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a> is\\n    <code class=\\\"code\\\">bscanf ic fmt f</code>, where:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">fmt</code> is a format string (the same format strings as those used to print\\n    material with module <a href=\\\"Printf.html\\\"><code class=\\\"code\\\">Printf</code></a> or <a href=\\\"Format.html\\\"><code class=\\\"code\\\">Format</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">f</code> is a function that has as many arguments as the number of values to\\n    read in the input.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Asimpleexample\\\">A simple example</div><br>\\n<br>\\nAs suggested above, the expression <code class=\\\"code\\\">bscanf ic &quot;%d&quot; f</code> reads a decimal\\n    integer <code class=\\\"code\\\">n</code> from the source of characters <code class=\\\"code\\\">ic</code> and returns <code class=\\\"code\\\">f n</code>.\\n<p>\\n\\n    For instance,\\n</p><p>\\n</p><ul>\\n<li>if we use <code class=\\\"code\\\">stdin</code> as the source of characters (<a href=\\\"Scanf.Scanning.html#VALstdin\\\"><code class=\\\"code\\\">Scanf.Scanning.stdin</code></a> is\\n    the predefined formatted input channel that reads from standard input),</li>\\n</ul>\\n<ul>\\n<li>if we define the receiver <code class=\\\"code\\\">f</code> as <code class=\\\"code\\\">let f x = x + 1</code>,</li>\\n</ul>\\n\\n    then <code class=\\\"code\\\">bscanf Scanning.stdin &quot;%d&quot; f</code> reads an integer <code class=\\\"code\\\">n</code> from the\\n    standard input and returns <code class=\\\"code\\\">f n</code> (that is <code class=\\\"code\\\">n + 1</code>). Thus, if we\\n    evaluate <code class=\\\"code\\\">bscanf stdin &quot;%d&quot; f</code>, and then enter <code class=\\\"code\\\">41</code> at the\\n    keyboard, we get <code class=\\\"code\\\">42</code> as the final result.<br>\\n<br>\\n<h6 id=\\\"6_Introduction\\\">Introduction</h6><br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Functionalinputwithformatstrings\\\">Functional input with format strings</div><br>\\n<br>\\nThe module <code class=\\\"code\\\">Scanf</code> provides formatted input functions or <em>scanners</em>.\\n<p>\\n\\n    The formatted input functions can read from any kind of input, including\\n    strings, files, or anything that can return characters. The more general\\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>. The more general\\n    formatted input function reads from any scanning buffer and is named\\n    <code class=\\\"code\\\">bscanf</code>.\\n</p><p>\\n\\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\\n<li>the first argument is a source of characters for the input,</li>\\n<li>the second argument is a format string that specifies the values to\\n      read,</li>\\n<li>the third argument is a <em>receiver function</em> that is applied to the\\n      values read.</li>\\n</ul>\\n\\n    Hence, a typical call to the formatted input function <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a> is\\n    <code class=\\\"code\\\">bscanf ic fmt f</code>, where:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">fmt</code> is a format string (the same format strings as those used to print\\n    material with module <a href=\\\"Printf.html\\\"><code class=\\\"code\\\">Printf</code></a> or <a href=\\\"Format.html\\\"><code class=\\\"code\\\">Format</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">f</code> is a function that has as many arguments as the number of values to\\n    read in the input.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Asimpleexample\\\">A simple example</div><br>\\n<br>\\nAs suggested above, the expression <code class=\\\"code\\\">bscanf ic &quot;%d&quot; f</code> reads a decimal\\n    integer <code class=\\\"code\\\">n</code> from the source of characters <code class=\\\"code\\\">ic</code> and returns <code class=\\\"code\\\">f n</code>.\\n<p>\\n\\n    For instance,\\n</p><p>\\n</p><ul>\\n<li>if we use <code class=\\\"code\\\">stdin</code> as the source of characters (<a href=\\\"Scanf.Scanning.html#VALstdin\\\"><code class=\\\"code\\\">Scanf.Scanning.stdin</code></a> is\\n    the predefined formatted input channel that reads from standard input),</li>\\n</ul>\\n<ul>\\n<li>if we define the receiver <code class=\\\"code\\\">f</code> as <code class=\\\"code\\\">let f x = x + 1</code>,</li>\\n</ul>\\n\\n    then <code class=\\\"code\\\">bscanf Scanning.stdin &quot;%d&quot; f</code> reads an integer <code class=\\\"code\\\">n</code> from the\\n    standard input and returns <code class=\\\"code\\\">f n</code> (that is <code class=\\\"code\\\">n + 1</code>). Thus, if we\\n    evaluate <code class=\\\"code\\\">bscanf stdin &quot;%d&quot; f</code>, and then enter <code class=\\\"code\\\">41</code> at the\\n    keyboard, we get <code class=\\\"code\\\">42</code> as the final result.<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Formattedinputasafunctionalfeature\\\">Formatted input as a functional feature</div><br>\\n<br>\\n<h6 id=\\\"6_Introduction\\\">Introduction</h6><br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Functionalinputwithformatstrings\\\">Functional input with format strings</div><br>\\n<br>\\nThe module <code class=\\\"code\\\">Scanf</code> provides formatted input functions or <em>scanners</em>.\\n<p>\\n\\n    The formatted input functions can read from any kind of input, including\\n    strings, files, or anything that can return characters. The more general\\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>. The more general\\n    formatted input function reads from any scanning buffer and is named\\n    <code class=\\\"code\\\">bscanf</code>.\\n</p><p>\\n\\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\\n<li>the first argument is a source of characters for the input,</li>\\n<li>the second argument is a format string that specifies the values to\\n      read,</li>\\n<li>the third argument is a <em>receiver function</em> that is applied to the\\n      values read.</li>\\n</ul>\\n\\n    Hence, a typical call to the formatted input function <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a> is\\n    <code class=\\\"code\\\">bscanf ic fmt f</code>, where:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">fmt</code> is a format string (the same format strings as those used to print\\n    material with module <a href=\\\"Printf.html\\\"><code class=\\\"code\\\">Printf</code></a> or <a href=\\\"Format.html\\\"><code class=\\\"code\\\">Format</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">f</code> is a function that has as many arguments as the number of values to\\n    read in the input.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Asimpleexample\\\">A simple example</div><br>\\n<br>\\nAs suggested above, the expression <code class=\\\"code\\\">bscanf ic &quot;%d&quot; f</code> reads a decimal\\n    integer <code class=\\\"code\\\">n</code> from the source of characters <code class=\\\"code\\\">ic</code> and returns <code class=\\\"code\\\">f n</code>.\\n<p>\\n\\n    For instance,\\n</p><p>\\n</p><ul>\\n<li>if we use <code class=\\\"code\\\">stdin</code> as the source of characters (<a href=\\\"Scanf.Scanning.html#VALstdin\\\"><code class=\\\"code\\\">Scanf.Scanning.stdin</code></a> is\\n    the predefined formatted input channel that reads from standard input),</li>\\n</ul>\\n<ul>\\n<li>if we define the receiver <code class=\\\"code\\\">f</code> as <code class=\\\"code\\\">let f x = x + 1</code>,</li>\\n</ul>\\n\\n    then <code class=\\\"code\\\">bscanf Scanning.stdin &quot;%d&quot; f</code> reads an integer <code class=\\\"code\\\">n</code> from the\\n    standard input and returns <code class=\\\"code\\\">f n</code> (that is <code class=\\\"code\\\">n + 1</code>). Thus, if we\\n    evaluate <code class=\\\"code\\\">bscanf stdin &quot;%d&quot; f</code>, and then enter <code class=\\\"code\\\">41</code> at the\\n    keyboard, we get <code class=\\\"code\\\">42</code> as the final result.<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Formattedinputasafunctionalfeature\\\">Formatted input as a functional feature</div><br>\\n<br>\\nThe OCaml scanning facility is reminiscent of the corresponding C feature.\\n    However, it is also largely different, simpler, and yet more powerful:\\n    the formatted input functions are higher-order functionals and the\\n    parameter passing mechanism is just the regular function application not\\n    the variable assignment based mechanism which is typical for formatted\\n    input in imperative languages; the OCaml format strings also feature\\n    useful additions to easily define complex tokens; as expected within a\\n    functional programming language, the formatted input functions also\\n    support polymorphism, in particular arbitrary interaction with\\n    polymorphic user-defined scanners. Furthermore, the OCaml formatted input\\n    facility is fully type-checked at compile time.<br>\\n<br>\\n<h6 id=\\\"6_Introduction\\\">Introduction</h6><br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Functionalinputwithformatstrings\\\">Functional input with format strings</div><br>\\n<br>\\nThe module <code class=\\\"code\\\">Scanf</code> provides formatted input functions or <em>scanners</em>.\\n<p>\\n\\n    The formatted input functions can read from any kind of input, including\\n    strings, files, or anything that can return characters. The more general\\n    source of characters is named a <em>formatted input channel</em> (or <em>    scanning buffer</em>) and has type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>. The more general\\n    formatted input function reads from any scanning buffer and is named\\n    <code class=\\\"code\\\">bscanf</code>.\\n</p><p>\\n\\n    Generally speaking, the formatted input functions have 3 arguments:</p><ul>\\n<li>the first argument is a source of characters for the input,</li>\\n<li>the second argument is a format string that specifies the values to\\n      read,</li>\\n<li>the third argument is a <em>receiver function</em> that is applied to the\\n      values read.</li>\\n</ul>\\n\\n    Hence, a typical call to the formatted input function <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a> is\\n    <code class=\\\"code\\\">bscanf ic fmt f</code>, where:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">ic</code> is a source of characters (typically a <em>    formatted input channel</em> with type <a href=\\\"Scanf.Scanning.html#TYPEin_channel\\\"><code class=\\\"code\\\">Scanf.Scanning.in_channel</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">fmt</code> is a format string (the same format strings as those used to print\\n    material with module <a href=\\\"Printf.html\\\"><code class=\\\"code\\\">Printf</code></a> or <a href=\\\"Format.html\\\"><code class=\\\"code\\\">Format</code></a>),</li>\\n</ul>\\n<ul>\\n<li><code class=\\\"code\\\">f</code> is a function that has as many arguments as the number of values to\\n    read in the input.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Asimpleexample\\\">A simple example</div><br>\\n<br>\\nAs suggested above, the expression <code class=\\\"code\\\">bscanf ic &quot;%d&quot; f</code> reads a decimal\\n    integer <code class=\\\"code\\\">n</code> from the source of characters <code class=\\\"code\\\">ic</code> and returns <code class=\\\"code\\\">f n</code>.\\n<p>\\n\\n    For instance,\\n</p><p>\\n</p><ul>\\n<li>if we use <code class=\\\"code\\\">stdin</code> as the source of characters (<a href=\\\"Scanf.Scanning.html#VALstdin\\\"><code class=\\\"code\\\">Scanf.Scanning.stdin</code></a> is\\n    the predefined formatted input channel that reads from standard input),</li>\\n</ul>\\n<ul>\\n<li>if we define the receiver <code class=\\\"code\\\">f</code> as <code class=\\\"code\\\">let f x = x + 1</code>,</li>\\n</ul>\\n\\n    then <code class=\\\"code\\\">bscanf Scanning.stdin &quot;%d&quot; f</code> reads an integer <code class=\\\"code\\\">n</code> from the\\n    standard input and returns <code class=\\\"code\\\">f n</code> (that is <code class=\\\"code\\\">n + 1</code>). Thus, if we\\n    evaluate <code class=\\\"code\\\">bscanf stdin &quot;%d&quot; f</code>, and then enter <code class=\\\"code\\\">41</code> at the\\n    keyboard, we get <code class=\\\"code\\\">42</code> as the final result.<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Formattedinputasafunctionalfeature\\\">Formatted input as a functional feature</div><br>\\n<br>\\nThe OCaml scanning facility is reminiscent of the corresponding C feature.\\n    However, it is also largely different, simpler, and yet more powerful:\\n    the formatted input functions are higher-order functionals and the\\n    parameter passing mechanism is just the regular function application not\\n    the variable assignment based mechanism which is typical for formatted\\n    input in imperative languages; the OCaml format strings also feature\\n    useful additions to easily define complex tokens; as expected within a\\n    functional programming language, the formatted input functions also\\n    support polymorphism, in particular arbitrary interaction with\\n    polymorphic user-defined scanners. Furthermore, the OCaml formatted input\\n    facility is fully type-checked at compile time.<br>\\n<br>\\n<h6 id=\\\"6_Formattedinputchannel\\\">Formatted input channel</h6><br>\\n\\n<pre><span class=\\\"keyword\\\">module</span> Scanning: sig .. end</pre><br>\\n<h6 id=\\\"6_Typeofformattedinputfunctions\\\">Type of formatted input functions</h6><br>\\n\\n<pre><span class=\\\"keyword\\\">type</span> scanner &apos;a &apos;b &apos;c &apos;d = Pervasives.format6 &apos;a Scanning.in_channel &apos;b &apos;c (&apos;a =&gt; &apos;d) &apos;d =&gt; &apos;c;\\n</pre>\\n<div class=\\\"info \\\">\\nThe type of formatted input scanners: <code class=\\\"code\\\">(&apos;a, &apos;b, &apos;c, &apos;d) scanner</code>\\n    is the type of a formatted input function that reads from some\\n    formatted input channel according to some format string; more\\n    precisely, if <code class=\\\"code\\\">scan</code> is some formatted input function, then <code class=\\\"code\\\">scan\\n    ic fmt f</code> applies <code class=\\\"code\\\">f</code> to the arguments specified by the format\\n    string <code class=\\\"code\\\">fmt</code>, when <code class=\\\"code\\\">scan</code> has read those arguments from the\\n    formatted input channel <code class=\\\"code\\\">ic</code>.\\n<p>\\n\\n    For instance, the <code class=\\\"code\\\">scanf</code> function below has type <code class=\\\"code\\\">(&apos;a, &apos;b, &apos;c, &apos;d)\\n    scanner</code>, since it is a formatted input function that reads from\\n    <code class=\\\"code\\\">Scanning.stdin</code>: <code class=\\\"code\\\">scanf fmt f</code> applies <code class=\\\"code\\\">f</code> to the arguments specified by\\n    <code class=\\\"code\\\">fmt</code>, reading those arguments from <code class=\\\"code\\\">Pervasives.stdin</code> as expected.\\n</p><p>\\n\\n    If the format <code class=\\\"code\\\">fmt</code> has some <code class=\\\"code\\\">%r</code> indications, the corresponding input\\n    functions must be provided before the receiver <code class=\\\"code\\\">f</code> argument. For\\n    instance, if <code class=\\\"code\\\">read_elem</code> is an input function for values of type <code class=\\\"code\\\">t</code>,\\n    then <code class=\\\"code\\\">bscanf ic &quot;%r;&quot; read_elem f</code> reads a value <code class=\\\"code\\\">v</code> of type <code class=\\\"code\\\">t</code> followed\\n    by a <code class=\\\"code\\\">&apos;;&apos;</code> character, and returns <code class=\\\"code\\\">f v</code>.<br>\\n<b>Since</b> 3.10.0<br>\\n</p></div>\\n\\n\\n<pre><span class=\\\"keyword\\\">exception</span> Scan_failure string;\\n</pre>\\n<div class=\\\"info \\\">\\nThe exception that formatted input functions raise when the input cannot\\n    be read according to the given format.<br>\\n</div>\\n<br>\\n<h6 id=\\\"6_Thegeneralformattedinputfunction\\\">The general formatted input function</h6><br>\\n\\n<pre><span class=\\\"keyword\\\">let</span> bscanf: Scanning.in_channel =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">bscanf ic fmt r1 ... rN f</code> reads arguments for the function <code class=\\\"code\\\">f</code>, from the\\n    formatted input channel <code class=\\\"code\\\">ic</code>, according to the format string <code class=\\\"code\\\">fmt</code>, and\\n    applies <code class=\\\"code\\\">f</code> to these values.\\n    The result of this call to <code class=\\\"code\\\">f</code> is returned as the result of the entire\\n    <code class=\\\"code\\\">bscanf</code> call.\\n    For instance, if <code class=\\\"code\\\">f</code> is the function <code class=\\\"code\\\">fun s i -&gt; i + 1</code>, then\\n    <code class=\\\"code\\\">Scanf.sscanf &quot;x=  1&quot; &quot;%s = %i&quot; f</code> returns <code class=\\\"code\\\">2</code>.\\n<p>\\n\\n    Arguments <code class=\\\"code\\\">r1</code> to <code class=\\\"code\\\">rN</code> are user-defined input functions that read the\\n    argument corresponding to the <code class=\\\"code\\\">%r</code> conversions specified in the format\\n    string.<br>\\n</p></div>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\nAs mentioned above, a plain character in the format string is just\\n    matched with the next character of the input; however, two characters are\\n    special exceptions to this rule: the space character (<code class=\\\"code\\\">&apos; &apos;</code> or ASCII code\\n    32) and the line feed character (<code class=\\\"code\\\">&apos;\\\\n&apos;</code> or ASCII code 10).\\n    A space does not match a single space character, but any amount of\\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\\n    string matches <em>any number</em> of tab, space, line feed and carriage\\n    return characters. Similarly, a line feed character in the format string\\n    matches either a single line feed or a carriage return followed by a line\\n    feed.\\n<p>\\n\\n    Matching <em>any</em> amount of whitespace, a space in the format string\\n    also matches no amount of whitespace at all; hence, the call <code class=\\\"code\\\">bscanf ib\\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class=\\\"code\\\">1</code> when reading an\\n    input with various whitespace in it, such as <code class=\\\"code\\\">Price = 1 $</code>,\\n    <code class=\\\"code\\\">Price  =  1    $</code>, or even <code class=\\\"code\\\">Price=1$</code>.<br>\\n<br>\\n</p><h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\nAs mentioned above, a plain character in the format string is just\\n    matched with the next character of the input; however, two characters are\\n    special exceptions to this rule: the space character (<code class=\\\"code\\\">&apos; &apos;</code> or ASCII code\\n    32) and the line feed character (<code class=\\\"code\\\">&apos;\\\\n&apos;</code> or ASCII code 10).\\n    A space does not match a single space character, but any amount of\\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\\n    string matches <em>any number</em> of tab, space, line feed and carriage\\n    return characters. Similarly, a line feed character in the format string\\n    matches either a single line feed or a carriage return followed by a line\\n    feed.\\n<p>\\n\\n    Matching <em>any</em> amount of whitespace, a space in the format string\\n    also matches no amount of whitespace at all; hence, the call <code class=\\\"code\\\">bscanf ib\\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class=\\\"code\\\">1</code> when reading an\\n    input with various whitespace in it, such as <code class=\\\"code\\\">Price = 1 $</code>,\\n    <code class=\\\"code\\\">Price  =  1    $</code>, or even <code class=\\\"code\\\">Price=1$</code>.<br>\\n<br>\\n</p><div class=\\\"h7\\\" id=\\\"conversion\\\">Conversion specifications in format strings</div><br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\nAs mentioned above, a plain character in the format string is just\\n    matched with the next character of the input; however, two characters are\\n    special exceptions to this rule: the space character (<code class=\\\"code\\\">&apos; &apos;</code> or ASCII code\\n    32) and the line feed character (<code class=\\\"code\\\">&apos;\\\\n&apos;</code> or ASCII code 10).\\n    A space does not match a single space character, but any amount of\\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\\n    string matches <em>any number</em> of tab, space, line feed and carriage\\n    return characters. Similarly, a line feed character in the format string\\n    matches either a single line feed or a carriage return followed by a line\\n    feed.\\n<p>\\n\\n    Matching <em>any</em> amount of whitespace, a space in the format string\\n    also matches no amount of whitespace at all; hence, the call <code class=\\\"code\\\">bscanf ib\\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class=\\\"code\\\">1</code> when reading an\\n    input with various whitespace in it, such as <code class=\\\"code\\\">Price = 1 $</code>,\\n    <code class=\\\"code\\\">Price  =  1    $</code>, or even <code class=\\\"code\\\">Price=1$</code>.<br>\\n<br>\\n</p><div class=\\\"h7\\\" id=\\\"conversion\\\">Conversion specifications in format strings</div><br>\\n<br>\\nConversion specifications consist in the <code class=\\\"code\\\">%</code> character, followed by\\n    an optional flag, an optional field width, and followed by one or\\n    two conversion characters. The conversion characters and their\\n    meanings are:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">d</code>: reads an optionally signed decimal integer.</li>\\n<li><code class=\\\"code\\\">i</code>: reads an optionally signed integer\\n      (usual input conventions for decimal (<code class=\\\"code\\\">0-9</code>+), hexadecimal\\n       (<code class=\\\"code\\\">0x[0-9a-f]+</code> and <code class=\\\"code\\\">0X[0-9A-F]+</code>), octal (<code class=\\\"code\\\">0o[0-7]+</code>), and binary\\n       (<code class=\\\"code\\\">0b[0-1]+</code>) notations are understood).</li>\\n<li><code class=\\\"code\\\">u</code>: reads an unsigned decimal integer.</li>\\n<li><code class=\\\"code\\\">x</code> or <code class=\\\"code\\\">X</code>: reads an unsigned hexadecimal integer (<code class=\\\"code\\\">[0-9a-fA-F]+</code>).</li>\\n<li><code class=\\\"code\\\">o</code>: reads an unsigned octal integer (<code class=\\\"code\\\">[0-7]+</code>).</li>\\n<li><code class=\\\"code\\\">s</code>: reads a string argument that spreads as much as possible, until the\\n      following bounding condition holds: <ul>\\n<li>a whitespace has been found (see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>a scanning indication (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>) has been\\n         encountered,</li>\\n<li>the end-of-input has been reached.</li>\\n</ul>\\n\\n      Hence, this conversion always succeeds: it returns an empty\\n      string if the bounding condition holds when the scan begins.</li>\\n<li><code class=\\\"code\\\">S</code>: reads a delimited string argument (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">c</code>: reads a single character. To test the current input character\\n      without reading it, specify a null field width, i.e. use\\n      specification <code class=\\\"code\\\">%0c</code>. Raise <code class=\\\"code\\\">Invalid_argument</code>, if the field width\\n      specification is greater than 1.</li>\\n<li><code class=\\\"code\\\">C</code>: reads a single delimited character (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">f</code>, <code class=\\\"code\\\">e</code>, <code class=\\\"code\\\">E</code>, <code class=\\\"code\\\">g</code>, <code class=\\\"code\\\">G</code>: reads an optionally signed\\n      floating-point number in decimal notation, in the style <code class=\\\"code\\\">dddd.ddd\\n      e/E+-dd</code>.</li>\\n<li><code class=\\\"code\\\">F</code>: reads a floating point number according to the lexical\\n      conventions of OCaml (hence the decimal point is mandatory if the\\n      exponent part is not mentioned).</li>\\n<li><code class=\\\"code\\\">B</code>: reads a boolean argument (<code class=\\\"code\\\">true</code> or <code class=\\\"code\\\">false</code>).</li>\\n<li><code class=\\\"code\\\">b</code>: reads a boolean argument (for backward compatibility; do not use\\n      in new programs).</li>\\n<li><code class=\\\"code\\\">ld</code>, <code class=\\\"code\\\">li</code>, <code class=\\\"code\\\">lu</code>, <code class=\\\"code\\\">lx</code>, <code class=\\\"code\\\">lX</code>, <code class=\\\"code\\\">lo</code>: reads an <code class=\\\"code\\\">int32</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">nd</code>, <code class=\\\"code\\\">ni</code>, <code class=\\\"code\\\">nu</code>, <code class=\\\"code\\\">nx</code>, <code class=\\\"code\\\">nX</code>, <code class=\\\"code\\\">no</code>: reads a <code class=\\\"code\\\">nativeint</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">Ld</code>, <code class=\\\"code\\\">Li</code>, <code class=\\\"code\\\">Lu</code>, <code class=\\\"code\\\">Lx</code>, <code class=\\\"code\\\">LX</code>, <code class=\\\"code\\\">Lo</code>: reads an <code class=\\\"code\\\">int64</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">[ range ]</code>: reads characters that matches one of the characters\\n      mentioned in the range of characters <code class=\\\"code\\\">range</code> (or not mentioned in\\n      it, if the range starts with <code class=\\\"code\\\">^</code>). Reads a <code class=\\\"code\\\">string</code> that can be\\n      empty, if the next input character does not match the range. The set of\\n      characters from <code class=\\\"code\\\">c1</code> to <code class=\\\"code\\\">c2</code> (inclusively) is denoted by <code class=\\\"code\\\">c1-c2</code>.\\n      Hence, <code class=\\\"code\\\">%[0-9]</code> returns a string representing a decimal number\\n      or an empty string if no decimal digit is found; similarly,\\n      <code class=\\\"code\\\">%[0-9a-f]</code> returns a string of hexadecimal digits.\\n      If a closing bracket appears in a range, it must occur as the\\n      first character of the range (or just after the <code class=\\\"code\\\">^</code> in case of\\n      range negation); hence <code class=\\\"code\\\">[]]</code> matches a <code class=\\\"code\\\">]</code> character and\\n      <code class=\\\"code\\\">[^]]</code> matches any character that is not <code class=\\\"code\\\">]</code>.\\n      Use <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code> to include a <code class=\\\"code\\\">%</code> or a <code class=\\\"code\\\">@</code> in a range.</li>\\n<li><code class=\\\"code\\\">r</code>: user-defined reader. Takes the next <code class=\\\"code\\\">ri</code> formatted input\\n      function and applies it to the scanning buffer <code class=\\\"code\\\">ib</code> to read the\\n      next argument. The input function <code class=\\\"code\\\">ri</code> must therefore have type\\n      <code class=\\\"code\\\">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class=\\\"code\\\">&apos;a</code>.</li>\\n<li><code class=\\\"code\\\">{ fmt %}</code>: reads a format string argument. The format string\\n      read must have the same type as the format string specification\\n      <code class=\\\"code\\\">fmt</code>. For instance, <code class=\\\"code\\\">&quot;%{ %i %}&quot;</code> reads any format string that\\n      can read a value of type <code class=\\\"code\\\">int</code>; hence, if <code class=\\\"code\\\">s</code> is the string\\n      <code class=\\\"code\\\">&quot;fmt:\\\\&quot;number is %u\\\\&quot;&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\\n      succeeds and returns the format string <code class=\\\"code\\\">&quot;number is %u&quot;</code>.</li>\\n<li><code class=\\\"code\\\">( fmt %)</code>: scanning sub-format substitution.\\n      Reads a format string <code class=\\\"code\\\">rf</code> in the input, then goes on scanning with\\n      <code class=\\\"code\\\">rf</code> instead of scanning with <code class=\\\"code\\\">fmt</code>.\\n      The format string <code class=\\\"code\\\">rf</code> must have the same type as the format string\\n      specification <code class=\\\"code\\\">fmt</code> that it replaces.\\n      For instance, <code class=\\\"code\\\">&quot;%( %i %)&quot;</code> reads any format string that can read a value\\n      of type <code class=\\\"code\\\">int</code>.\\n      The conversion returns the format string read <code class=\\\"code\\\">rf</code>, and then a value\\n      read using <code class=\\\"code\\\">rf</code>.\\n      Hence, if <code class=\\\"code\\\">s</code> is the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then\\n      <code class=\\\"code\\\">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\\n      <code class=\\\"code\\\">(&quot;%4d&quot;, 1234)</code>.\\n      This behaviour is not mere format substitution, since the conversion\\n      returns the format string read as additional argument. If you need\\n      pure format substitution, use special flag <code class=\\\"code\\\">_</code> to discard the\\n      extraneous argument: conversion <code class=\\\"code\\\">%_( fmt %)</code> reads a format string\\n      <code class=\\\"code\\\">rf</code> and then behaves the same as format string <code class=\\\"code\\\">rf</code>.  Hence, if <code class=\\\"code\\\">s</code> is\\n      the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\\n      simply equivalent to <code class=\\\"code\\\">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\\n<li><code class=\\\"code\\\">l</code>: returns the number of lines read so far.</li>\\n<li><code class=\\\"code\\\">n</code>: returns the number of characters read so far.</li>\\n<li><code class=\\\"code\\\">N</code> or <code class=\\\"code\\\">L</code>: returns the number of tokens read so far.</li>\\n<li><code class=\\\"code\\\">!</code>: matches the end of input condition.</li>\\n<li><code class=\\\"code\\\">%</code>: matches one <code class=\\\"code\\\">%</code> character in the input.</li>\\n<li><code class=\\\"code\\\">@</code>: matches one <code class=\\\"code\\\">@</code> character in the input.</li>\\n<li><code class=\\\"code\\\">,</code>: does nothing.</li>\\n</ul>\\n\\n    Following the <code class=\\\"code\\\">%</code> character that introduces a conversion, there may be\\n    the special flag <code class=\\\"code\\\">_</code>: the conversion that follows occurs as usual,\\n    but the resulting value is discarded.\\n    For instance, if <code class=\\\"code\\\">f</code> is the function <code class=\\\"code\\\">fun i -&gt; i + 1</code>, and <code class=\\\"code\\\">s</code> is the\\n    string <code class=\\\"code\\\">&quot;x = 1&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class=\\\"code\\\">2</code>.\\n<p>\\n\\n    The field width is composed of an optional integer literal\\n    indicating the maximal width of the token to read.\\n    For instance, <code class=\\\"code\\\">%6d</code> reads an integer, having at most 6 decimal digits;\\n    <code class=\\\"code\\\">%4f</code> reads a float with at most 4 characters; and <code class=\\\"code\\\">%8[\\\\000-\\\\255]</code>\\n    returns the next 8 characters (or all the characters still available,\\n    if fewer than 8 characters are available in the input).\\n</p><p>\\n\\n    Notes:\\n</p><p>\\n</p><ul>\\n<li>as mentioned above, a <code class=\\\"code\\\">%s</code> conversion always succeeds, even if there is\\n      nothing to read in the input: in this case, it simply returns <code class=\\\"code\\\">&quot;&quot;</code>.</li>\\n</ul>\\n<ul>\\n<li>in addition to the relevant digits, <code class=\\\"code\\\">&apos;_&apos;</code> characters may appear\\n    inside numbers (this is reminiscent to the usual OCaml lexical\\n    conventions). If stricter scanning is desired, use the range\\n    conversion facility instead of the number conversions.</li>\\n</ul>\\n<ul>\\n<li>the <code class=\\\"code\\\">scanf</code> facility is not intended for heavy duty lexical\\n    analysis and parsing. If it appears not expressive enough for your\\n    needs, several alternative exists: regular expressions (module\\n    <code class=\\\"code\\\">Str</code>), stream parsers, <code class=\\\"code\\\">ocamllex</code>-generated lexers,\\n    <code class=\\\"code\\\">ocamlyacc</code>-generated parsers.</li>\\n</ul>\\n<br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\nAs mentioned above, a plain character in the format string is just\\n    matched with the next character of the input; however, two characters are\\n    special exceptions to this rule: the space character (<code class=\\\"code\\\">&apos; &apos;</code> or ASCII code\\n    32) and the line feed character (<code class=\\\"code\\\">&apos;\\\\n&apos;</code> or ASCII code 10).\\n    A space does not match a single space character, but any amount of\\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\\n    string matches <em>any number</em> of tab, space, line feed and carriage\\n    return characters. Similarly, a line feed character in the format string\\n    matches either a single line feed or a carriage return followed by a line\\n    feed.\\n<p>\\n\\n    Matching <em>any</em> amount of whitespace, a space in the format string\\n    also matches no amount of whitespace at all; hence, the call <code class=\\\"code\\\">bscanf ib\\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class=\\\"code\\\">1</code> when reading an\\n    input with various whitespace in it, such as <code class=\\\"code\\\">Price = 1 $</code>,\\n    <code class=\\\"code\\\">Price  =  1    $</code>, or even <code class=\\\"code\\\">Price=1$</code>.<br>\\n<br>\\n</p><div class=\\\"h7\\\" id=\\\"conversion\\\">Conversion specifications in format strings</div><br>\\n<br>\\nConversion specifications consist in the <code class=\\\"code\\\">%</code> character, followed by\\n    an optional flag, an optional field width, and followed by one or\\n    two conversion characters. The conversion characters and their\\n    meanings are:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">d</code>: reads an optionally signed decimal integer.</li>\\n<li><code class=\\\"code\\\">i</code>: reads an optionally signed integer\\n      (usual input conventions for decimal (<code class=\\\"code\\\">0-9</code>+), hexadecimal\\n       (<code class=\\\"code\\\">0x[0-9a-f]+</code> and <code class=\\\"code\\\">0X[0-9A-F]+</code>), octal (<code class=\\\"code\\\">0o[0-7]+</code>), and binary\\n       (<code class=\\\"code\\\">0b[0-1]+</code>) notations are understood).</li>\\n<li><code class=\\\"code\\\">u</code>: reads an unsigned decimal integer.</li>\\n<li><code class=\\\"code\\\">x</code> or <code class=\\\"code\\\">X</code>: reads an unsigned hexadecimal integer (<code class=\\\"code\\\">[0-9a-fA-F]+</code>).</li>\\n<li><code class=\\\"code\\\">o</code>: reads an unsigned octal integer (<code class=\\\"code\\\">[0-7]+</code>).</li>\\n<li><code class=\\\"code\\\">s</code>: reads a string argument that spreads as much as possible, until the\\n      following bounding condition holds: <ul>\\n<li>a whitespace has been found (see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>a scanning indication (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>) has been\\n         encountered,</li>\\n<li>the end-of-input has been reached.</li>\\n</ul>\\n\\n      Hence, this conversion always succeeds: it returns an empty\\n      string if the bounding condition holds when the scan begins.</li>\\n<li><code class=\\\"code\\\">S</code>: reads a delimited string argument (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">c</code>: reads a single character. To test the current input character\\n      without reading it, specify a null field width, i.e. use\\n      specification <code class=\\\"code\\\">%0c</code>. Raise <code class=\\\"code\\\">Invalid_argument</code>, if the field width\\n      specification is greater than 1.</li>\\n<li><code class=\\\"code\\\">C</code>: reads a single delimited character (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">f</code>, <code class=\\\"code\\\">e</code>, <code class=\\\"code\\\">E</code>, <code class=\\\"code\\\">g</code>, <code class=\\\"code\\\">G</code>: reads an optionally signed\\n      floating-point number in decimal notation, in the style <code class=\\\"code\\\">dddd.ddd\\n      e/E+-dd</code>.</li>\\n<li><code class=\\\"code\\\">F</code>: reads a floating point number according to the lexical\\n      conventions of OCaml (hence the decimal point is mandatory if the\\n      exponent part is not mentioned).</li>\\n<li><code class=\\\"code\\\">B</code>: reads a boolean argument (<code class=\\\"code\\\">true</code> or <code class=\\\"code\\\">false</code>).</li>\\n<li><code class=\\\"code\\\">b</code>: reads a boolean argument (for backward compatibility; do not use\\n      in new programs).</li>\\n<li><code class=\\\"code\\\">ld</code>, <code class=\\\"code\\\">li</code>, <code class=\\\"code\\\">lu</code>, <code class=\\\"code\\\">lx</code>, <code class=\\\"code\\\">lX</code>, <code class=\\\"code\\\">lo</code>: reads an <code class=\\\"code\\\">int32</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">nd</code>, <code class=\\\"code\\\">ni</code>, <code class=\\\"code\\\">nu</code>, <code class=\\\"code\\\">nx</code>, <code class=\\\"code\\\">nX</code>, <code class=\\\"code\\\">no</code>: reads a <code class=\\\"code\\\">nativeint</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">Ld</code>, <code class=\\\"code\\\">Li</code>, <code class=\\\"code\\\">Lu</code>, <code class=\\\"code\\\">Lx</code>, <code class=\\\"code\\\">LX</code>, <code class=\\\"code\\\">Lo</code>: reads an <code class=\\\"code\\\">int64</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">[ range ]</code>: reads characters that matches one of the characters\\n      mentioned in the range of characters <code class=\\\"code\\\">range</code> (or not mentioned in\\n      it, if the range starts with <code class=\\\"code\\\">^</code>). Reads a <code class=\\\"code\\\">string</code> that can be\\n      empty, if the next input character does not match the range. The set of\\n      characters from <code class=\\\"code\\\">c1</code> to <code class=\\\"code\\\">c2</code> (inclusively) is denoted by <code class=\\\"code\\\">c1-c2</code>.\\n      Hence, <code class=\\\"code\\\">%[0-9]</code> returns a string representing a decimal number\\n      or an empty string if no decimal digit is found; similarly,\\n      <code class=\\\"code\\\">%[0-9a-f]</code> returns a string of hexadecimal digits.\\n      If a closing bracket appears in a range, it must occur as the\\n      first character of the range (or just after the <code class=\\\"code\\\">^</code> in case of\\n      range negation); hence <code class=\\\"code\\\">[]]</code> matches a <code class=\\\"code\\\">]</code> character and\\n      <code class=\\\"code\\\">[^]]</code> matches any character that is not <code class=\\\"code\\\">]</code>.\\n      Use <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code> to include a <code class=\\\"code\\\">%</code> or a <code class=\\\"code\\\">@</code> in a range.</li>\\n<li><code class=\\\"code\\\">r</code>: user-defined reader. Takes the next <code class=\\\"code\\\">ri</code> formatted input\\n      function and applies it to the scanning buffer <code class=\\\"code\\\">ib</code> to read the\\n      next argument. The input function <code class=\\\"code\\\">ri</code> must therefore have type\\n      <code class=\\\"code\\\">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class=\\\"code\\\">&apos;a</code>.</li>\\n<li><code class=\\\"code\\\">{ fmt %}</code>: reads a format string argument. The format string\\n      read must have the same type as the format string specification\\n      <code class=\\\"code\\\">fmt</code>. For instance, <code class=\\\"code\\\">&quot;%{ %i %}&quot;</code> reads any format string that\\n      can read a value of type <code class=\\\"code\\\">int</code>; hence, if <code class=\\\"code\\\">s</code> is the string\\n      <code class=\\\"code\\\">&quot;fmt:\\\\&quot;number is %u\\\\&quot;&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\\n      succeeds and returns the format string <code class=\\\"code\\\">&quot;number is %u&quot;</code>.</li>\\n<li><code class=\\\"code\\\">( fmt %)</code>: scanning sub-format substitution.\\n      Reads a format string <code class=\\\"code\\\">rf</code> in the input, then goes on scanning with\\n      <code class=\\\"code\\\">rf</code> instead of scanning with <code class=\\\"code\\\">fmt</code>.\\n      The format string <code class=\\\"code\\\">rf</code> must have the same type as the format string\\n      specification <code class=\\\"code\\\">fmt</code> that it replaces.\\n      For instance, <code class=\\\"code\\\">&quot;%( %i %)&quot;</code> reads any format string that can read a value\\n      of type <code class=\\\"code\\\">int</code>.\\n      The conversion returns the format string read <code class=\\\"code\\\">rf</code>, and then a value\\n      read using <code class=\\\"code\\\">rf</code>.\\n      Hence, if <code class=\\\"code\\\">s</code> is the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then\\n      <code class=\\\"code\\\">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\\n      <code class=\\\"code\\\">(&quot;%4d&quot;, 1234)</code>.\\n      This behaviour is not mere format substitution, since the conversion\\n      returns the format string read as additional argument. If you need\\n      pure format substitution, use special flag <code class=\\\"code\\\">_</code> to discard the\\n      extraneous argument: conversion <code class=\\\"code\\\">%_( fmt %)</code> reads a format string\\n      <code class=\\\"code\\\">rf</code> and then behaves the same as format string <code class=\\\"code\\\">rf</code>.  Hence, if <code class=\\\"code\\\">s</code> is\\n      the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\\n      simply equivalent to <code class=\\\"code\\\">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\\n<li><code class=\\\"code\\\">l</code>: returns the number of lines read so far.</li>\\n<li><code class=\\\"code\\\">n</code>: returns the number of characters read so far.</li>\\n<li><code class=\\\"code\\\">N</code> or <code class=\\\"code\\\">L</code>: returns the number of tokens read so far.</li>\\n<li><code class=\\\"code\\\">!</code>: matches the end of input condition.</li>\\n<li><code class=\\\"code\\\">%</code>: matches one <code class=\\\"code\\\">%</code> character in the input.</li>\\n<li><code class=\\\"code\\\">@</code>: matches one <code class=\\\"code\\\">@</code> character in the input.</li>\\n<li><code class=\\\"code\\\">,</code>: does nothing.</li>\\n</ul>\\n\\n    Following the <code class=\\\"code\\\">%</code> character that introduces a conversion, there may be\\n    the special flag <code class=\\\"code\\\">_</code>: the conversion that follows occurs as usual,\\n    but the resulting value is discarded.\\n    For instance, if <code class=\\\"code\\\">f</code> is the function <code class=\\\"code\\\">fun i -&gt; i + 1</code>, and <code class=\\\"code\\\">s</code> is the\\n    string <code class=\\\"code\\\">&quot;x = 1&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class=\\\"code\\\">2</code>.\\n<p>\\n\\n    The field width is composed of an optional integer literal\\n    indicating the maximal width of the token to read.\\n    For instance, <code class=\\\"code\\\">%6d</code> reads an integer, having at most 6 decimal digits;\\n    <code class=\\\"code\\\">%4f</code> reads a float with at most 4 characters; and <code class=\\\"code\\\">%8[\\\\000-\\\\255]</code>\\n    returns the next 8 characters (or all the characters still available,\\n    if fewer than 8 characters are available in the input).\\n</p><p>\\n\\n    Notes:\\n</p><p>\\n</p><ul>\\n<li>as mentioned above, a <code class=\\\"code\\\">%s</code> conversion always succeeds, even if there is\\n      nothing to read in the input: in this case, it simply returns <code class=\\\"code\\\">&quot;&quot;</code>.</li>\\n</ul>\\n<ul>\\n<li>in addition to the relevant digits, <code class=\\\"code\\\">&apos;_&apos;</code> characters may appear\\n    inside numbers (this is reminiscent to the usual OCaml lexical\\n    conventions). If stricter scanning is desired, use the range\\n    conversion facility instead of the number conversions.</li>\\n</ul>\\n<ul>\\n<li>the <code class=\\\"code\\\">scanf</code> facility is not intended for heavy duty lexical\\n    analysis and parsing. If it appears not expressive enough for your\\n    needs, several alternative exists: regular expressions (module\\n    <code class=\\\"code\\\">Str</code>), stream parsers, <code class=\\\"code\\\">ocamllex</code>-generated lexers,\\n    <code class=\\\"code\\\">ocamlyacc</code>-generated parsers.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"indication\\\">Scanning indications in format strings</div><br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\nAs mentioned above, a plain character in the format string is just\\n    matched with the next character of the input; however, two characters are\\n    special exceptions to this rule: the space character (<code class=\\\"code\\\">&apos; &apos;</code> or ASCII code\\n    32) and the line feed character (<code class=\\\"code\\\">&apos;\\\\n&apos;</code> or ASCII code 10).\\n    A space does not match a single space character, but any amount of\\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\\n    string matches <em>any number</em> of tab, space, line feed and carriage\\n    return characters. Similarly, a line feed character in the format string\\n    matches either a single line feed or a carriage return followed by a line\\n    feed.\\n<p>\\n\\n    Matching <em>any</em> amount of whitespace, a space in the format string\\n    also matches no amount of whitespace at all; hence, the call <code class=\\\"code\\\">bscanf ib\\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class=\\\"code\\\">1</code> when reading an\\n    input with various whitespace in it, such as <code class=\\\"code\\\">Price = 1 $</code>,\\n    <code class=\\\"code\\\">Price  =  1    $</code>, or even <code class=\\\"code\\\">Price=1$</code>.<br>\\n<br>\\n</p><div class=\\\"h7\\\" id=\\\"conversion\\\">Conversion specifications in format strings</div><br>\\n<br>\\nConversion specifications consist in the <code class=\\\"code\\\">%</code> character, followed by\\n    an optional flag, an optional field width, and followed by one or\\n    two conversion characters. The conversion characters and their\\n    meanings are:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">d</code>: reads an optionally signed decimal integer.</li>\\n<li><code class=\\\"code\\\">i</code>: reads an optionally signed integer\\n      (usual input conventions for decimal (<code class=\\\"code\\\">0-9</code>+), hexadecimal\\n       (<code class=\\\"code\\\">0x[0-9a-f]+</code> and <code class=\\\"code\\\">0X[0-9A-F]+</code>), octal (<code class=\\\"code\\\">0o[0-7]+</code>), and binary\\n       (<code class=\\\"code\\\">0b[0-1]+</code>) notations are understood).</li>\\n<li><code class=\\\"code\\\">u</code>: reads an unsigned decimal integer.</li>\\n<li><code class=\\\"code\\\">x</code> or <code class=\\\"code\\\">X</code>: reads an unsigned hexadecimal integer (<code class=\\\"code\\\">[0-9a-fA-F]+</code>).</li>\\n<li><code class=\\\"code\\\">o</code>: reads an unsigned octal integer (<code class=\\\"code\\\">[0-7]+</code>).</li>\\n<li><code class=\\\"code\\\">s</code>: reads a string argument that spreads as much as possible, until the\\n      following bounding condition holds: <ul>\\n<li>a whitespace has been found (see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>a scanning indication (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>) has been\\n         encountered,</li>\\n<li>the end-of-input has been reached.</li>\\n</ul>\\n\\n      Hence, this conversion always succeeds: it returns an empty\\n      string if the bounding condition holds when the scan begins.</li>\\n<li><code class=\\\"code\\\">S</code>: reads a delimited string argument (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">c</code>: reads a single character. To test the current input character\\n      without reading it, specify a null field width, i.e. use\\n      specification <code class=\\\"code\\\">%0c</code>. Raise <code class=\\\"code\\\">Invalid_argument</code>, if the field width\\n      specification is greater than 1.</li>\\n<li><code class=\\\"code\\\">C</code>: reads a single delimited character (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">f</code>, <code class=\\\"code\\\">e</code>, <code class=\\\"code\\\">E</code>, <code class=\\\"code\\\">g</code>, <code class=\\\"code\\\">G</code>: reads an optionally signed\\n      floating-point number in decimal notation, in the style <code class=\\\"code\\\">dddd.ddd\\n      e/E+-dd</code>.</li>\\n<li><code class=\\\"code\\\">F</code>: reads a floating point number according to the lexical\\n      conventions of OCaml (hence the decimal point is mandatory if the\\n      exponent part is not mentioned).</li>\\n<li><code class=\\\"code\\\">B</code>: reads a boolean argument (<code class=\\\"code\\\">true</code> or <code class=\\\"code\\\">false</code>).</li>\\n<li><code class=\\\"code\\\">b</code>: reads a boolean argument (for backward compatibility; do not use\\n      in new programs).</li>\\n<li><code class=\\\"code\\\">ld</code>, <code class=\\\"code\\\">li</code>, <code class=\\\"code\\\">lu</code>, <code class=\\\"code\\\">lx</code>, <code class=\\\"code\\\">lX</code>, <code class=\\\"code\\\">lo</code>: reads an <code class=\\\"code\\\">int32</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">nd</code>, <code class=\\\"code\\\">ni</code>, <code class=\\\"code\\\">nu</code>, <code class=\\\"code\\\">nx</code>, <code class=\\\"code\\\">nX</code>, <code class=\\\"code\\\">no</code>: reads a <code class=\\\"code\\\">nativeint</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">Ld</code>, <code class=\\\"code\\\">Li</code>, <code class=\\\"code\\\">Lu</code>, <code class=\\\"code\\\">Lx</code>, <code class=\\\"code\\\">LX</code>, <code class=\\\"code\\\">Lo</code>: reads an <code class=\\\"code\\\">int64</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">[ range ]</code>: reads characters that matches one of the characters\\n      mentioned in the range of characters <code class=\\\"code\\\">range</code> (or not mentioned in\\n      it, if the range starts with <code class=\\\"code\\\">^</code>). Reads a <code class=\\\"code\\\">string</code> that can be\\n      empty, if the next input character does not match the range. The set of\\n      characters from <code class=\\\"code\\\">c1</code> to <code class=\\\"code\\\">c2</code> (inclusively) is denoted by <code class=\\\"code\\\">c1-c2</code>.\\n      Hence, <code class=\\\"code\\\">%[0-9]</code> returns a string representing a decimal number\\n      or an empty string if no decimal digit is found; similarly,\\n      <code class=\\\"code\\\">%[0-9a-f]</code> returns a string of hexadecimal digits.\\n      If a closing bracket appears in a range, it must occur as the\\n      first character of the range (or just after the <code class=\\\"code\\\">^</code> in case of\\n      range negation); hence <code class=\\\"code\\\">[]]</code> matches a <code class=\\\"code\\\">]</code> character and\\n      <code class=\\\"code\\\">[^]]</code> matches any character that is not <code class=\\\"code\\\">]</code>.\\n      Use <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code> to include a <code class=\\\"code\\\">%</code> or a <code class=\\\"code\\\">@</code> in a range.</li>\\n<li><code class=\\\"code\\\">r</code>: user-defined reader. Takes the next <code class=\\\"code\\\">ri</code> formatted input\\n      function and applies it to the scanning buffer <code class=\\\"code\\\">ib</code> to read the\\n      next argument. The input function <code class=\\\"code\\\">ri</code> must therefore have type\\n      <code class=\\\"code\\\">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class=\\\"code\\\">&apos;a</code>.</li>\\n<li><code class=\\\"code\\\">{ fmt %}</code>: reads a format string argument. The format string\\n      read must have the same type as the format string specification\\n      <code class=\\\"code\\\">fmt</code>. For instance, <code class=\\\"code\\\">&quot;%{ %i %}&quot;</code> reads any format string that\\n      can read a value of type <code class=\\\"code\\\">int</code>; hence, if <code class=\\\"code\\\">s</code> is the string\\n      <code class=\\\"code\\\">&quot;fmt:\\\\&quot;number is %u\\\\&quot;&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\\n      succeeds and returns the format string <code class=\\\"code\\\">&quot;number is %u&quot;</code>.</li>\\n<li><code class=\\\"code\\\">( fmt %)</code>: scanning sub-format substitution.\\n      Reads a format string <code class=\\\"code\\\">rf</code> in the input, then goes on scanning with\\n      <code class=\\\"code\\\">rf</code> instead of scanning with <code class=\\\"code\\\">fmt</code>.\\n      The format string <code class=\\\"code\\\">rf</code> must have the same type as the format string\\n      specification <code class=\\\"code\\\">fmt</code> that it replaces.\\n      For instance, <code class=\\\"code\\\">&quot;%( %i %)&quot;</code> reads any format string that can read a value\\n      of type <code class=\\\"code\\\">int</code>.\\n      The conversion returns the format string read <code class=\\\"code\\\">rf</code>, and then a value\\n      read using <code class=\\\"code\\\">rf</code>.\\n      Hence, if <code class=\\\"code\\\">s</code> is the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then\\n      <code class=\\\"code\\\">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\\n      <code class=\\\"code\\\">(&quot;%4d&quot;, 1234)</code>.\\n      This behaviour is not mere format substitution, since the conversion\\n      returns the format string read as additional argument. If you need\\n      pure format substitution, use special flag <code class=\\\"code\\\">_</code> to discard the\\n      extraneous argument: conversion <code class=\\\"code\\\">%_( fmt %)</code> reads a format string\\n      <code class=\\\"code\\\">rf</code> and then behaves the same as format string <code class=\\\"code\\\">rf</code>.  Hence, if <code class=\\\"code\\\">s</code> is\\n      the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\\n      simply equivalent to <code class=\\\"code\\\">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\\n<li><code class=\\\"code\\\">l</code>: returns the number of lines read so far.</li>\\n<li><code class=\\\"code\\\">n</code>: returns the number of characters read so far.</li>\\n<li><code class=\\\"code\\\">N</code> or <code class=\\\"code\\\">L</code>: returns the number of tokens read so far.</li>\\n<li><code class=\\\"code\\\">!</code>: matches the end of input condition.</li>\\n<li><code class=\\\"code\\\">%</code>: matches one <code class=\\\"code\\\">%</code> character in the input.</li>\\n<li><code class=\\\"code\\\">@</code>: matches one <code class=\\\"code\\\">@</code> character in the input.</li>\\n<li><code class=\\\"code\\\">,</code>: does nothing.</li>\\n</ul>\\n\\n    Following the <code class=\\\"code\\\">%</code> character that introduces a conversion, there may be\\n    the special flag <code class=\\\"code\\\">_</code>: the conversion that follows occurs as usual,\\n    but the resulting value is discarded.\\n    For instance, if <code class=\\\"code\\\">f</code> is the function <code class=\\\"code\\\">fun i -&gt; i + 1</code>, and <code class=\\\"code\\\">s</code> is the\\n    string <code class=\\\"code\\\">&quot;x = 1&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class=\\\"code\\\">2</code>.\\n<p>\\n\\n    The field width is composed of an optional integer literal\\n    indicating the maximal width of the token to read.\\n    For instance, <code class=\\\"code\\\">%6d</code> reads an integer, having at most 6 decimal digits;\\n    <code class=\\\"code\\\">%4f</code> reads a float with at most 4 characters; and <code class=\\\"code\\\">%8[\\\\000-\\\\255]</code>\\n    returns the next 8 characters (or all the characters still available,\\n    if fewer than 8 characters are available in the input).\\n</p><p>\\n\\n    Notes:\\n</p><p>\\n</p><ul>\\n<li>as mentioned above, a <code class=\\\"code\\\">%s</code> conversion always succeeds, even if there is\\n      nothing to read in the input: in this case, it simply returns <code class=\\\"code\\\">&quot;&quot;</code>.</li>\\n</ul>\\n<ul>\\n<li>in addition to the relevant digits, <code class=\\\"code\\\">&apos;_&apos;</code> characters may appear\\n    inside numbers (this is reminiscent to the usual OCaml lexical\\n    conventions). If stricter scanning is desired, use the range\\n    conversion facility instead of the number conversions.</li>\\n</ul>\\n<ul>\\n<li>the <code class=\\\"code\\\">scanf</code> facility is not intended for heavy duty lexical\\n    analysis and parsing. If it appears not expressive enough for your\\n    needs, several alternative exists: regular expressions (module\\n    <code class=\\\"code\\\">Str</code>), stream parsers, <code class=\\\"code\\\">ocamllex</code>-generated lexers,\\n    <code class=\\\"code\\\">ocamlyacc</code>-generated parsers.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"indication\\\">Scanning indications in format strings</div><br>\\n<br>\\nScanning indications appear just after the string conversions <code class=\\\"code\\\">%s</code>\\n    and <code class=\\\"code\\\">%[ range ]</code> to delimit the end of the token. A scanning\\n    indication is introduced by a <code class=\\\"code\\\">@</code> character, followed by some\\n    plain character <code class=\\\"code\\\">c</code>. It means that the string token should end\\n    just before the next matching <code class=\\\"code\\\">c</code> (which is skipped). If no <code class=\\\"code\\\">c</code>\\n    character is encountered, the string token spreads as much as\\n    possible. For instance, <code class=\\\"code\\\">&quot;%s@\\\\t&quot;</code> reads a string up to the next\\n    tab character or to the end of input. If a <code class=\\\"code\\\">@</code> character appears\\n    anywhere else in the format string, it is treated as a plain character.\\n<p>\\n\\n    Note:\\n</p><p>\\n</p><ul>\\n<li>As usual in format strings, <code class=\\\"code\\\">%</code> and <code class=\\\"code\\\">@</code> characters must be escaped\\n    using <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code>; this rule still holds within range specifications\\n    and scanning indications.\\n    For instance, <code class=\\\"code\\\">&quot;%s@%%&quot;</code> reads a string up to the next <code class=\\\"code\\\">%</code> character.</li>\\n<li>The scanning indications introduce slight differences in the syntax of\\n    <code class=\\\"code\\\">Scanf</code> format strings, compared to those used for the <code class=\\\"code\\\">Printf</code>\\n    module. However, the scanning indications are similar to those used in\\n    the <code class=\\\"code\\\">Format</code> module; hence, when producing formatted text to be scanned\\n    by <code class=\\\"code\\\">!Scanf.bscanf</code>, it is wise to use printing functions from the\\n    <code class=\\\"code\\\">Format</code> module (or, if you need to use functions from <code class=\\\"code\\\">Printf</code>, banish\\n    or carefully double check the format strings that contain <code class=\\\"code\\\">&apos;@&apos;</code>\\n    characters).</li>\\n</ul>\\n<br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\nAs mentioned above, a plain character in the format string is just\\n    matched with the next character of the input; however, two characters are\\n    special exceptions to this rule: the space character (<code class=\\\"code\\\">&apos; &apos;</code> or ASCII code\\n    32) and the line feed character (<code class=\\\"code\\\">&apos;\\\\n&apos;</code> or ASCII code 10).\\n    A space does not match a single space character, but any amount of\\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\\n    string matches <em>any number</em> of tab, space, line feed and carriage\\n    return characters. Similarly, a line feed character in the format string\\n    matches either a single line feed or a carriage return followed by a line\\n    feed.\\n<p>\\n\\n    Matching <em>any</em> amount of whitespace, a space in the format string\\n    also matches no amount of whitespace at all; hence, the call <code class=\\\"code\\\">bscanf ib\\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class=\\\"code\\\">1</code> when reading an\\n    input with various whitespace in it, such as <code class=\\\"code\\\">Price = 1 $</code>,\\n    <code class=\\\"code\\\">Price  =  1    $</code>, or even <code class=\\\"code\\\">Price=1$</code>.<br>\\n<br>\\n</p><div class=\\\"h7\\\" id=\\\"conversion\\\">Conversion specifications in format strings</div><br>\\n<br>\\nConversion specifications consist in the <code class=\\\"code\\\">%</code> character, followed by\\n    an optional flag, an optional field width, and followed by one or\\n    two conversion characters. The conversion characters and their\\n    meanings are:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">d</code>: reads an optionally signed decimal integer.</li>\\n<li><code class=\\\"code\\\">i</code>: reads an optionally signed integer\\n      (usual input conventions for decimal (<code class=\\\"code\\\">0-9</code>+), hexadecimal\\n       (<code class=\\\"code\\\">0x[0-9a-f]+</code> and <code class=\\\"code\\\">0X[0-9A-F]+</code>), octal (<code class=\\\"code\\\">0o[0-7]+</code>), and binary\\n       (<code class=\\\"code\\\">0b[0-1]+</code>) notations are understood).</li>\\n<li><code class=\\\"code\\\">u</code>: reads an unsigned decimal integer.</li>\\n<li><code class=\\\"code\\\">x</code> or <code class=\\\"code\\\">X</code>: reads an unsigned hexadecimal integer (<code class=\\\"code\\\">[0-9a-fA-F]+</code>).</li>\\n<li><code class=\\\"code\\\">o</code>: reads an unsigned octal integer (<code class=\\\"code\\\">[0-7]+</code>).</li>\\n<li><code class=\\\"code\\\">s</code>: reads a string argument that spreads as much as possible, until the\\n      following bounding condition holds: <ul>\\n<li>a whitespace has been found (see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>a scanning indication (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>) has been\\n         encountered,</li>\\n<li>the end-of-input has been reached.</li>\\n</ul>\\n\\n      Hence, this conversion always succeeds: it returns an empty\\n      string if the bounding condition holds when the scan begins.</li>\\n<li><code class=\\\"code\\\">S</code>: reads a delimited string argument (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">c</code>: reads a single character. To test the current input character\\n      without reading it, specify a null field width, i.e. use\\n      specification <code class=\\\"code\\\">%0c</code>. Raise <code class=\\\"code\\\">Invalid_argument</code>, if the field width\\n      specification is greater than 1.</li>\\n<li><code class=\\\"code\\\">C</code>: reads a single delimited character (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">f</code>, <code class=\\\"code\\\">e</code>, <code class=\\\"code\\\">E</code>, <code class=\\\"code\\\">g</code>, <code class=\\\"code\\\">G</code>: reads an optionally signed\\n      floating-point number in decimal notation, in the style <code class=\\\"code\\\">dddd.ddd\\n      e/E+-dd</code>.</li>\\n<li><code class=\\\"code\\\">F</code>: reads a floating point number according to the lexical\\n      conventions of OCaml (hence the decimal point is mandatory if the\\n      exponent part is not mentioned).</li>\\n<li><code class=\\\"code\\\">B</code>: reads a boolean argument (<code class=\\\"code\\\">true</code> or <code class=\\\"code\\\">false</code>).</li>\\n<li><code class=\\\"code\\\">b</code>: reads a boolean argument (for backward compatibility; do not use\\n      in new programs).</li>\\n<li><code class=\\\"code\\\">ld</code>, <code class=\\\"code\\\">li</code>, <code class=\\\"code\\\">lu</code>, <code class=\\\"code\\\">lx</code>, <code class=\\\"code\\\">lX</code>, <code class=\\\"code\\\">lo</code>: reads an <code class=\\\"code\\\">int32</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">nd</code>, <code class=\\\"code\\\">ni</code>, <code class=\\\"code\\\">nu</code>, <code class=\\\"code\\\">nx</code>, <code class=\\\"code\\\">nX</code>, <code class=\\\"code\\\">no</code>: reads a <code class=\\\"code\\\">nativeint</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">Ld</code>, <code class=\\\"code\\\">Li</code>, <code class=\\\"code\\\">Lu</code>, <code class=\\\"code\\\">Lx</code>, <code class=\\\"code\\\">LX</code>, <code class=\\\"code\\\">Lo</code>: reads an <code class=\\\"code\\\">int64</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">[ range ]</code>: reads characters that matches one of the characters\\n      mentioned in the range of characters <code class=\\\"code\\\">range</code> (or not mentioned in\\n      it, if the range starts with <code class=\\\"code\\\">^</code>). Reads a <code class=\\\"code\\\">string</code> that can be\\n      empty, if the next input character does not match the range. The set of\\n      characters from <code class=\\\"code\\\">c1</code> to <code class=\\\"code\\\">c2</code> (inclusively) is denoted by <code class=\\\"code\\\">c1-c2</code>.\\n      Hence, <code class=\\\"code\\\">%[0-9]</code> returns a string representing a decimal number\\n      or an empty string if no decimal digit is found; similarly,\\n      <code class=\\\"code\\\">%[0-9a-f]</code> returns a string of hexadecimal digits.\\n      If a closing bracket appears in a range, it must occur as the\\n      first character of the range (or just after the <code class=\\\"code\\\">^</code> in case of\\n      range negation); hence <code class=\\\"code\\\">[]]</code> matches a <code class=\\\"code\\\">]</code> character and\\n      <code class=\\\"code\\\">[^]]</code> matches any character that is not <code class=\\\"code\\\">]</code>.\\n      Use <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code> to include a <code class=\\\"code\\\">%</code> or a <code class=\\\"code\\\">@</code> in a range.</li>\\n<li><code class=\\\"code\\\">r</code>: user-defined reader. Takes the next <code class=\\\"code\\\">ri</code> formatted input\\n      function and applies it to the scanning buffer <code class=\\\"code\\\">ib</code> to read the\\n      next argument. The input function <code class=\\\"code\\\">ri</code> must therefore have type\\n      <code class=\\\"code\\\">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class=\\\"code\\\">&apos;a</code>.</li>\\n<li><code class=\\\"code\\\">{ fmt %}</code>: reads a format string argument. The format string\\n      read must have the same type as the format string specification\\n      <code class=\\\"code\\\">fmt</code>. For instance, <code class=\\\"code\\\">&quot;%{ %i %}&quot;</code> reads any format string that\\n      can read a value of type <code class=\\\"code\\\">int</code>; hence, if <code class=\\\"code\\\">s</code> is the string\\n      <code class=\\\"code\\\">&quot;fmt:\\\\&quot;number is %u\\\\&quot;&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\\n      succeeds and returns the format string <code class=\\\"code\\\">&quot;number is %u&quot;</code>.</li>\\n<li><code class=\\\"code\\\">( fmt %)</code>: scanning sub-format substitution.\\n      Reads a format string <code class=\\\"code\\\">rf</code> in the input, then goes on scanning with\\n      <code class=\\\"code\\\">rf</code> instead of scanning with <code class=\\\"code\\\">fmt</code>.\\n      The format string <code class=\\\"code\\\">rf</code> must have the same type as the format string\\n      specification <code class=\\\"code\\\">fmt</code> that it replaces.\\n      For instance, <code class=\\\"code\\\">&quot;%( %i %)&quot;</code> reads any format string that can read a value\\n      of type <code class=\\\"code\\\">int</code>.\\n      The conversion returns the format string read <code class=\\\"code\\\">rf</code>, and then a value\\n      read using <code class=\\\"code\\\">rf</code>.\\n      Hence, if <code class=\\\"code\\\">s</code> is the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then\\n      <code class=\\\"code\\\">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\\n      <code class=\\\"code\\\">(&quot;%4d&quot;, 1234)</code>.\\n      This behaviour is not mere format substitution, since the conversion\\n      returns the format string read as additional argument. If you need\\n      pure format substitution, use special flag <code class=\\\"code\\\">_</code> to discard the\\n      extraneous argument: conversion <code class=\\\"code\\\">%_( fmt %)</code> reads a format string\\n      <code class=\\\"code\\\">rf</code> and then behaves the same as format string <code class=\\\"code\\\">rf</code>.  Hence, if <code class=\\\"code\\\">s</code> is\\n      the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\\n      simply equivalent to <code class=\\\"code\\\">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\\n<li><code class=\\\"code\\\">l</code>: returns the number of lines read so far.</li>\\n<li><code class=\\\"code\\\">n</code>: returns the number of characters read so far.</li>\\n<li><code class=\\\"code\\\">N</code> or <code class=\\\"code\\\">L</code>: returns the number of tokens read so far.</li>\\n<li><code class=\\\"code\\\">!</code>: matches the end of input condition.</li>\\n<li><code class=\\\"code\\\">%</code>: matches one <code class=\\\"code\\\">%</code> character in the input.</li>\\n<li><code class=\\\"code\\\">@</code>: matches one <code class=\\\"code\\\">@</code> character in the input.</li>\\n<li><code class=\\\"code\\\">,</code>: does nothing.</li>\\n</ul>\\n\\n    Following the <code class=\\\"code\\\">%</code> character that introduces a conversion, there may be\\n    the special flag <code class=\\\"code\\\">_</code>: the conversion that follows occurs as usual,\\n    but the resulting value is discarded.\\n    For instance, if <code class=\\\"code\\\">f</code> is the function <code class=\\\"code\\\">fun i -&gt; i + 1</code>, and <code class=\\\"code\\\">s</code> is the\\n    string <code class=\\\"code\\\">&quot;x = 1&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class=\\\"code\\\">2</code>.\\n<p>\\n\\n    The field width is composed of an optional integer literal\\n    indicating the maximal width of the token to read.\\n    For instance, <code class=\\\"code\\\">%6d</code> reads an integer, having at most 6 decimal digits;\\n    <code class=\\\"code\\\">%4f</code> reads a float with at most 4 characters; and <code class=\\\"code\\\">%8[\\\\000-\\\\255]</code>\\n    returns the next 8 characters (or all the characters still available,\\n    if fewer than 8 characters are available in the input).\\n</p><p>\\n\\n    Notes:\\n</p><p>\\n</p><ul>\\n<li>as mentioned above, a <code class=\\\"code\\\">%s</code> conversion always succeeds, even if there is\\n      nothing to read in the input: in this case, it simply returns <code class=\\\"code\\\">&quot;&quot;</code>.</li>\\n</ul>\\n<ul>\\n<li>in addition to the relevant digits, <code class=\\\"code\\\">&apos;_&apos;</code> characters may appear\\n    inside numbers (this is reminiscent to the usual OCaml lexical\\n    conventions). If stricter scanning is desired, use the range\\n    conversion facility instead of the number conversions.</li>\\n</ul>\\n<ul>\\n<li>the <code class=\\\"code\\\">scanf</code> facility is not intended for heavy duty lexical\\n    analysis and parsing. If it appears not expressive enough for your\\n    needs, several alternative exists: regular expressions (module\\n    <code class=\\\"code\\\">Str</code>), stream parsers, <code class=\\\"code\\\">ocamllex</code>-generated lexers,\\n    <code class=\\\"code\\\">ocamlyacc</code>-generated parsers.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"indication\\\">Scanning indications in format strings</div><br>\\n<br>\\nScanning indications appear just after the string conversions <code class=\\\"code\\\">%s</code>\\n    and <code class=\\\"code\\\">%[ range ]</code> to delimit the end of the token. A scanning\\n    indication is introduced by a <code class=\\\"code\\\">@</code> character, followed by some\\n    plain character <code class=\\\"code\\\">c</code>. It means that the string token should end\\n    just before the next matching <code class=\\\"code\\\">c</code> (which is skipped). If no <code class=\\\"code\\\">c</code>\\n    character is encountered, the string token spreads as much as\\n    possible. For instance, <code class=\\\"code\\\">&quot;%s@\\\\t&quot;</code> reads a string up to the next\\n    tab character or to the end of input. If a <code class=\\\"code\\\">@</code> character appears\\n    anywhere else in the format string, it is treated as a plain character.\\n<p>\\n\\n    Note:\\n</p><p>\\n</p><ul>\\n<li>As usual in format strings, <code class=\\\"code\\\">%</code> and <code class=\\\"code\\\">@</code> characters must be escaped\\n    using <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code>; this rule still holds within range specifications\\n    and scanning indications.\\n    For instance, <code class=\\\"code\\\">&quot;%s@%%&quot;</code> reads a string up to the next <code class=\\\"code\\\">%</code> character.</li>\\n<li>The scanning indications introduce slight differences in the syntax of\\n    <code class=\\\"code\\\">Scanf</code> format strings, compared to those used for the <code class=\\\"code\\\">Printf</code>\\n    module. However, the scanning indications are similar to those used in\\n    the <code class=\\\"code\\\">Format</code> module; hence, when producing formatted text to be scanned\\n    by <code class=\\\"code\\\">!Scanf.bscanf</code>, it is wise to use printing functions from the\\n    <code class=\\\"code\\\">Format</code> module (or, if you need to use functions from <code class=\\\"code\\\">Printf</code>, banish\\n    or carefully double check the format strings that contain <code class=\\\"code\\\">&apos;@&apos;</code>\\n    characters).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Exceptionsduringscanning\\\">Exceptions during scanning</div><br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\nAs mentioned above, a plain character in the format string is just\\n    matched with the next character of the input; however, two characters are\\n    special exceptions to this rule: the space character (<code class=\\\"code\\\">&apos; &apos;</code> or ASCII code\\n    32) and the line feed character (<code class=\\\"code\\\">&apos;\\\\n&apos;</code> or ASCII code 10).\\n    A space does not match a single space character, but any amount of\\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\\n    string matches <em>any number</em> of tab, space, line feed and carriage\\n    return characters. Similarly, a line feed character in the format string\\n    matches either a single line feed or a carriage return followed by a line\\n    feed.\\n<p>\\n\\n    Matching <em>any</em> amount of whitespace, a space in the format string\\n    also matches no amount of whitespace at all; hence, the call <code class=\\\"code\\\">bscanf ib\\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class=\\\"code\\\">1</code> when reading an\\n    input with various whitespace in it, such as <code class=\\\"code\\\">Price = 1 $</code>,\\n    <code class=\\\"code\\\">Price  =  1    $</code>, or even <code class=\\\"code\\\">Price=1$</code>.<br>\\n<br>\\n</p><div class=\\\"h7\\\" id=\\\"conversion\\\">Conversion specifications in format strings</div><br>\\n<br>\\nConversion specifications consist in the <code class=\\\"code\\\">%</code> character, followed by\\n    an optional flag, an optional field width, and followed by one or\\n    two conversion characters. The conversion characters and their\\n    meanings are:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">d</code>: reads an optionally signed decimal integer.</li>\\n<li><code class=\\\"code\\\">i</code>: reads an optionally signed integer\\n      (usual input conventions for decimal (<code class=\\\"code\\\">0-9</code>+), hexadecimal\\n       (<code class=\\\"code\\\">0x[0-9a-f]+</code> and <code class=\\\"code\\\">0X[0-9A-F]+</code>), octal (<code class=\\\"code\\\">0o[0-7]+</code>), and binary\\n       (<code class=\\\"code\\\">0b[0-1]+</code>) notations are understood).</li>\\n<li><code class=\\\"code\\\">u</code>: reads an unsigned decimal integer.</li>\\n<li><code class=\\\"code\\\">x</code> or <code class=\\\"code\\\">X</code>: reads an unsigned hexadecimal integer (<code class=\\\"code\\\">[0-9a-fA-F]+</code>).</li>\\n<li><code class=\\\"code\\\">o</code>: reads an unsigned octal integer (<code class=\\\"code\\\">[0-7]+</code>).</li>\\n<li><code class=\\\"code\\\">s</code>: reads a string argument that spreads as much as possible, until the\\n      following bounding condition holds: <ul>\\n<li>a whitespace has been found (see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>a scanning indication (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>) has been\\n         encountered,</li>\\n<li>the end-of-input has been reached.</li>\\n</ul>\\n\\n      Hence, this conversion always succeeds: it returns an empty\\n      string if the bounding condition holds when the scan begins.</li>\\n<li><code class=\\\"code\\\">S</code>: reads a delimited string argument (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">c</code>: reads a single character. To test the current input character\\n      without reading it, specify a null field width, i.e. use\\n      specification <code class=\\\"code\\\">%0c</code>. Raise <code class=\\\"code\\\">Invalid_argument</code>, if the field width\\n      specification is greater than 1.</li>\\n<li><code class=\\\"code\\\">C</code>: reads a single delimited character (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">f</code>, <code class=\\\"code\\\">e</code>, <code class=\\\"code\\\">E</code>, <code class=\\\"code\\\">g</code>, <code class=\\\"code\\\">G</code>: reads an optionally signed\\n      floating-point number in decimal notation, in the style <code class=\\\"code\\\">dddd.ddd\\n      e/E+-dd</code>.</li>\\n<li><code class=\\\"code\\\">F</code>: reads a floating point number according to the lexical\\n      conventions of OCaml (hence the decimal point is mandatory if the\\n      exponent part is not mentioned).</li>\\n<li><code class=\\\"code\\\">B</code>: reads a boolean argument (<code class=\\\"code\\\">true</code> or <code class=\\\"code\\\">false</code>).</li>\\n<li><code class=\\\"code\\\">b</code>: reads a boolean argument (for backward compatibility; do not use\\n      in new programs).</li>\\n<li><code class=\\\"code\\\">ld</code>, <code class=\\\"code\\\">li</code>, <code class=\\\"code\\\">lu</code>, <code class=\\\"code\\\">lx</code>, <code class=\\\"code\\\">lX</code>, <code class=\\\"code\\\">lo</code>: reads an <code class=\\\"code\\\">int32</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">nd</code>, <code class=\\\"code\\\">ni</code>, <code class=\\\"code\\\">nu</code>, <code class=\\\"code\\\">nx</code>, <code class=\\\"code\\\">nX</code>, <code class=\\\"code\\\">no</code>: reads a <code class=\\\"code\\\">nativeint</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">Ld</code>, <code class=\\\"code\\\">Li</code>, <code class=\\\"code\\\">Lu</code>, <code class=\\\"code\\\">Lx</code>, <code class=\\\"code\\\">LX</code>, <code class=\\\"code\\\">Lo</code>: reads an <code class=\\\"code\\\">int64</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">[ range ]</code>: reads characters that matches one of the characters\\n      mentioned in the range of characters <code class=\\\"code\\\">range</code> (or not mentioned in\\n      it, if the range starts with <code class=\\\"code\\\">^</code>). Reads a <code class=\\\"code\\\">string</code> that can be\\n      empty, if the next input character does not match the range. The set of\\n      characters from <code class=\\\"code\\\">c1</code> to <code class=\\\"code\\\">c2</code> (inclusively) is denoted by <code class=\\\"code\\\">c1-c2</code>.\\n      Hence, <code class=\\\"code\\\">%[0-9]</code> returns a string representing a decimal number\\n      or an empty string if no decimal digit is found; similarly,\\n      <code class=\\\"code\\\">%[0-9a-f]</code> returns a string of hexadecimal digits.\\n      If a closing bracket appears in a range, it must occur as the\\n      first character of the range (or just after the <code class=\\\"code\\\">^</code> in case of\\n      range negation); hence <code class=\\\"code\\\">[]]</code> matches a <code class=\\\"code\\\">]</code> character and\\n      <code class=\\\"code\\\">[^]]</code> matches any character that is not <code class=\\\"code\\\">]</code>.\\n      Use <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code> to include a <code class=\\\"code\\\">%</code> or a <code class=\\\"code\\\">@</code> in a range.</li>\\n<li><code class=\\\"code\\\">r</code>: user-defined reader. Takes the next <code class=\\\"code\\\">ri</code> formatted input\\n      function and applies it to the scanning buffer <code class=\\\"code\\\">ib</code> to read the\\n      next argument. The input function <code class=\\\"code\\\">ri</code> must therefore have type\\n      <code class=\\\"code\\\">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class=\\\"code\\\">&apos;a</code>.</li>\\n<li><code class=\\\"code\\\">{ fmt %}</code>: reads a format string argument. The format string\\n      read must have the same type as the format string specification\\n      <code class=\\\"code\\\">fmt</code>. For instance, <code class=\\\"code\\\">&quot;%{ %i %}&quot;</code> reads any format string that\\n      can read a value of type <code class=\\\"code\\\">int</code>; hence, if <code class=\\\"code\\\">s</code> is the string\\n      <code class=\\\"code\\\">&quot;fmt:\\\\&quot;number is %u\\\\&quot;&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\\n      succeeds and returns the format string <code class=\\\"code\\\">&quot;number is %u&quot;</code>.</li>\\n<li><code class=\\\"code\\\">( fmt %)</code>: scanning sub-format substitution.\\n      Reads a format string <code class=\\\"code\\\">rf</code> in the input, then goes on scanning with\\n      <code class=\\\"code\\\">rf</code> instead of scanning with <code class=\\\"code\\\">fmt</code>.\\n      The format string <code class=\\\"code\\\">rf</code> must have the same type as the format string\\n      specification <code class=\\\"code\\\">fmt</code> that it replaces.\\n      For instance, <code class=\\\"code\\\">&quot;%( %i %)&quot;</code> reads any format string that can read a value\\n      of type <code class=\\\"code\\\">int</code>.\\n      The conversion returns the format string read <code class=\\\"code\\\">rf</code>, and then a value\\n      read using <code class=\\\"code\\\">rf</code>.\\n      Hence, if <code class=\\\"code\\\">s</code> is the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then\\n      <code class=\\\"code\\\">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\\n      <code class=\\\"code\\\">(&quot;%4d&quot;, 1234)</code>.\\n      This behaviour is not mere format substitution, since the conversion\\n      returns the format string read as additional argument. If you need\\n      pure format substitution, use special flag <code class=\\\"code\\\">_</code> to discard the\\n      extraneous argument: conversion <code class=\\\"code\\\">%_( fmt %)</code> reads a format string\\n      <code class=\\\"code\\\">rf</code> and then behaves the same as format string <code class=\\\"code\\\">rf</code>.  Hence, if <code class=\\\"code\\\">s</code> is\\n      the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\\n      simply equivalent to <code class=\\\"code\\\">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\\n<li><code class=\\\"code\\\">l</code>: returns the number of lines read so far.</li>\\n<li><code class=\\\"code\\\">n</code>: returns the number of characters read so far.</li>\\n<li><code class=\\\"code\\\">N</code> or <code class=\\\"code\\\">L</code>: returns the number of tokens read so far.</li>\\n<li><code class=\\\"code\\\">!</code>: matches the end of input condition.</li>\\n<li><code class=\\\"code\\\">%</code>: matches one <code class=\\\"code\\\">%</code> character in the input.</li>\\n<li><code class=\\\"code\\\">@</code>: matches one <code class=\\\"code\\\">@</code> character in the input.</li>\\n<li><code class=\\\"code\\\">,</code>: does nothing.</li>\\n</ul>\\n\\n    Following the <code class=\\\"code\\\">%</code> character that introduces a conversion, there may be\\n    the special flag <code class=\\\"code\\\">_</code>: the conversion that follows occurs as usual,\\n    but the resulting value is discarded.\\n    For instance, if <code class=\\\"code\\\">f</code> is the function <code class=\\\"code\\\">fun i -&gt; i + 1</code>, and <code class=\\\"code\\\">s</code> is the\\n    string <code class=\\\"code\\\">&quot;x = 1&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class=\\\"code\\\">2</code>.\\n<p>\\n\\n    The field width is composed of an optional integer literal\\n    indicating the maximal width of the token to read.\\n    For instance, <code class=\\\"code\\\">%6d</code> reads an integer, having at most 6 decimal digits;\\n    <code class=\\\"code\\\">%4f</code> reads a float with at most 4 characters; and <code class=\\\"code\\\">%8[\\\\000-\\\\255]</code>\\n    returns the next 8 characters (or all the characters still available,\\n    if fewer than 8 characters are available in the input).\\n</p><p>\\n\\n    Notes:\\n</p><p>\\n</p><ul>\\n<li>as mentioned above, a <code class=\\\"code\\\">%s</code> conversion always succeeds, even if there is\\n      nothing to read in the input: in this case, it simply returns <code class=\\\"code\\\">&quot;&quot;</code>.</li>\\n</ul>\\n<ul>\\n<li>in addition to the relevant digits, <code class=\\\"code\\\">&apos;_&apos;</code> characters may appear\\n    inside numbers (this is reminiscent to the usual OCaml lexical\\n    conventions). If stricter scanning is desired, use the range\\n    conversion facility instead of the number conversions.</li>\\n</ul>\\n<ul>\\n<li>the <code class=\\\"code\\\">scanf</code> facility is not intended for heavy duty lexical\\n    analysis and parsing. If it appears not expressive enough for your\\n    needs, several alternative exists: regular expressions (module\\n    <code class=\\\"code\\\">Str</code>), stream parsers, <code class=\\\"code\\\">ocamllex</code>-generated lexers,\\n    <code class=\\\"code\\\">ocamlyacc</code>-generated parsers.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"indication\\\">Scanning indications in format strings</div><br>\\n<br>\\nScanning indications appear just after the string conversions <code class=\\\"code\\\">%s</code>\\n    and <code class=\\\"code\\\">%[ range ]</code> to delimit the end of the token. A scanning\\n    indication is introduced by a <code class=\\\"code\\\">@</code> character, followed by some\\n    plain character <code class=\\\"code\\\">c</code>. It means that the string token should end\\n    just before the next matching <code class=\\\"code\\\">c</code> (which is skipped). If no <code class=\\\"code\\\">c</code>\\n    character is encountered, the string token spreads as much as\\n    possible. For instance, <code class=\\\"code\\\">&quot;%s@\\\\t&quot;</code> reads a string up to the next\\n    tab character or to the end of input. If a <code class=\\\"code\\\">@</code> character appears\\n    anywhere else in the format string, it is treated as a plain character.\\n<p>\\n\\n    Note:\\n</p><p>\\n</p><ul>\\n<li>As usual in format strings, <code class=\\\"code\\\">%</code> and <code class=\\\"code\\\">@</code> characters must be escaped\\n    using <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code>; this rule still holds within range specifications\\n    and scanning indications.\\n    For instance, <code class=\\\"code\\\">&quot;%s@%%&quot;</code> reads a string up to the next <code class=\\\"code\\\">%</code> character.</li>\\n<li>The scanning indications introduce slight differences in the syntax of\\n    <code class=\\\"code\\\">Scanf</code> format strings, compared to those used for the <code class=\\\"code\\\">Printf</code>\\n    module. However, the scanning indications are similar to those used in\\n    the <code class=\\\"code\\\">Format</code> module; hence, when producing formatted text to be scanned\\n    by <code class=\\\"code\\\">!Scanf.bscanf</code>, it is wise to use printing functions from the\\n    <code class=\\\"code\\\">Format</code> module (or, if you need to use functions from <code class=\\\"code\\\">Printf</code>, banish\\n    or carefully double check the format strings that contain <code class=\\\"code\\\">&apos;@&apos;</code>\\n    characters).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Exceptionsduringscanning\\\">Exceptions during scanning</div><br>\\n<br>\\nScanners may raise the following exceptions when the input cannot be read\\n    according to the format string:\\n<p>\\n</p><ul>\\n<li>Raise <code class=\\\"code\\\">Scanf.Scan_failure</code> if the input does not match the format.</li>\\n</ul>\\n<ul>\\n<li>Raise <code class=\\\"code\\\">Failure</code> if a conversion to a number is not possible.</li>\\n</ul>\\n<ul>\\n<li>Raise <code class=\\\"code\\\">End_of_file</code> if the end of input is encountered while some more\\n      characters are needed to read the current conversion specification.</li>\\n</ul>\\n<ul>\\n<li>Raise <code class=\\\"code\\\">Invalid_argument</code> if the format string is invalid.</li>\\n</ul>\\n\\n    Note:\\n<p>\\n</p><ul>\\n<li>as a consequence, scanning a <code class=\\\"code\\\">%s</code> conversion never raises exception\\n    <code class=\\\"code\\\">End_of_file</code>: if the end of input is reached the conversion succeeds and\\n    simply returns the characters read so far, or <code class=\\\"code\\\">&quot;&quot;</code> if none were ever read.</li>\\n</ul>\\n<br>\\n<br>\\n<h6 id=\\\"6_Formatstringdescription\\\">Format string description</h6><br>\\n<br>\\nThe format string is a character string which contains three types of\\n    objects:<ul>\\n<li>plain characters, which are simply matched with the characters of the\\n      input (with a special case for space and line feed, see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>conversion specifications, each of which causes reading and conversion of\\n      one argument for the function <code class=\\\"code\\\">f</code> (see <a href=\\\"Scanf.html#conversion\\\"><i>Conversion specifications in format strings</i></a>),</li>\\n<li>scanning indications to specify boundaries of tokens\\n      (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"space\\\">The space character in format strings</div><br>\\n<br>\\nAs mentioned above, a plain character in the format string is just\\n    matched with the next character of the input; however, two characters are\\n    special exceptions to this rule: the space character (<code class=\\\"code\\\">&apos; &apos;</code> or ASCII code\\n    32) and the line feed character (<code class=\\\"code\\\">&apos;\\\\n&apos;</code> or ASCII code 10).\\n    A space does not match a single space character, but any amount of\\n    &apos;whitespace&apos; in the input. More precisely, a space inside the format\\n    string matches <em>any number</em> of tab, space, line feed and carriage\\n    return characters. Similarly, a line feed character in the format string\\n    matches either a single line feed or a carriage return followed by a line\\n    feed.\\n<p>\\n\\n    Matching <em>any</em> amount of whitespace, a space in the format string\\n    also matches no amount of whitespace at all; hence, the call <code class=\\\"code\\\">bscanf ib\\n    &quot;Price = %d $&quot; (fun p -&gt; p)</code> succeeds and returns <code class=\\\"code\\\">1</code> when reading an\\n    input with various whitespace in it, such as <code class=\\\"code\\\">Price = 1 $</code>,\\n    <code class=\\\"code\\\">Price  =  1    $</code>, or even <code class=\\\"code\\\">Price=1$</code>.<br>\\n<br>\\n</p><div class=\\\"h7\\\" id=\\\"conversion\\\">Conversion specifications in format strings</div><br>\\n<br>\\nConversion specifications consist in the <code class=\\\"code\\\">%</code> character, followed by\\n    an optional flag, an optional field width, and followed by one or\\n    two conversion characters. The conversion characters and their\\n    meanings are:\\n<p>\\n</p><ul>\\n<li><code class=\\\"code\\\">d</code>: reads an optionally signed decimal integer.</li>\\n<li><code class=\\\"code\\\">i</code>: reads an optionally signed integer\\n      (usual input conventions for decimal (<code class=\\\"code\\\">0-9</code>+), hexadecimal\\n       (<code class=\\\"code\\\">0x[0-9a-f]+</code> and <code class=\\\"code\\\">0X[0-9A-F]+</code>), octal (<code class=\\\"code\\\">0o[0-7]+</code>), and binary\\n       (<code class=\\\"code\\\">0b[0-1]+</code>) notations are understood).</li>\\n<li><code class=\\\"code\\\">u</code>: reads an unsigned decimal integer.</li>\\n<li><code class=\\\"code\\\">x</code> or <code class=\\\"code\\\">X</code>: reads an unsigned hexadecimal integer (<code class=\\\"code\\\">[0-9a-fA-F]+</code>).</li>\\n<li><code class=\\\"code\\\">o</code>: reads an unsigned octal integer (<code class=\\\"code\\\">[0-7]+</code>).</li>\\n<li><code class=\\\"code\\\">s</code>: reads a string argument that spreads as much as possible, until the\\n      following bounding condition holds: <ul>\\n<li>a whitespace has been found (see <a href=\\\"Scanf.html#space\\\"><i>The space character in format strings</i></a>),</li>\\n<li>a scanning indication (see scanning <a href=\\\"Scanf.html#indication\\\"><i>Scanning indications in format strings</i></a>) has been\\n         encountered,</li>\\n<li>the end-of-input has been reached.</li>\\n</ul>\\n\\n      Hence, this conversion always succeeds: it returns an empty\\n      string if the bounding condition holds when the scan begins.</li>\\n<li><code class=\\\"code\\\">S</code>: reads a delimited string argument (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">c</code>: reads a single character. To test the current input character\\n      without reading it, specify a null field width, i.e. use\\n      specification <code class=\\\"code\\\">%0c</code>. Raise <code class=\\\"code\\\">Invalid_argument</code>, if the field width\\n      specification is greater than 1.</li>\\n<li><code class=\\\"code\\\">C</code>: reads a single delimited character (delimiters and special\\n      escaped characters follow the lexical conventions of OCaml).</li>\\n<li><code class=\\\"code\\\">f</code>, <code class=\\\"code\\\">e</code>, <code class=\\\"code\\\">E</code>, <code class=\\\"code\\\">g</code>, <code class=\\\"code\\\">G</code>: reads an optionally signed\\n      floating-point number in decimal notation, in the style <code class=\\\"code\\\">dddd.ddd\\n      e/E+-dd</code>.</li>\\n<li><code class=\\\"code\\\">F</code>: reads a floating point number according to the lexical\\n      conventions of OCaml (hence the decimal point is mandatory if the\\n      exponent part is not mentioned).</li>\\n<li><code class=\\\"code\\\">B</code>: reads a boolean argument (<code class=\\\"code\\\">true</code> or <code class=\\\"code\\\">false</code>).</li>\\n<li><code class=\\\"code\\\">b</code>: reads a boolean argument (for backward compatibility; do not use\\n      in new programs).</li>\\n<li><code class=\\\"code\\\">ld</code>, <code class=\\\"code\\\">li</code>, <code class=\\\"code\\\">lu</code>, <code class=\\\"code\\\">lx</code>, <code class=\\\"code\\\">lX</code>, <code class=\\\"code\\\">lo</code>: reads an <code class=\\\"code\\\">int32</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">nd</code>, <code class=\\\"code\\\">ni</code>, <code class=\\\"code\\\">nu</code>, <code class=\\\"code\\\">nx</code>, <code class=\\\"code\\\">nX</code>, <code class=\\\"code\\\">no</code>: reads a <code class=\\\"code\\\">nativeint</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">Ld</code>, <code class=\\\"code\\\">Li</code>, <code class=\\\"code\\\">Lu</code>, <code class=\\\"code\\\">Lx</code>, <code class=\\\"code\\\">LX</code>, <code class=\\\"code\\\">Lo</code>: reads an <code class=\\\"code\\\">int64</code> argument to\\n      the format specified by the second letter for regular integers.</li>\\n<li><code class=\\\"code\\\">[ range ]</code>: reads characters that matches one of the characters\\n      mentioned in the range of characters <code class=\\\"code\\\">range</code> (or not mentioned in\\n      it, if the range starts with <code class=\\\"code\\\">^</code>). Reads a <code class=\\\"code\\\">string</code> that can be\\n      empty, if the next input character does not match the range. The set of\\n      characters from <code class=\\\"code\\\">c1</code> to <code class=\\\"code\\\">c2</code> (inclusively) is denoted by <code class=\\\"code\\\">c1-c2</code>.\\n      Hence, <code class=\\\"code\\\">%[0-9]</code> returns a string representing a decimal number\\n      or an empty string if no decimal digit is found; similarly,\\n      <code class=\\\"code\\\">%[0-9a-f]</code> returns a string of hexadecimal digits.\\n      If a closing bracket appears in a range, it must occur as the\\n      first character of the range (or just after the <code class=\\\"code\\\">^</code> in case of\\n      range negation); hence <code class=\\\"code\\\">[]]</code> matches a <code class=\\\"code\\\">]</code> character and\\n      <code class=\\\"code\\\">[^]]</code> matches any character that is not <code class=\\\"code\\\">]</code>.\\n      Use <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code> to include a <code class=\\\"code\\\">%</code> or a <code class=\\\"code\\\">@</code> in a range.</li>\\n<li><code class=\\\"code\\\">r</code>: user-defined reader. Takes the next <code class=\\\"code\\\">ri</code> formatted input\\n      function and applies it to the scanning buffer <code class=\\\"code\\\">ib</code> to read the\\n      next argument. The input function <code class=\\\"code\\\">ri</code> must therefore have type\\n      <code class=\\\"code\\\">Scanning.in_channel -&gt; &apos;a</code> and the argument read has type <code class=\\\"code\\\">&apos;a</code>.</li>\\n<li><code class=\\\"code\\\">{ fmt %}</code>: reads a format string argument. The format string\\n      read must have the same type as the format string specification\\n      <code class=\\\"code\\\">fmt</code>. For instance, <code class=\\\"code\\\">&quot;%{ %i %}&quot;</code> reads any format string that\\n      can read a value of type <code class=\\\"code\\\">int</code>; hence, if <code class=\\\"code\\\">s</code> is the string\\n      <code class=\\\"code\\\">&quot;fmt:\\\\&quot;number is %u\\\\&quot;&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;fmt: %{%i%}&quot;</code>\\n      succeeds and returns the format string <code class=\\\"code\\\">&quot;number is %u&quot;</code>.</li>\\n<li><code class=\\\"code\\\">( fmt %)</code>: scanning sub-format substitution.\\n      Reads a format string <code class=\\\"code\\\">rf</code> in the input, then goes on scanning with\\n      <code class=\\\"code\\\">rf</code> instead of scanning with <code class=\\\"code\\\">fmt</code>.\\n      The format string <code class=\\\"code\\\">rf</code> must have the same type as the format string\\n      specification <code class=\\\"code\\\">fmt</code> that it replaces.\\n      For instance, <code class=\\\"code\\\">&quot;%( %i %)&quot;</code> reads any format string that can read a value\\n      of type <code class=\\\"code\\\">int</code>.\\n      The conversion returns the format string read <code class=\\\"code\\\">rf</code>, and then a value\\n      read using <code class=\\\"code\\\">rf</code>.\\n      Hence, if <code class=\\\"code\\\">s</code> is the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then\\n      <code class=\\\"code\\\">Scanf.sscanf s &quot;%(%i%)&quot; (fun fmt i -&gt; fmt, i)</code> evaluates to\\n      <code class=\\\"code\\\">(&quot;%4d&quot;, 1234)</code>.\\n      This behaviour is not mere format substitution, since the conversion\\n      returns the format string read as additional argument. If you need\\n      pure format substitution, use special flag <code class=\\\"code\\\">_</code> to discard the\\n      extraneous argument: conversion <code class=\\\"code\\\">%_( fmt %)</code> reads a format string\\n      <code class=\\\"code\\\">rf</code> and then behaves the same as format string <code class=\\\"code\\\">rf</code>.  Hence, if <code class=\\\"code\\\">s</code> is\\n      the string <code class=\\\"code\\\">&quot;\\\\&quot;%4d\\\\&quot;1234.00&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_(%i%)&quot;</code> is\\n      simply equivalent to <code class=\\\"code\\\">Scanf.sscanf &quot;1234.00&quot; &quot;%4d&quot;</code>.</li>\\n<li><code class=\\\"code\\\">l</code>: returns the number of lines read so far.</li>\\n<li><code class=\\\"code\\\">n</code>: returns the number of characters read so far.</li>\\n<li><code class=\\\"code\\\">N</code> or <code class=\\\"code\\\">L</code>: returns the number of tokens read so far.</li>\\n<li><code class=\\\"code\\\">!</code>: matches the end of input condition.</li>\\n<li><code class=\\\"code\\\">%</code>: matches one <code class=\\\"code\\\">%</code> character in the input.</li>\\n<li><code class=\\\"code\\\">@</code>: matches one <code class=\\\"code\\\">@</code> character in the input.</li>\\n<li><code class=\\\"code\\\">,</code>: does nothing.</li>\\n</ul>\\n\\n    Following the <code class=\\\"code\\\">%</code> character that introduces a conversion, there may be\\n    the special flag <code class=\\\"code\\\">_</code>: the conversion that follows occurs as usual,\\n    but the resulting value is discarded.\\n    For instance, if <code class=\\\"code\\\">f</code> is the function <code class=\\\"code\\\">fun i -&gt; i + 1</code>, and <code class=\\\"code\\\">s</code> is the\\n    string <code class=\\\"code\\\">&quot;x = 1&quot;</code>, then <code class=\\\"code\\\">Scanf.sscanf s &quot;%_s = %i&quot; f</code> returns <code class=\\\"code\\\">2</code>.\\n<p>\\n\\n    The field width is composed of an optional integer literal\\n    indicating the maximal width of the token to read.\\n    For instance, <code class=\\\"code\\\">%6d</code> reads an integer, having at most 6 decimal digits;\\n    <code class=\\\"code\\\">%4f</code> reads a float with at most 4 characters; and <code class=\\\"code\\\">%8[\\\\000-\\\\255]</code>\\n    returns the next 8 characters (or all the characters still available,\\n    if fewer than 8 characters are available in the input).\\n</p><p>\\n\\n    Notes:\\n</p><p>\\n</p><ul>\\n<li>as mentioned above, a <code class=\\\"code\\\">%s</code> conversion always succeeds, even if there is\\n      nothing to read in the input: in this case, it simply returns <code class=\\\"code\\\">&quot;&quot;</code>.</li>\\n</ul>\\n<ul>\\n<li>in addition to the relevant digits, <code class=\\\"code\\\">&apos;_&apos;</code> characters may appear\\n    inside numbers (this is reminiscent to the usual OCaml lexical\\n    conventions). If stricter scanning is desired, use the range\\n    conversion facility instead of the number conversions.</li>\\n</ul>\\n<ul>\\n<li>the <code class=\\\"code\\\">scanf</code> facility is not intended for heavy duty lexical\\n    analysis and parsing. If it appears not expressive enough for your\\n    needs, several alternative exists: regular expressions (module\\n    <code class=\\\"code\\\">Str</code>), stream parsers, <code class=\\\"code\\\">ocamllex</code>-generated lexers,\\n    <code class=\\\"code\\\">ocamlyacc</code>-generated parsers.</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"indication\\\">Scanning indications in format strings</div><br>\\n<br>\\nScanning indications appear just after the string conversions <code class=\\\"code\\\">%s</code>\\n    and <code class=\\\"code\\\">%[ range ]</code> to delimit the end of the token. A scanning\\n    indication is introduced by a <code class=\\\"code\\\">@</code> character, followed by some\\n    plain character <code class=\\\"code\\\">c</code>. It means that the string token should end\\n    just before the next matching <code class=\\\"code\\\">c</code> (which is skipped). If no <code class=\\\"code\\\">c</code>\\n    character is encountered, the string token spreads as much as\\n    possible. For instance, <code class=\\\"code\\\">&quot;%s@\\\\t&quot;</code> reads a string up to the next\\n    tab character or to the end of input. If a <code class=\\\"code\\\">@</code> character appears\\n    anywhere else in the format string, it is treated as a plain character.\\n<p>\\n\\n    Note:\\n</p><p>\\n</p><ul>\\n<li>As usual in format strings, <code class=\\\"code\\\">%</code> and <code class=\\\"code\\\">@</code> characters must be escaped\\n    using <code class=\\\"code\\\">%%</code> and <code class=\\\"code\\\">%@</code>; this rule still holds within range specifications\\n    and scanning indications.\\n    For instance, <code class=\\\"code\\\">&quot;%s@%%&quot;</code> reads a string up to the next <code class=\\\"code\\\">%</code> character.</li>\\n<li>The scanning indications introduce slight differences in the syntax of\\n    <code class=\\\"code\\\">Scanf</code> format strings, compared to those used for the <code class=\\\"code\\\">Printf</code>\\n    module. However, the scanning indications are similar to those used in\\n    the <code class=\\\"code\\\">Format</code> module; hence, when producing formatted text to be scanned\\n    by <code class=\\\"code\\\">!Scanf.bscanf</code>, it is wise to use printing functions from the\\n    <code class=\\\"code\\\">Format</code> module (or, if you need to use functions from <code class=\\\"code\\\">Printf</code>, banish\\n    or carefully double check the format strings that contain <code class=\\\"code\\\">&apos;@&apos;</code>\\n    characters).</li>\\n</ul>\\n<br>\\n<br>\\n<div class=\\\"h7\\\" id=\\\"7_Exceptionsduringscanning\\\">Exceptions during scanning</div><br>\\n<br>\\nScanners may raise the following exceptions when the input cannot be read\\n    according to the format string:\\n<p>\\n</p><ul>\\n<li>Raise <code class=\\\"code\\\">Scanf.Scan_failure</code> if the input does not match the format.</li>\\n</ul>\\n<ul>\\n<li>Raise <code class=\\\"code\\\">Failure</code> if a conversion to a number is not possible.</li>\\n</ul>\\n<ul>\\n<li>Raise <code class=\\\"code\\\">End_of_file</code> if the end of input is encountered while some more\\n      characters are needed to read the current conversion specification.</li>\\n</ul>\\n<ul>\\n<li>Raise <code class=\\\"code\\\">Invalid_argument</code> if the format string is invalid.</li>\\n</ul>\\n\\n    Note:\\n<p>\\n</p><ul>\\n<li>as a consequence, scanning a <code class=\\\"code\\\">%s</code> conversion never raises exception\\n    <code class=\\\"code\\\">End_of_file</code>: if the end of input is reached the conversion succeeds and\\n    simply returns the characters read so far, or <code class=\\\"code\\\">&quot;&quot;</code> if none were ever read.</li>\\n</ul>\\n<br>\\n<br>\\n<h6 id=\\\"6_Specialisedformattedinputfunctions\\\">Specialised formatted input functions</h6><br>\\n\\n<pre><span class=\\\"keyword\\\">let</span> fscanf: Pervasives.in_channel =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\\n</pre><div class=\\\"info \\\">\\nSame as <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a>, but reads from the given regular input channel.\\n<p>\\n\\n    Warning: since all formatted input functions operate from a <em>formatted\\n    input channel</em>, be aware that each <code class=\\\"code\\\">fscanf</code> invocation will operate with a\\n    formatted input channel reading from the given channel. This extra level\\n    of bufferization can lead to a strange scanning behaviour if you use low\\n    level primitives on the channel (reading characters, seeking the reading\\n    position, and so on).\\n</p><p>\\n\\n    As a consequence, never mix direct low level reading and high level\\n    scanning from the same regular input channel.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> sscanf: string =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\\n</pre><div class=\\\"info \\\">\\nSame as <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a>, but reads from the given string.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> scanf: scanner &apos;a &apos;b &apos;c &apos;d;\\n</pre><div class=\\\"info \\\">\\nSame as <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a>, but reads from the predefined formatted input\\n    channel <a href=\\\"Scanf.Scanning.html#VALstdin\\\"><code class=\\\"code\\\">Scanf.Scanning.stdin</code></a> that is connected to <code class=\\\"code\\\">Pervasives.stdin</code>.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> kscanf: Scanning.in_channel =&gt; (Scanning.in_channel =&gt; exn =&gt; &apos;d) =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\\n</pre><div class=\\\"info \\\">\\nSame as <a href=\\\"Scanf.html#VALbscanf\\\"><code class=\\\"code\\\">Scanf.bscanf</code></a>, but takes an additional function argument\\n    <code class=\\\"code\\\">ef</code> that is called in case of error: if the scanning process or\\n    some conversion fails, the scanning function aborts and calls the\\n    error handling function <code class=\\\"code\\\">ef</code> with the formatted input channel and the\\n    exception that aborted the scanning process as arguments.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> ksscanf: string =&gt; (Scanning.in_channel =&gt; exn =&gt; &apos;d) =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\\n</pre><div class=\\\"info \\\">\\nSame as <a href=\\\"Scanf.html#VALkscanf\\\"><code class=\\\"code\\\">Scanf.kscanf</code></a> but reads from the given string.<br>\\n<b>Since</b> 4.02.0<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> kfscanf: Pervasives.in_channel =&gt; (Scanning.in_channel =&gt; exn =&gt; &apos;d) =&gt; scanner &apos;a &apos;b &apos;c &apos;d;\\n</pre><div class=\\\"info \\\">\\nSame as <a href=\\\"Scanf.html#VALkscanf\\\"><code class=\\\"code\\\">Scanf.kscanf</code></a>, but reads from the given regular input channel.<br>\\n<b>Since</b> 4.02.0<br>\\n</div>\\n<br>\\n<h6 id=\\\"6_Readingformatstringsfrominput\\\">Reading format strings from input</h6><br>\\n\\n<pre><span class=\\\"keyword\\\">let</span> bscanf_format:\\n  Scanning.in_channel =&gt;\\n  Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt;\\n  (Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt; &apos;g) =&gt;\\n  &apos;g;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">bscanf_format ic fmt f</code> reads a format string token from the formatted\\n    input channel <code class=\\\"code\\\">ic</code>, according to the given format string <code class=\\\"code\\\">fmt</code>, and\\n    applies <code class=\\\"code\\\">f</code> to the resulting format string value.\\n    Raise <code class=\\\"code\\\">Scan_failure</code> if the format string value read does not have the\\n    same type as <code class=\\\"code\\\">fmt</code>.<br>\\n<b>Since</b> 3.09.0<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> sscanf_format:\\n  string =&gt;\\n  Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt;\\n  (Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt; &apos;g) =&gt;\\n  &apos;g;\\n</pre><div class=\\\"info \\\">\\nSame as <a href=\\\"Scanf.html#VALbscanf_format\\\"><code class=\\\"code\\\">Scanf.bscanf_format</code></a>, but reads from the given string.<br>\\n<b>Since</b> 3.09.0<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> format_from_string:\\n  string =&gt; Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f =&gt; Pervasives.format6 &apos;a &apos;b &apos;c &apos;d &apos;e &apos;f;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">format_from_string s fmt</code> converts a string argument to a format string,\\n    according to the given format string <code class=\\\"code\\\">fmt</code>.\\n    Raise <code class=\\\"code\\\">Scan_failure</code> if <code class=\\\"code\\\">s</code>, considered as a format string, does not\\n    have the same type as <code class=\\\"code\\\">fmt</code>.<br>\\n<b>Since</b> 3.10.0<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> unescaped: string =&gt; string;\\n</pre><div class=\\\"info \\\">\\nReturn a copy of the argument with escape sequences, following the\\n    lexical conventions of OCaml, replaced by their corresponding\\n    special characters. If there is no escape sequence in the\\n    argument, still return a copy, contrary to String.escaped.<br>\\n<b>Since</b> 4.00.0<br>\\n</div>\\n</div>\"\n\t\t\t}\n\t\t}\n\t},\n\t\"pathContext\": {\n\t\t\"relativePath\": \"api/Scanf.html\"\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/api-scanf-html.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/api-scanf-html.json\n// module chunks = 203"],"sourceRoot":""}