{"version":3,"sources":["webpack:///path---api-bytes-html-90e04ee29275a12cfbf0.js","webpack:///./.cache/json/api-bytes-html.json"],"names":["webpackJsonp","./node_modules/json-loader/index.js!./.cache/json/api-bytes-html.json","module","exports","data","file","relativePath","childRawHtml","content","pathContext"],"mappings":"AAAAA,cAAc,MAERC,wEACA,SAAUC,EAAQC,GCHxBD,EAAAC,SACAC,MACAC,MACAC,aAAA,iBACAC,cACAC,QAAA,8+yBAIAC,aACAH,aAAA","file":"path---api-bytes-html-90e04ee29275a12cfbf0.js","sourcesContent":["webpackJsonp([286],{\n\n/***/ \"./node_modules/json-loader/index.js!./.cache/json/api-bytes-html.json\":\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\n\t\t\"data\": {\n\t\t\t\"file\": {\n\t\t\t\t\"relativePath\": \"api/Bytes.html\",\n\t\t\t\t\"childRawHtml\": {\n\t\t\t\t\t\"content\": \"<div class=\\\"ocamldoc\\\">\\n<div class=\\\"navbar\\\"><a class=\\\"pre\\\" href=\\\"Buffer.html\\\" title=\\\"Buffer\\\">Previous</a>\\n&#xA0;<a class=\\\"up\\\" href=\\\"index.html\\\" title=\\\"Index\\\">Up</a>\\n&#xA0;<a class=\\\"post\\\" href=\\\"BytesLabels.html\\\" title=\\\"BytesLabels\\\">Next</a>\\n</div>\\n<h1>Module <a href=\\\"type_Bytes.html\\\">Bytes</a></h1>\\n\\n<pre><span class=\\\"keyword\\\">module</span> Bytes: sig .. end</pre><div class=\\\"info module top\\\">\\nByte sequence operations.\\n<p>\\n\\n   A byte sequence is a mutable data structure that contains a\\n   fixed-length sequence of bytes. Each byte can be indexed in\\n   constant time for reading or writing.\\n</p><p>\\n\\n   Given a byte sequence <code class=\\\"code\\\">s</code> of length <code class=\\\"code\\\">l</code>, we can access each of the\\n   <code class=\\\"code\\\">l</code> bytes of <code class=\\\"code\\\">s</code> via its index in the sequence. Indexes start at\\n   <code class=\\\"code\\\">0</code>, and we will call an index valid in <code class=\\\"code\\\">s</code> if it falls within the\\n   range <code class=\\\"code\\\">[0...l-1]</code> (inclusive). A position is the point between two\\n   bytes or at the beginning or end of the sequence.  We call a\\n   position valid in <code class=\\\"code\\\">s</code> if it falls within the range <code class=\\\"code\\\">[0...l]</code>\\n   (inclusive). Note that the byte at index <code class=\\\"code\\\">n</code> is between positions\\n   <code class=\\\"code\\\">n</code> and <code class=\\\"code\\\">n+1</code>.\\n</p><p>\\n\\n   Two parameters <code class=\\\"code\\\">start</code> and <code class=\\\"code\\\">len</code> are said to designate a valid\\n   range of <code class=\\\"code\\\">s</code> if <code class=\\\"code\\\">len &gt;= 0</code> and <code class=\\\"code\\\">start</code> and <code class=\\\"code\\\">start+len</code> are valid\\n   positions in <code class=\\\"code\\\">s</code>.\\n</p><p>\\n\\n   Byte sequences can be modified in place, for instance via the <code class=\\\"code\\\">set</code>\\n   and <code class=\\\"code\\\">blit</code> functions described below.  See also strings (module\\n   <a href=\\\"String.html\\\"><code class=\\\"code\\\">String</code></a>), which are almost the same data structure, but cannot be\\n   modified in place.\\n</p><p>\\n\\n   Bytes are represented by the OCaml type <code class=\\\"code\\\">char</code>.<br>\\n<b>Since</b> 4.02.0<br>\\n</p></div>\\n<hr width=\\\"100%\\\">\\n\\n<pre><span class=\\\"keyword\\\">let</span> length: bytes =&gt; int;\\n</pre><div class=\\\"info \\\">\\nReturn the length (number of bytes) of the argument.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> get: bytes =&gt; int =&gt; char;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">get s n</code> returns the byte at index <code class=\\\"code\\\">n</code> in argument <code class=\\\"code\\\">s</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">n</code> not a valid index in <code class=\\\"code\\\">s</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> set: bytes =&gt; int =&gt; char =&gt; unit;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">set s n c</code> modifies <code class=\\\"code\\\">s</code> in place, replacing the byte at index <code class=\\\"code\\\">n</code>\\n    with <code class=\\\"code\\\">c</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">n</code> is not a valid index in <code class=\\\"code\\\">s</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> create: int =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">create n</code> returns a new byte sequence of length <code class=\\\"code\\\">n</code>. The\\n    sequence is uninitialized and contains arbitrary bytes.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">n &lt; 0</code> or <code class=\\\"code\\\">n &gt; </code><a href=\\\"Sys.html#VALmax_string_length\\\"><code class=\\\"code\\\">Sys.max_string_length</code></a>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> make: int =&gt; char =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">make n c</code> returns a new byte sequence of length <code class=\\\"code\\\">n</code>, filled with\\n    the byte <code class=\\\"code\\\">c</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">n &lt; 0</code> or <code class=\\\"code\\\">n &gt; </code><a href=\\\"Sys.html#VALmax_string_length\\\"><code class=\\\"code\\\">Sys.max_string_length</code></a>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> init: int =&gt; (int =&gt; char) =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">Bytes.init n f</code> returns a fresh byte sequence of length <code class=\\\"code\\\">n</code>, with\\n    character <code class=\\\"code\\\">i</code> initialized to the result of <code class=\\\"code\\\">f i</code> (in increasing\\n    index order).\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">n &lt; 0</code> or <code class=\\\"code\\\">n &gt; </code><a href=\\\"Sys.html#VALmax_string_length\\\"><code class=\\\"code\\\">Sys.max_string_length</code></a>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> empty: bytes;\\n</pre><div class=\\\"info \\\">\\nA byte sequence of size 0.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> copy: bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nReturn a new byte sequence that contains the same bytes as the\\n    argument.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> of_string: string =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nReturn a new byte sequence that contains the same bytes as the\\n    given string.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> to_string: bytes =&gt; string;\\n</pre><div class=\\\"info \\\">\\nReturn a new string that contains the same bytes as the given byte\\n    sequence.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> sub: bytes =&gt; int =&gt; int =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">sub s start len</code> returns a new byte sequence of length <code class=\\\"code\\\">len</code>,\\n    containing the subsequence of <code class=\\\"code\\\">s</code> that starts at position <code class=\\\"code\\\">start</code>\\n    and has length <code class=\\\"code\\\">len</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">start</code> and <code class=\\\"code\\\">len</code> do not designate a\\n    valid range of <code class=\\\"code\\\">s</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> sub_string: bytes =&gt; int =&gt; int =&gt; string;\\n</pre><div class=\\\"info \\\">\\nSame as <code class=\\\"code\\\">sub</code> but return a string instead of a byte sequence.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> extend: bytes =&gt; int =&gt; int =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">extend s left right</code> returns a new byte sequence that contains\\n    the bytes of <code class=\\\"code\\\">s</code>, with <code class=\\\"code\\\">left</code> uninitialized bytes prepended and\\n    <code class=\\\"code\\\">right</code> uninitialized bytes appended to it. If <code class=\\\"code\\\">left</code> or <code class=\\\"code\\\">right</code>\\n    is negative, then bytes are removed (instead of appended) from\\n    the corresponding side of <code class=\\\"code\\\">s</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if the result length is negative or\\n    longer than <a href=\\\"Sys.html#VALmax_string_length\\\"><code class=\\\"code\\\">Sys.max_string_length</code></a> bytes.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> fill: bytes =&gt; int =&gt; int =&gt; char =&gt; unit;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">fill s start len c</code> modifies <code class=\\\"code\\\">s</code> in place, replacing <code class=\\\"code\\\">len</code>\\n    characters with <code class=\\\"code\\\">c</code>, starting at <code class=\\\"code\\\">start</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">start</code> and <code class=\\\"code\\\">len</code> do not designate a\\n    valid range of <code class=\\\"code\\\">s</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> blit: bytes =&gt; int =&gt; bytes =&gt; int =&gt; int =&gt; unit;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">blit src srcoff dst dstoff len</code> copies <code class=\\\"code\\\">len</code> bytes from sequence\\n    <code class=\\\"code\\\">src</code>, starting at index <code class=\\\"code\\\">srcoff</code>, to sequence <code class=\\\"code\\\">dst</code>, starting at\\n    index <code class=\\\"code\\\">dstoff</code>. It works correctly even if <code class=\\\"code\\\">src</code> and <code class=\\\"code\\\">dst</code> are the\\n    same byte sequence, and the source and destination intervals\\n    overlap.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">srcoff</code> and <code class=\\\"code\\\">len</code> do not\\n    designate a valid range of <code class=\\\"code\\\">src</code>, or if <code class=\\\"code\\\">dstoff</code> and <code class=\\\"code\\\">len</code>\\n    do not designate a valid range of <code class=\\\"code\\\">dst</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> blit_string: string =&gt; int =&gt; bytes =&gt; int =&gt; int =&gt; unit;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">blit src srcoff dst dstoff len</code> copies <code class=\\\"code\\\">len</code> bytes from string\\n    <code class=\\\"code\\\">src</code>, starting at index <code class=\\\"code\\\">srcoff</code>, to byte sequence <code class=\\\"code\\\">dst</code>,\\n    starting at index <code class=\\\"code\\\">dstoff</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">srcoff</code> and <code class=\\\"code\\\">len</code> do not\\n    designate a valid range of <code class=\\\"code\\\">src</code>, or if <code class=\\\"code\\\">dstoff</code> and <code class=\\\"code\\\">len</code>\\n    do not designate a valid range of <code class=\\\"code\\\">dst</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> concat: bytes =&gt; list bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">concat sep sl</code> concatenates the list of byte sequences <code class=\\\"code\\\">sl</code>,\\n    inserting the separator byte sequence <code class=\\\"code\\\">sep</code> between each, and\\n    returns the result as a new byte sequence.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if the result is longer than\\n    <a href=\\\"Sys.html#VALmax_string_length\\\"><code class=\\\"code\\\">Sys.max_string_length</code></a> bytes.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> cat: bytes =&gt; bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">cat s1 s2</code> concatenates <code class=\\\"code\\\">s1</code> and <code class=\\\"code\\\">s2</code> and returns the result\\n     as new byte sequence.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if the result is longer than\\n    <a href=\\\"Sys.html#VALmax_string_length\\\"><code class=\\\"code\\\">Sys.max_string_length</code></a> bytes.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> iter: (char =&gt; unit) =&gt; bytes =&gt; unit;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">iter f s</code> applies function <code class=\\\"code\\\">f</code> in turn to all the bytes of <code class=\\\"code\\\">s</code>.\\n    It is equivalent to <code class=\\\"code\\\">f (get s 0); f (get s 1); ...; f (get s\\n    (length s - 1)); ()</code>.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> iteri: (int =&gt; char =&gt; unit) =&gt; bytes =&gt; unit;\\n</pre><div class=\\\"info \\\">\\nSame as <a href=\\\"Bytes.html#VALiter\\\"><code class=\\\"code\\\">Bytes.iter</code></a>, but the function is applied to the index of\\n    the byte as first argument and the byte itself as second\\n    argument.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> map: (char =&gt; char) =&gt; bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">map f s</code> applies function <code class=\\\"code\\\">f</code> in turn to all the bytes of <code class=\\\"code\\\">s</code>\\n    (in increasing index order) and stores the resulting bytes in\\n    a new sequence that is returned as the result.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> mapi: (int =&gt; char =&gt; char) =&gt; bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">mapi f s</code> calls <code class=\\\"code\\\">f</code> with each character of <code class=\\\"code\\\">s</code> and its\\n    index (in increasing index order) and stores the resulting bytes\\n    in a new sequence that is returned as the result.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> trim: bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nReturn a copy of the argument, without leading and trailing\\n    whitespace. The bytes regarded as whitespace are the ASCII\\n    characters <code class=\\\"code\\\">&apos; &apos;</code>, <code class=\\\"code\\\">&apos;\\\\012&apos;</code>, <code class=\\\"code\\\">&apos;\\\\n&apos;</code>, <code class=\\\"code\\\">&apos;\\\\r&apos;</code>, and <code class=\\\"code\\\">&apos;\\\\t&apos;</code>.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> escaped: bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nReturn a copy of the argument, with special characters represented\\n    by escape sequences, following the lexical conventions of OCaml.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if the result is longer than\\n    <a href=\\\"Sys.html#VALmax_string_length\\\"><code class=\\\"code\\\">Sys.max_string_length</code></a> bytes.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> index: bytes =&gt; char =&gt; int;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">index s c</code> returns the index of the first occurrence of byte <code class=\\\"code\\\">c</code>\\n    in <code class=\\\"code\\\">s</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Not_found</code> if <code class=\\\"code\\\">c</code> does not occur in <code class=\\\"code\\\">s</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> rindex: bytes =&gt; char =&gt; int;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">rindex s c</code> returns the index of the last occurrence of byte <code class=\\\"code\\\">c</code>\\n    in <code class=\\\"code\\\">s</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Not_found</code> if <code class=\\\"code\\\">c</code> does not occur in <code class=\\\"code\\\">s</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> index_from: bytes =&gt; int =&gt; char =&gt; int;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">index_from s i c</code> returns the index of the first occurrence of\\n    byte <code class=\\\"code\\\">c</code> in <code class=\\\"code\\\">s</code> after position <code class=\\\"code\\\">i</code>.  <code class=\\\"code\\\">Bytes.index s c</code> is\\n    equivalent to <code class=\\\"code\\\">Bytes.index_from s 0 c</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">i</code> is not a valid position in <code class=\\\"code\\\">s</code>.\\n    Raise <code class=\\\"code\\\">Not_found</code> if <code class=\\\"code\\\">c</code> does not occur in <code class=\\\"code\\\">s</code> after position <code class=\\\"code\\\">i</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> rindex_from: bytes =&gt; int =&gt; char =&gt; int;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">rindex_from s i c</code> returns the index of the last occurrence of\\n    byte <code class=\\\"code\\\">c</code> in <code class=\\\"code\\\">s</code> before position <code class=\\\"code\\\">i+1</code>.  <code class=\\\"code\\\">rindex s c</code> is equivalent\\n    to <code class=\\\"code\\\">rindex_from s (Bytes.length s - 1) c</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">i+1</code> is not a valid position in <code class=\\\"code\\\">s</code>.\\n    Raise <code class=\\\"code\\\">Not_found</code> if <code class=\\\"code\\\">c</code> does not occur in <code class=\\\"code\\\">s</code> before position <code class=\\\"code\\\">i+1</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> contains: bytes =&gt; char =&gt; bool;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">contains s c</code> tests if byte <code class=\\\"code\\\">c</code> appears in <code class=\\\"code\\\">s</code>.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> contains_from: bytes =&gt; int =&gt; char =&gt; bool;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">contains_from s start c</code> tests if byte <code class=\\\"code\\\">c</code> appears in <code class=\\\"code\\\">s</code> after\\n    position <code class=\\\"code\\\">start</code>.  <code class=\\\"code\\\">contains s c</code> is equivalent to <code class=\\\"code\\\">contains_from\\n    s 0 c</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">start</code> is not a valid position in <code class=\\\"code\\\">s</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> rcontains_from: bytes =&gt; int =&gt; char =&gt; bool;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">rcontains_from s stop c</code> tests if byte <code class=\\\"code\\\">c</code> appears in <code class=\\\"code\\\">s</code> before\\n    position <code class=\\\"code\\\">stop+1</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">stop &lt; 0</code> or <code class=\\\"code\\\">stop+1</code> is not a valid\\n    position in <code class=\\\"code\\\">s</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> uppercase: bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nReturn a copy of the argument, with all lowercase letters\\n    translated to uppercase, including accented letters of the ISO\\n    Latin-1 (8859-1) character set.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> lowercase: bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nReturn a copy of the argument, with all uppercase letters\\n    translated to lowercase, including accented letters of the ISO\\n    Latin-1 (8859-1) character set.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> capitalize: bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nReturn a copy of the argument, with the first byte set to\\n    uppercase.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> uncapitalize: bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nReturn a copy of the argument, with the first byte set to\\n    lowercase.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">type</span> t = bytes;\\n</pre>\\n<div class=\\\"info \\\">\\nAn alias for the type of byte sequences.<br>\\n</div>\\n\\n\\n<pre><span class=\\\"keyword\\\">let</span> compare: t =&gt; t =&gt; int;\\n</pre><div class=\\\"info \\\">\\nThe comparison function for byte sequences, with the same\\n    specification as <a href=\\\"Pervasives.html#VALcompare\\\"><code class=\\\"code\\\">Pervasives.compare</code></a>.  Along with the type <code class=\\\"code\\\">t</code>,\\n    this function <code class=\\\"code\\\">compare</code> allows the module <code class=\\\"code\\\">Bytes</code> to be passed as\\n    argument to the functors <a href=\\\"Set.Make.html\\\"><code class=\\\"code\\\">Set.Make</code></a> and <a href=\\\"Map.Make.html\\\"><code class=\\\"code\\\">Map.Make</code></a>.<br>\\n</div>\\n<br>\\n<h4 id=\\\"4_Unsafeconversionsforadvancedusers\\\">Unsafe conversions (for advanced users)</h4>\\n<p>\\n\\n    This section describes unsafe, low-level conversion functions\\n    between <code class=\\\"code\\\">bytes</code> and <code class=\\\"code\\\">string</code>. They do not copy the internal data;\\n    used improperly, they can break the immutability invariant on\\n    strings provided by the <code class=\\\"code\\\">-safe-string</code> option. They are available for\\n    expert library authors, but for most purposes you should use the\\n    always-correct <a href=\\\"Bytes.html#VALto_string\\\"><code class=\\\"code\\\">Bytes.to_string</code></a> and <a href=\\\"Bytes.html#VALof_string\\\"><code class=\\\"code\\\">Bytes.of_string</code></a> instead.<br>\\n\\n</p><pre><span class=\\\"keyword\\\">let</span> unsafe_to_string: bytes =&gt; string;\\n</pre><div class=\\\"info \\\">\\nUnsafely convert a byte sequence into a string.\\n<p>\\n\\n    To reason about the use of <code class=\\\"code\\\">unsafe_to_string</code>, it is convenient to\\n    consider an &quot;ownership&quot; discipline. A piece of code that\\n    manipulates some data &quot;owns&quot; it; there are several disjoint ownership\\n    modes, including:</p><ul>\\n<li>Unique ownership: the data may be accessed and mutated</li>\\n<li>Shared ownership: the data has several owners, that may only\\n      access it, not mutate it.</li>\\n</ul>\\n\\n    Unique ownership is linear: passing the data to another piece of\\n    code means giving up ownership (we cannot write the\\n    data again). A unique owner may decide to make the data shared\\n    (giving up mutation rights on it), but shared data may not become\\n    uniquely-owned again.\\n<p>\\n\\n   <code class=\\\"code\\\">unsafe_to_string s</code> can only be used when the caller owns the byte\\n   sequence <code class=\\\"code\\\">s</code> -- either uniquely or as shared immutable data. The\\n   caller gives up ownership of <code class=\\\"code\\\">s</code>, and gains ownership of the\\n   returned string.\\n</p><p>\\n\\n   There are two valid use-cases that respect this ownership\\n   discipline:\\n</p><p>\\n\\n   1. Creating a string by initializing and mutating a byte sequence\\n   that is never changed after initialization is performed.\\n</p><p>\\n\\n   </p><pre class=\\\"codepre\\\"><span class=\\\"keyword\\\">let</span> string_init len f : string =\\n  let s = Bytes.create len in\\n  for i = 0 to len - 1 do Bytes.set s i (f i) done;\\n  Bytes.unsafe_to_string s\\n   </pre>\\n<p>\\n\\n   This function is safe because the byte sequence <code class=\\\"code\\\">s</code> will never be\\n   accessed or mutated after <code class=\\\"code\\\">unsafe_to_string</code> is called. The\\n   <code class=\\\"code\\\">string_init</code> code gives up ownership of <code class=\\\"code\\\">s</code>, and returns the\\n   ownership of the resulting string to its caller.\\n</p><p>\\n\\n   Note that it would be unsafe if <code class=\\\"code\\\">s</code> was passed as an additional\\n   parameter to the function <code class=\\\"code\\\">f</code> as it could escape this way and be\\n   mutated in the future -- <code class=\\\"code\\\">string_init</code> would give up ownership of\\n   <code class=\\\"code\\\">s</code> to pass it to <code class=\\\"code\\\">f</code>, and could not call <code class=\\\"code\\\">unsafe_to_string</code>\\n   safely.\\n</p><p>\\n\\n   We have provided the <a href=\\\"String.html#VALinit\\\"><code class=\\\"code\\\">String.init</code></a>, <a href=\\\"String.html#VALmap\\\"><code class=\\\"code\\\">String.map</code></a> and\\n   <a href=\\\"String.html#VALmapi\\\"><code class=\\\"code\\\">String.mapi</code></a> functions to cover most cases of building\\n   new strings. You should prefer those over <code class=\\\"code\\\">to_string</code> or\\n   <code class=\\\"code\\\">unsafe_to_string</code> whenever applicable.\\n</p><p>\\n\\n   2. Temporarily giving ownership of a byte sequence to a function\\n   that expects a uniquely owned string and returns ownership back, so\\n   that we can mutate the sequence again after the call ended.\\n</p><p>\\n\\n   </p><pre class=\\\"codepre\\\"><span class=\\\"keyword\\\">let</span> bytes_length (s : bytes) =\\n  String.length (Bytes.unsafe_to_string s)\\n   </pre>\\n<p>\\n\\n   In this use-case, we do not promise that <code class=\\\"code\\\">s</code> will never be mutated\\n   after the call to <code class=\\\"code\\\">bytes_length s</code>. The <a href=\\\"String.html#VALlength\\\"><code class=\\\"code\\\">String.length</code></a> function\\n   temporarily borrows unique ownership of the byte sequence\\n   (and sees it as a <code class=\\\"code\\\">string</code>), but returns this ownership back to\\n   the caller, which may assume that <code class=\\\"code\\\">s</code> is still a valid byte\\n   sequence after the call. Note that this is only correct because we\\n   know that <a href=\\\"String.html#VALlength\\\"><code class=\\\"code\\\">String.length</code></a> does not capture its argument -- it could\\n   escape by a side-channel such as a memoization combinator.\\n</p><p>\\n\\n   The caller may not mutate <code class=\\\"code\\\">s</code> while the string is borrowed (it has\\n   temporarily given up ownership). This affects concurrent programs,\\n   but also higher-order functions: if <code class=\\\"code\\\">String.length</code> returned\\n   a closure to be called later, <code class=\\\"code\\\">s</code> should not be mutated until this\\n   closure is fully applied and returns ownership.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> unsafe_of_string: string =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nUnsafely convert a shared string to a byte sequence that should\\n    not be mutated.\\n<p>\\n\\n    The same ownership discipline that makes <code class=\\\"code\\\">unsafe_to_string</code>\\n    correct applies to <code class=\\\"code\\\">unsafe_of_string</code>: you may use it if you were\\n    the owner of the <code class=\\\"code\\\">string</code> value, and you will own the return\\n    <code class=\\\"code\\\">bytes</code> in the same mode.\\n</p><p>\\n\\n    In practice, unique ownership of string values is extremely\\n    difficult to reason about correctly. You should always assume\\n    strings are shared, never uniquely owned.\\n</p><p>\\n\\n    For example, string literals are implicitly shared by the\\n    compiler, so you never uniquely own them.\\n</p><p>\\n\\n    </p><pre class=\\\"codepre\\\"><span class=\\\"keyword\\\">let</span> incorrect = Bytes.unsafe_of_string &quot;hello&quot;\\nlet s = Bytes.of_string &quot;hello&quot;\\n    </pre>\\n<p>\\n\\n    The first declaration is incorrect, because the string literal\\n    <code class=\\\"code\\\">&quot;hello&quot;</code> could be shared by the compiler with other parts of the\\n    program, and mutating <code class=\\\"code\\\">incorrect</code> is a bug. You must always use\\n    the second version, which performs a copy and is thus correct.\\n</p><p>\\n\\n    Assuming unique ownership of strings that are not string\\n    literals, but are (partly) built from string literals, is also\\n    incorrect. For example, mutating <code class=\\\"code\\\">unsafe_of_string (&quot;foo&quot; ^ s)</code>\\n    could mutate the shared string <code class=\\\"code\\\">&quot;foo&quot;</code> -- assuming a rope-like\\n    representation of strings. More generally, functions operating on\\n    strings will assume shared ownership, they do not preserve unique\\n    ownership. It is thus incorrect to assume unique ownership of the\\n    result of <code class=\\\"code\\\">unsafe_of_string</code>.\\n</p><p>\\n\\n    The only case we have reasonable confidence is safe is if the\\n    produced <code class=\\\"code\\\">bytes</code> is shared -- used as an immutable byte\\n    sequence. This is possibly useful for incremental migration of\\n    low-level programs that manipulate immutable sequences of bytes\\n    (for example <a href=\\\"Marshal.html#VALfrom_bytes\\\"><code class=\\\"code\\\">Marshal.from_bytes</code></a>) and previously used the\\n    <code class=\\\"code\\\">string</code> type for this purpose.<br>\\n</p></div>\\n</div>\"\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t\"pathContext\": {\n\t\t\t\"relativePath\": \"api/Bytes.html\"\n\t\t}\n\t};\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---api-bytes-html-90e04ee29275a12cfbf0.js","module.exports = {\n\t\"data\": {\n\t\t\"file\": {\n\t\t\t\"relativePath\": \"api/Bytes.html\",\n\t\t\t\"childRawHtml\": {\n\t\t\t\t\"content\": \"<div class=\\\"ocamldoc\\\">\\n<div class=\\\"navbar\\\"><a class=\\\"pre\\\" href=\\\"Buffer.html\\\" title=\\\"Buffer\\\">Previous</a>\\n&#xA0;<a class=\\\"up\\\" href=\\\"index.html\\\" title=\\\"Index\\\">Up</a>\\n&#xA0;<a class=\\\"post\\\" href=\\\"BytesLabels.html\\\" title=\\\"BytesLabels\\\">Next</a>\\n</div>\\n<h1>Module <a href=\\\"type_Bytes.html\\\">Bytes</a></h1>\\n\\n<pre><span class=\\\"keyword\\\">module</span> Bytes: sig .. end</pre><div class=\\\"info module top\\\">\\nByte sequence operations.\\n<p>\\n\\n   A byte sequence is a mutable data structure that contains a\\n   fixed-length sequence of bytes. Each byte can be indexed in\\n   constant time for reading or writing.\\n</p><p>\\n\\n   Given a byte sequence <code class=\\\"code\\\">s</code> of length <code class=\\\"code\\\">l</code>, we can access each of the\\n   <code class=\\\"code\\\">l</code> bytes of <code class=\\\"code\\\">s</code> via its index in the sequence. Indexes start at\\n   <code class=\\\"code\\\">0</code>, and we will call an index valid in <code class=\\\"code\\\">s</code> if it falls within the\\n   range <code class=\\\"code\\\">[0...l-1]</code> (inclusive). A position is the point between two\\n   bytes or at the beginning or end of the sequence.  We call a\\n   position valid in <code class=\\\"code\\\">s</code> if it falls within the range <code class=\\\"code\\\">[0...l]</code>\\n   (inclusive). Note that the byte at index <code class=\\\"code\\\">n</code> is between positions\\n   <code class=\\\"code\\\">n</code> and <code class=\\\"code\\\">n+1</code>.\\n</p><p>\\n\\n   Two parameters <code class=\\\"code\\\">start</code> and <code class=\\\"code\\\">len</code> are said to designate a valid\\n   range of <code class=\\\"code\\\">s</code> if <code class=\\\"code\\\">len &gt;= 0</code> and <code class=\\\"code\\\">start</code> and <code class=\\\"code\\\">start+len</code> are valid\\n   positions in <code class=\\\"code\\\">s</code>.\\n</p><p>\\n\\n   Byte sequences can be modified in place, for instance via the <code class=\\\"code\\\">set</code>\\n   and <code class=\\\"code\\\">blit</code> functions described below.  See also strings (module\\n   <a href=\\\"String.html\\\"><code class=\\\"code\\\">String</code></a>), which are almost the same data structure, but cannot be\\n   modified in place.\\n</p><p>\\n\\n   Bytes are represented by the OCaml type <code class=\\\"code\\\">char</code>.<br>\\n<b>Since</b> 4.02.0<br>\\n</p></div>\\n<hr width=\\\"100%\\\">\\n\\n<pre><span class=\\\"keyword\\\">let</span> length: bytes =&gt; int;\\n</pre><div class=\\\"info \\\">\\nReturn the length (number of bytes) of the argument.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> get: bytes =&gt; int =&gt; char;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">get s n</code> returns the byte at index <code class=\\\"code\\\">n</code> in argument <code class=\\\"code\\\">s</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">n</code> not a valid index in <code class=\\\"code\\\">s</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> set: bytes =&gt; int =&gt; char =&gt; unit;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">set s n c</code> modifies <code class=\\\"code\\\">s</code> in place, replacing the byte at index <code class=\\\"code\\\">n</code>\\n    with <code class=\\\"code\\\">c</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">n</code> is not a valid index in <code class=\\\"code\\\">s</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> create: int =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">create n</code> returns a new byte sequence of length <code class=\\\"code\\\">n</code>. The\\n    sequence is uninitialized and contains arbitrary bytes.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">n &lt; 0</code> or <code class=\\\"code\\\">n &gt; </code><a href=\\\"Sys.html#VALmax_string_length\\\"><code class=\\\"code\\\">Sys.max_string_length</code></a>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> make: int =&gt; char =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">make n c</code> returns a new byte sequence of length <code class=\\\"code\\\">n</code>, filled with\\n    the byte <code class=\\\"code\\\">c</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">n &lt; 0</code> or <code class=\\\"code\\\">n &gt; </code><a href=\\\"Sys.html#VALmax_string_length\\\"><code class=\\\"code\\\">Sys.max_string_length</code></a>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> init: int =&gt; (int =&gt; char) =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">Bytes.init n f</code> returns a fresh byte sequence of length <code class=\\\"code\\\">n</code>, with\\n    character <code class=\\\"code\\\">i</code> initialized to the result of <code class=\\\"code\\\">f i</code> (in increasing\\n    index order).\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">n &lt; 0</code> or <code class=\\\"code\\\">n &gt; </code><a href=\\\"Sys.html#VALmax_string_length\\\"><code class=\\\"code\\\">Sys.max_string_length</code></a>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> empty: bytes;\\n</pre><div class=\\\"info \\\">\\nA byte sequence of size 0.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> copy: bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nReturn a new byte sequence that contains the same bytes as the\\n    argument.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> of_string: string =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nReturn a new byte sequence that contains the same bytes as the\\n    given string.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> to_string: bytes =&gt; string;\\n</pre><div class=\\\"info \\\">\\nReturn a new string that contains the same bytes as the given byte\\n    sequence.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> sub: bytes =&gt; int =&gt; int =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">sub s start len</code> returns a new byte sequence of length <code class=\\\"code\\\">len</code>,\\n    containing the subsequence of <code class=\\\"code\\\">s</code> that starts at position <code class=\\\"code\\\">start</code>\\n    and has length <code class=\\\"code\\\">len</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">start</code> and <code class=\\\"code\\\">len</code> do not designate a\\n    valid range of <code class=\\\"code\\\">s</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> sub_string: bytes =&gt; int =&gt; int =&gt; string;\\n</pre><div class=\\\"info \\\">\\nSame as <code class=\\\"code\\\">sub</code> but return a string instead of a byte sequence.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> extend: bytes =&gt; int =&gt; int =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">extend s left right</code> returns a new byte sequence that contains\\n    the bytes of <code class=\\\"code\\\">s</code>, with <code class=\\\"code\\\">left</code> uninitialized bytes prepended and\\n    <code class=\\\"code\\\">right</code> uninitialized bytes appended to it. If <code class=\\\"code\\\">left</code> or <code class=\\\"code\\\">right</code>\\n    is negative, then bytes are removed (instead of appended) from\\n    the corresponding side of <code class=\\\"code\\\">s</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if the result length is negative or\\n    longer than <a href=\\\"Sys.html#VALmax_string_length\\\"><code class=\\\"code\\\">Sys.max_string_length</code></a> bytes.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> fill: bytes =&gt; int =&gt; int =&gt; char =&gt; unit;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">fill s start len c</code> modifies <code class=\\\"code\\\">s</code> in place, replacing <code class=\\\"code\\\">len</code>\\n    characters with <code class=\\\"code\\\">c</code>, starting at <code class=\\\"code\\\">start</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">start</code> and <code class=\\\"code\\\">len</code> do not designate a\\n    valid range of <code class=\\\"code\\\">s</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> blit: bytes =&gt; int =&gt; bytes =&gt; int =&gt; int =&gt; unit;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">blit src srcoff dst dstoff len</code> copies <code class=\\\"code\\\">len</code> bytes from sequence\\n    <code class=\\\"code\\\">src</code>, starting at index <code class=\\\"code\\\">srcoff</code>, to sequence <code class=\\\"code\\\">dst</code>, starting at\\n    index <code class=\\\"code\\\">dstoff</code>. It works correctly even if <code class=\\\"code\\\">src</code> and <code class=\\\"code\\\">dst</code> are the\\n    same byte sequence, and the source and destination intervals\\n    overlap.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">srcoff</code> and <code class=\\\"code\\\">len</code> do not\\n    designate a valid range of <code class=\\\"code\\\">src</code>, or if <code class=\\\"code\\\">dstoff</code> and <code class=\\\"code\\\">len</code>\\n    do not designate a valid range of <code class=\\\"code\\\">dst</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> blit_string: string =&gt; int =&gt; bytes =&gt; int =&gt; int =&gt; unit;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">blit src srcoff dst dstoff len</code> copies <code class=\\\"code\\\">len</code> bytes from string\\n    <code class=\\\"code\\\">src</code>, starting at index <code class=\\\"code\\\">srcoff</code>, to byte sequence <code class=\\\"code\\\">dst</code>,\\n    starting at index <code class=\\\"code\\\">dstoff</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">srcoff</code> and <code class=\\\"code\\\">len</code> do not\\n    designate a valid range of <code class=\\\"code\\\">src</code>, or if <code class=\\\"code\\\">dstoff</code> and <code class=\\\"code\\\">len</code>\\n    do not designate a valid range of <code class=\\\"code\\\">dst</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> concat: bytes =&gt; list bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">concat sep sl</code> concatenates the list of byte sequences <code class=\\\"code\\\">sl</code>,\\n    inserting the separator byte sequence <code class=\\\"code\\\">sep</code> between each, and\\n    returns the result as a new byte sequence.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if the result is longer than\\n    <a href=\\\"Sys.html#VALmax_string_length\\\"><code class=\\\"code\\\">Sys.max_string_length</code></a> bytes.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> cat: bytes =&gt; bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">cat s1 s2</code> concatenates <code class=\\\"code\\\">s1</code> and <code class=\\\"code\\\">s2</code> and returns the result\\n     as new byte sequence.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if the result is longer than\\n    <a href=\\\"Sys.html#VALmax_string_length\\\"><code class=\\\"code\\\">Sys.max_string_length</code></a> bytes.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> iter: (char =&gt; unit) =&gt; bytes =&gt; unit;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">iter f s</code> applies function <code class=\\\"code\\\">f</code> in turn to all the bytes of <code class=\\\"code\\\">s</code>.\\n    It is equivalent to <code class=\\\"code\\\">f (get s 0); f (get s 1); ...; f (get s\\n    (length s - 1)); ()</code>.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> iteri: (int =&gt; char =&gt; unit) =&gt; bytes =&gt; unit;\\n</pre><div class=\\\"info \\\">\\nSame as <a href=\\\"Bytes.html#VALiter\\\"><code class=\\\"code\\\">Bytes.iter</code></a>, but the function is applied to the index of\\n    the byte as first argument and the byte itself as second\\n    argument.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> map: (char =&gt; char) =&gt; bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">map f s</code> applies function <code class=\\\"code\\\">f</code> in turn to all the bytes of <code class=\\\"code\\\">s</code>\\n    (in increasing index order) and stores the resulting bytes in\\n    a new sequence that is returned as the result.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> mapi: (int =&gt; char =&gt; char) =&gt; bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">mapi f s</code> calls <code class=\\\"code\\\">f</code> with each character of <code class=\\\"code\\\">s</code> and its\\n    index (in increasing index order) and stores the resulting bytes\\n    in a new sequence that is returned as the result.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> trim: bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nReturn a copy of the argument, without leading and trailing\\n    whitespace. The bytes regarded as whitespace are the ASCII\\n    characters <code class=\\\"code\\\">&apos; &apos;</code>, <code class=\\\"code\\\">&apos;\\\\012&apos;</code>, <code class=\\\"code\\\">&apos;\\\\n&apos;</code>, <code class=\\\"code\\\">&apos;\\\\r&apos;</code>, and <code class=\\\"code\\\">&apos;\\\\t&apos;</code>.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> escaped: bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nReturn a copy of the argument, with special characters represented\\n    by escape sequences, following the lexical conventions of OCaml.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if the result is longer than\\n    <a href=\\\"Sys.html#VALmax_string_length\\\"><code class=\\\"code\\\">Sys.max_string_length</code></a> bytes.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> index: bytes =&gt; char =&gt; int;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">index s c</code> returns the index of the first occurrence of byte <code class=\\\"code\\\">c</code>\\n    in <code class=\\\"code\\\">s</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Not_found</code> if <code class=\\\"code\\\">c</code> does not occur in <code class=\\\"code\\\">s</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> rindex: bytes =&gt; char =&gt; int;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">rindex s c</code> returns the index of the last occurrence of byte <code class=\\\"code\\\">c</code>\\n    in <code class=\\\"code\\\">s</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Not_found</code> if <code class=\\\"code\\\">c</code> does not occur in <code class=\\\"code\\\">s</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> index_from: bytes =&gt; int =&gt; char =&gt; int;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">index_from s i c</code> returns the index of the first occurrence of\\n    byte <code class=\\\"code\\\">c</code> in <code class=\\\"code\\\">s</code> after position <code class=\\\"code\\\">i</code>.  <code class=\\\"code\\\">Bytes.index s c</code> is\\n    equivalent to <code class=\\\"code\\\">Bytes.index_from s 0 c</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">i</code> is not a valid position in <code class=\\\"code\\\">s</code>.\\n    Raise <code class=\\\"code\\\">Not_found</code> if <code class=\\\"code\\\">c</code> does not occur in <code class=\\\"code\\\">s</code> after position <code class=\\\"code\\\">i</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> rindex_from: bytes =&gt; int =&gt; char =&gt; int;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">rindex_from s i c</code> returns the index of the last occurrence of\\n    byte <code class=\\\"code\\\">c</code> in <code class=\\\"code\\\">s</code> before position <code class=\\\"code\\\">i+1</code>.  <code class=\\\"code\\\">rindex s c</code> is equivalent\\n    to <code class=\\\"code\\\">rindex_from s (Bytes.length s - 1) c</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">i+1</code> is not a valid position in <code class=\\\"code\\\">s</code>.\\n    Raise <code class=\\\"code\\\">Not_found</code> if <code class=\\\"code\\\">c</code> does not occur in <code class=\\\"code\\\">s</code> before position <code class=\\\"code\\\">i+1</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> contains: bytes =&gt; char =&gt; bool;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">contains s c</code> tests if byte <code class=\\\"code\\\">c</code> appears in <code class=\\\"code\\\">s</code>.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> contains_from: bytes =&gt; int =&gt; char =&gt; bool;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">contains_from s start c</code> tests if byte <code class=\\\"code\\\">c</code> appears in <code class=\\\"code\\\">s</code> after\\n    position <code class=\\\"code\\\">start</code>.  <code class=\\\"code\\\">contains s c</code> is equivalent to <code class=\\\"code\\\">contains_from\\n    s 0 c</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">start</code> is not a valid position in <code class=\\\"code\\\">s</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> rcontains_from: bytes =&gt; int =&gt; char =&gt; bool;\\n</pre><div class=\\\"info \\\">\\n<code class=\\\"code\\\">rcontains_from s stop c</code> tests if byte <code class=\\\"code\\\">c</code> appears in <code class=\\\"code\\\">s</code> before\\n    position <code class=\\\"code\\\">stop+1</code>.\\n<p>\\n\\n    Raise <code class=\\\"code\\\">Invalid_argument</code> if <code class=\\\"code\\\">stop &lt; 0</code> or <code class=\\\"code\\\">stop+1</code> is not a valid\\n    position in <code class=\\\"code\\\">s</code>.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> uppercase: bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nReturn a copy of the argument, with all lowercase letters\\n    translated to uppercase, including accented letters of the ISO\\n    Latin-1 (8859-1) character set.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> lowercase: bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nReturn a copy of the argument, with all uppercase letters\\n    translated to lowercase, including accented letters of the ISO\\n    Latin-1 (8859-1) character set.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> capitalize: bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nReturn a copy of the argument, with the first byte set to\\n    uppercase.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> uncapitalize: bytes =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nReturn a copy of the argument, with the first byte set to\\n    lowercase.<br>\\n</div>\\n\\n<pre><span class=\\\"keyword\\\">type</span> t = bytes;\\n</pre>\\n<div class=\\\"info \\\">\\nAn alias for the type of byte sequences.<br>\\n</div>\\n\\n\\n<pre><span class=\\\"keyword\\\">let</span> compare: t =&gt; t =&gt; int;\\n</pre><div class=\\\"info \\\">\\nThe comparison function for byte sequences, with the same\\n    specification as <a href=\\\"Pervasives.html#VALcompare\\\"><code class=\\\"code\\\">Pervasives.compare</code></a>.  Along with the type <code class=\\\"code\\\">t</code>,\\n    this function <code class=\\\"code\\\">compare</code> allows the module <code class=\\\"code\\\">Bytes</code> to be passed as\\n    argument to the functors <a href=\\\"Set.Make.html\\\"><code class=\\\"code\\\">Set.Make</code></a> and <a href=\\\"Map.Make.html\\\"><code class=\\\"code\\\">Map.Make</code></a>.<br>\\n</div>\\n<br>\\n<h4 id=\\\"4_Unsafeconversionsforadvancedusers\\\">Unsafe conversions (for advanced users)</h4>\\n<p>\\n\\n    This section describes unsafe, low-level conversion functions\\n    between <code class=\\\"code\\\">bytes</code> and <code class=\\\"code\\\">string</code>. They do not copy the internal data;\\n    used improperly, they can break the immutability invariant on\\n    strings provided by the <code class=\\\"code\\\">-safe-string</code> option. They are available for\\n    expert library authors, but for most purposes you should use the\\n    always-correct <a href=\\\"Bytes.html#VALto_string\\\"><code class=\\\"code\\\">Bytes.to_string</code></a> and <a href=\\\"Bytes.html#VALof_string\\\"><code class=\\\"code\\\">Bytes.of_string</code></a> instead.<br>\\n\\n</p><pre><span class=\\\"keyword\\\">let</span> unsafe_to_string: bytes =&gt; string;\\n</pre><div class=\\\"info \\\">\\nUnsafely convert a byte sequence into a string.\\n<p>\\n\\n    To reason about the use of <code class=\\\"code\\\">unsafe_to_string</code>, it is convenient to\\n    consider an &quot;ownership&quot; discipline. A piece of code that\\n    manipulates some data &quot;owns&quot; it; there are several disjoint ownership\\n    modes, including:</p><ul>\\n<li>Unique ownership: the data may be accessed and mutated</li>\\n<li>Shared ownership: the data has several owners, that may only\\n      access it, not mutate it.</li>\\n</ul>\\n\\n    Unique ownership is linear: passing the data to another piece of\\n    code means giving up ownership (we cannot write the\\n    data again). A unique owner may decide to make the data shared\\n    (giving up mutation rights on it), but shared data may not become\\n    uniquely-owned again.\\n<p>\\n\\n   <code class=\\\"code\\\">unsafe_to_string s</code> can only be used when the caller owns the byte\\n   sequence <code class=\\\"code\\\">s</code> -- either uniquely or as shared immutable data. The\\n   caller gives up ownership of <code class=\\\"code\\\">s</code>, and gains ownership of the\\n   returned string.\\n</p><p>\\n\\n   There are two valid use-cases that respect this ownership\\n   discipline:\\n</p><p>\\n\\n   1. Creating a string by initializing and mutating a byte sequence\\n   that is never changed after initialization is performed.\\n</p><p>\\n\\n   </p><pre class=\\\"codepre\\\"><span class=\\\"keyword\\\">let</span> string_init len f : string =\\n  let s = Bytes.create len in\\n  for i = 0 to len - 1 do Bytes.set s i (f i) done;\\n  Bytes.unsafe_to_string s\\n   </pre>\\n<p>\\n\\n   This function is safe because the byte sequence <code class=\\\"code\\\">s</code> will never be\\n   accessed or mutated after <code class=\\\"code\\\">unsafe_to_string</code> is called. The\\n   <code class=\\\"code\\\">string_init</code> code gives up ownership of <code class=\\\"code\\\">s</code>, and returns the\\n   ownership of the resulting string to its caller.\\n</p><p>\\n\\n   Note that it would be unsafe if <code class=\\\"code\\\">s</code> was passed as an additional\\n   parameter to the function <code class=\\\"code\\\">f</code> as it could escape this way and be\\n   mutated in the future -- <code class=\\\"code\\\">string_init</code> would give up ownership of\\n   <code class=\\\"code\\\">s</code> to pass it to <code class=\\\"code\\\">f</code>, and could not call <code class=\\\"code\\\">unsafe_to_string</code>\\n   safely.\\n</p><p>\\n\\n   We have provided the <a href=\\\"String.html#VALinit\\\"><code class=\\\"code\\\">String.init</code></a>, <a href=\\\"String.html#VALmap\\\"><code class=\\\"code\\\">String.map</code></a> and\\n   <a href=\\\"String.html#VALmapi\\\"><code class=\\\"code\\\">String.mapi</code></a> functions to cover most cases of building\\n   new strings. You should prefer those over <code class=\\\"code\\\">to_string</code> or\\n   <code class=\\\"code\\\">unsafe_to_string</code> whenever applicable.\\n</p><p>\\n\\n   2. Temporarily giving ownership of a byte sequence to a function\\n   that expects a uniquely owned string and returns ownership back, so\\n   that we can mutate the sequence again after the call ended.\\n</p><p>\\n\\n   </p><pre class=\\\"codepre\\\"><span class=\\\"keyword\\\">let</span> bytes_length (s : bytes) =\\n  String.length (Bytes.unsafe_to_string s)\\n   </pre>\\n<p>\\n\\n   In this use-case, we do not promise that <code class=\\\"code\\\">s</code> will never be mutated\\n   after the call to <code class=\\\"code\\\">bytes_length s</code>. The <a href=\\\"String.html#VALlength\\\"><code class=\\\"code\\\">String.length</code></a> function\\n   temporarily borrows unique ownership of the byte sequence\\n   (and sees it as a <code class=\\\"code\\\">string</code>), but returns this ownership back to\\n   the caller, which may assume that <code class=\\\"code\\\">s</code> is still a valid byte\\n   sequence after the call. Note that this is only correct because we\\n   know that <a href=\\\"String.html#VALlength\\\"><code class=\\\"code\\\">String.length</code></a> does not capture its argument -- it could\\n   escape by a side-channel such as a memoization combinator.\\n</p><p>\\n\\n   The caller may not mutate <code class=\\\"code\\\">s</code> while the string is borrowed (it has\\n   temporarily given up ownership). This affects concurrent programs,\\n   but also higher-order functions: if <code class=\\\"code\\\">String.length</code> returned\\n   a closure to be called later, <code class=\\\"code\\\">s</code> should not be mutated until this\\n   closure is fully applied and returns ownership.<br>\\n</p></div>\\n\\n<pre><span class=\\\"keyword\\\">let</span> unsafe_of_string: string =&gt; bytes;\\n</pre><div class=\\\"info \\\">\\nUnsafely convert a shared string to a byte sequence that should\\n    not be mutated.\\n<p>\\n\\n    The same ownership discipline that makes <code class=\\\"code\\\">unsafe_to_string</code>\\n    correct applies to <code class=\\\"code\\\">unsafe_of_string</code>: you may use it if you were\\n    the owner of the <code class=\\\"code\\\">string</code> value, and you will own the return\\n    <code class=\\\"code\\\">bytes</code> in the same mode.\\n</p><p>\\n\\n    In practice, unique ownership of string values is extremely\\n    difficult to reason about correctly. You should always assume\\n    strings are shared, never uniquely owned.\\n</p><p>\\n\\n    For example, string literals are implicitly shared by the\\n    compiler, so you never uniquely own them.\\n</p><p>\\n\\n    </p><pre class=\\\"codepre\\\"><span class=\\\"keyword\\\">let</span> incorrect = Bytes.unsafe_of_string &quot;hello&quot;\\nlet s = Bytes.of_string &quot;hello&quot;\\n    </pre>\\n<p>\\n\\n    The first declaration is incorrect, because the string literal\\n    <code class=\\\"code\\\">&quot;hello&quot;</code> could be shared by the compiler with other parts of the\\n    program, and mutating <code class=\\\"code\\\">incorrect</code> is a bug. You must always use\\n    the second version, which performs a copy and is thus correct.\\n</p><p>\\n\\n    Assuming unique ownership of strings that are not string\\n    literals, but are (partly) built from string literals, is also\\n    incorrect. For example, mutating <code class=\\\"code\\\">unsafe_of_string (&quot;foo&quot; ^ s)</code>\\n    could mutate the shared string <code class=\\\"code\\\">&quot;foo&quot;</code> -- assuming a rope-like\\n    representation of strings. More generally, functions operating on\\n    strings will assume shared ownership, they do not preserve unique\\n    ownership. It is thus incorrect to assume unique ownership of the\\n    result of <code class=\\\"code\\\">unsafe_of_string</code>.\\n</p><p>\\n\\n    The only case we have reasonable confidence is safe is if the\\n    produced <code class=\\\"code\\\">bytes</code> is shared -- used as an immutable byte\\n    sequence. This is possibly useful for incremental migration of\\n    low-level programs that manipulate immutable sequences of bytes\\n    (for example <a href=\\\"Marshal.html#VALfrom_bytes\\\"><code class=\\\"code\\\">Marshal.from_bytes</code></a>) and previously used the\\n    <code class=\\\"code\\\">string</code> type for this purpose.<br>\\n</p></div>\\n</div>\"\n\t\t\t}\n\t\t}\n\t},\n\t\"pathContext\": {\n\t\t\"relativePath\": \"api/Bytes.html\"\n\t}\n};\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/api-bytes-html.json\n// module id = ./node_modules/json-loader/index.js!./.cache/json/api-bytes-html.json\n// module chunks = 286"],"sourceRoot":""}